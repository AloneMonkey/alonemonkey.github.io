<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AloneMonkey</title>
  <subtitle>Coder Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.alonemonkey.com/"/>
  <updated>2017-06-02T06:17:34.000Z</updated>
  <id>http://www.alonemonkey.com/</id>
  
  <author>
    <name>AloneMonkey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS成长之路开售！</title>
    <link href="http://www.alonemonkey.com/2017/06/02/ios-book-pr/"/>
    <id>http://www.alonemonkey.com/2017/06/02/ios-book-pr/</id>
    <published>2017-06-01T16:00:00.000Z</published>
    <updated>2017-06-02T06:17:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过 3 个月的筹备 iOS 成长之路第二期和大家见面啦。经历了第一期的蹒跚发布后，终于在盛夏迎来了更好的第二期。这一期相比第一期更有料了，从第一期的 8 篇文章增加到 12 篇文章。</p>
<p>这一期的内容也提供了更多的广度和深度，从基于 Rx 的网络层设计到 AFN 源码解析，从 Swift 性能分析到 LLVM 体验，从 SpriteKit 到 APM 监控 SDK 的架构设计。希望大家会喜欢这一期。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><p>Chris Lattner 访谈录(下)</p>
<p>译者：@故胤道长，亚马逊 iOS 工程师，曾就职于 Uber。</p>
<p>博客：<a href="http://www.jianshu.com/u/8d5b91490ca5" target="_blank" rel="external">http://www.jianshu.com/u/8d5b91490ca5</a></p>
</li>
<li><p>动手玩 LLVM</p>
<p>作者：戴铭，滴滴出行技术专家。最近正在研究 iOS 编译相关底层技术，用来解决工程优化问题。</p>
<p>博客：<a href="https://ming1016.github.io/" target="_blank" rel="external">https://ming1016.github.io/</a></p>
</li>
<li><p>Swift 性能分析</p>
<p>作者：唐巧，小猿搜题产品技术负责人，6 年 iOS 开发经验，《iOS开发进阶》作者。</p>
<p>博客：<a href="http://blog.devtang.com/about/" target="_blank" rel="external">http://blog.devtang.com/about/</a></p>
</li>
<li><p>监控SDK的架构设计实践(<strong>6月5号上线</strong>)</p>
<p>作者：王朝成， @圣迪 , 饿了么移动架构师。耕耘移动基础设施的建设，致力于移动大数据与人工智能的结合</p>
<p>博客：<a href="http://www.jianshu.com/u/a774b58c9b89" target="_blank" rel="external">http://www.jianshu.com/u/a774b58c9b89</a></p>
</li>
<li><p>初识 LLVM</p>
<p>作者：@Alone_Monkey， 网易 iOS 工程师</p>
<p>博客：<a href="http://www.blogfshare.com" target="_blank" rel="external">www.blogfshare.com</a></p>
</li>
<li><p>TCP / IP 漫游</p>
<p>作者：@mrriddler，蚂蚁金服 iOS 工程师。</p>
<p>博客：<a href="http://blog.mrriddler.com" target="_blank" rel="external">blog.mrriddler.com</a></p>
</li>
<li><p>复用的精妙 - UITableView 复用技术原理分析</p>
<p>作者：冬瓜，微博：@冬瓜争做全栈瓜，爱奇艺 iOS 工程师。</p>
<p>博客：<a href="http://www.desgard.com" target="_blank" rel="external">http://www.desgard.com</a></p>
</li>
<li><p>试图取代 TCP 的 QUIC 协议到底是什么</p>
<p>作者：张星宇，@bestswifter，百度 iOS 工程师，喜欢探索问题的本质，讨厌一切不说人话的描述。正在学习前端，励志成为一名大前端全栈工程师。</p>
<p>博客：<a href="https://bestswifter.com/" target="_blank" rel="external">https://bestswifter.com/</a></p>
</li>
<li><p>AFNetworking 源码分析</p>
<p>作者： @涂耀辉 ，今日头条 iOS 工程师</p>
<p>博客：<a href="http://www.jianshu.com/u/14431e509ae8" target="_blank" rel="external">http://www.jianshu.com/u/14431e509ae8</a></p>
</li>
<li><p>SpriteKit 入门与实践</p>
<p>作者：郭鹏，丁香园资深 iOS 工程师</p>
</li>
<li><p>基于 Rx 的网络层实践</p>
<p>作者：李富强，@李富强Jason，美团外卖 iOS 架构师<br>博客：<a href="http://blog.csdn.net/colorapp" target="_blank" rel="external">http://blog.csdn.net/colorapp</a></p>
</li>
<li><p>iOS 组件化 —— 路由设计思路分析</p>
<p>作者： @一缕殇流化隐半边冰霜，饿了么 iOS 工程师，微博 @halfrost</p>
<p>博客：<a href="http://www.jianshu.com/u/12201cdd5d7a" target="_blank" rel="external">http://www.jianshu.com/u/12201cdd5d7a</a></p>
</li>
</ul>
<h2 id="淘宝购买地址"><a href="#淘宝购买地址" class="headerlink" title="淘宝购买地址"></a>淘宝购买地址</h2><p><a href="https://item.taobao.com/item.htm?id=552290531953" target="_blank" rel="external">https://item.taobao.com/item.htm?id=552290531953</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/225849-9d5cec83919493f9.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p>
]]></content>
    
    <summary type="html">
    
      这一期的内容也提供了更多的广度和深度，从基于 Rx 的网络层设计到 AFN 源码解析，从 Swift 性能分析到 LLVM 体验，从 SpriteKit 到 APM 监控 SDK 的架构设计。希望大家会喜欢这一期。
    
    </summary>
    
      <category term="iOS" scheme="http://www.alonemonkey.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.alonemonkey.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章走进Mac逆向的世界</title>
    <link href="http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/"/>
    <id>http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/</id>
    <published>2017-05-30T16:00:00.000Z</published>
    <updated>2017-06-02T01:59:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在玩了iOS逆向之后，看到Mac上面的应用莫名有了一种想要搞事情的冲动。其实在思想上iOS逆向和Mac逆向是差不多的，原理都差不多，走的流程可能不太一样，这篇文章的目的主要是让大家了解一下Mac上面玩逆向的大致流程和分析方法，所以在本文中去实现什么样的功能并不是重点，重点是让大家懂得怎么去分析找到实现。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>既然是逆向分析，总的有个目的，有目的才有动力，那么就以QQ撤回这个功能为例吧，网上也有很多文章讲解应该hook哪个函数，具体的分析过程却不是那么清晰，所以这里还是着重分析的过程，最终的实现大家自由发挥。</p>
<h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><p>在iOS逆向分析中，大致的思想是这样的(不同情况略有差异)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">界面分析  -&gt;  动态分析  -&gt;  静态分析  -&gt;  动态库注入  -&gt;  ...</div></pre></td></tr></table></figure>
<p>那么在Mac逆向过程中，也可以按照这个套路来搞一波。</p>
<h3 id="界面分析"><a href="#界面分析" class="headerlink" title="界面分析"></a>界面分析</h3><p>要分析QQ撤回的动作，这个动作是有在界面上面体现的，别人撤回一条消息后，那条消息会变成被撤回的通知。所以先分析界面上负责处理该状态的类，然后再去看类的调用。</p>
<p>在Mac上面也有类似iOS <code>Reveal</code>的工具叫做<a href="https://www.interface-inspector.com/" target="_blank" rel="external">Interface Inspector</a>。</p>
<p>下载下来后打开，发现是一个需要<code>License</code>的货，既然遇到了那就搞一搞吧。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496202790459.png" alt="image"></p>
<p>首先从界面关键词<code>Register</code>入手吧，拖到<code>hopper</code>,在<code>Strings</code>里面搜索<code>Register</code>。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496202987912.png" alt="image"></p>
<p>找到之后按<code>x</code>查找引用关系，发现是在<code>-[SMEnterLicenseViewController loadView]</code>这个函数里面存在这个字符串。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496203071610.png" alt="image"></p>
<p>继续找到<code>action</code>为<code>-[SMEnterLicenseViewController register:]</code>。</p>
<p>里面会调用<code>[r14 enterLicenseViewControllerDidSelectRegister:r15 withLicenseName:r12 code:rbx];</code></p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496203184764.png" alt="image"></p>
<p>这里<code>registerLicenseWithName:code:</code>里面是通过<code>[SMLicenseManager verifyLicenseWithName:code:]</code>验证的。</p>
<p>那直接修改代码返回<code>YES</code>。</p>
<p><code>Modify -&gt; Assemble Instruction...</code></p>
<p>输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov        eax, 0x1    //eax用来保存返回值</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>生成一个新的可执行文件，<code>File -&gt; Produce New Executable...</code>。</p>
<p>选择<code>Remove Signature</code>。</p>
<p>替换原可执行文件，然后打开，弹出了:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496203632361.png" alt="image"></p>
<p>看来它还验证签名了。</p>
<p>那么找到启动时的回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[SMAppDelegate applicationWillFinishLaunching:]</div></pre></td></tr></table></figure>
<p>可以找到对应的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if ([rax codeSignState] != 0x2) goto loc_100024851;</div></pre></td></tr></table></figure>
<p>如果<code>codeSignState</code>返回不为2就会弹出刚刚那个。</p>
<p>所以这里把:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jne        loc_100024851</div></pre></td></tr></table></figure>
<p>对应的二进制<code>0F 85 CD 03 00 00</code>改成<code>0F 84 CD 03 00 00</code>。</p>
<p>重新打开不显示那个签名问题，但是直接闪退了。</p>
<p>猜测某些地方还有检测，然后<code>exit</code>或者<code>terminate</code>了。</p>
<p>在<code>Strings</code>中查找字符串找到<code>terminate:</code>的引用。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496214065433.png" alt="image"></p>
<p>查看每一处调用，发现这么一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void ___24+[SMLicenseManager load]_block_invoke(void * _block) &#123;</div><div class="line">    if ([SMLicenseManager verifyLicenseWithName:@&quot;Test User&quot; code:@&quot;GAWAE-8C69D-7LZ5H-9D8M3-HVEG7-KHNQC-CQ7RF-SEPQC-CRF82-G47U5-H6DKAB-8SKA7-EWSCM-7Q7SV-MYF4&quot;] != 0x0) &#123;</div><div class="line">            [*_NSApp terminate:0x0];</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作者自己拿了假的<code>License</code>测试，如果通过就直接退出了。</p>
<p>所以这里<code>je         loc_10010ec26</code>对应二进制<code>74 1A</code>改成<code>75 1A</code>。</p>
<p>然后重新生成可执行文件，打开随便填入<code>License</code>注册即可。</p>
<p>额，好像有点扯远了，不过本文的目的就是为了学习Mac逆向的分析过程，所以这一部分并不是多余的。</p>
<p>当然这里还有坑，如何你发现<code>attach process</code>的时候报错的话，请参考<a href="http://bbs.iosre.com/t/fix-bug-for-interface-inspector-on-macos-serria/5665" target="_blank" rel="external">Fix Bug for Interface Inspector on macOS Serria</a>这篇文章重新编译<code>mach_inject_bundle_stub.bundle</code>。</p>
<p>终于准备好了，附加到QQ，选中聊天界面。可以找到<code>MQAIOChatViewController</code>这样的一个<code>ViewController</code>。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496216671572.png" alt="image"></p>
<p>下面通过动态跟踪函数调用来看看这个类的调用流程。</p>
<h3 id="动态跟踪"><a href="#动态跟踪" class="headerlink" title="动态跟踪"></a>动态跟踪</h3><p>动态跟踪的方法有多种，除了iOS逆向中使用的<a href="https://www.frida.re/" target="_blank" rel="external">Frida</a>, lldb , Mac上面还可以使用Dtrace。</p>
<h4 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h4><p><code>Frida</code>是一个通过<code>js</code>和<code>Native</code>交互的跨平台工具，可以通过<code>frida QQ</code>的方式附加，查看当前加载的类，类的方法等等。除此外还可以加载自己的<code>js</code>脚本<code>frida QQ -l trace.js</code>。</p>
<p>在<code>python</code>中，有可以<code>import frida</code>来获取设置以及目标等相关信息，同时也能调用<code>js</code>并获取返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjC.classes.MQAIOChatViewController.$methods</div></pre></td></tr></table></figure>
<p><code>frida</code>还提供了一个非常有用的功能，可以用于此处，也就是<code>frida-trace</code>。</p>
<p>可以通过这个工具来跟踪指定方法或者指定类的调用过程，这里感兴趣的是<code>MQAIOChatViewController</code>这个类的调用过程，所以可以通过如下命令来跟踪：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frida-trace -m &quot;-[MQAIOChatViewController *]&quot; QQ</div></pre></td></tr></table></figure>
<p>然后撤回一条消息可以看到如下调用过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">25623 ms  -[MQAIOChatViewController revokeMessages:0x618000206220 ]</div><div class="line">25623 ms     | -[MQAIOChatViewController topMsgListViewController]</div><div class="line">25623 ms     | -[MQAIOChatViewController topMsgListViewController]</div><div class="line">25625 ms     | -[MQAIOChatViewController scrollViewDidScrollToBottom:0x7fc28b0dffb0 ]</div><div class="line">25632 ms     | -[MQAIOChatViewController scheduleRecognitionLogic]</div><div class="line">25633 ms     | -[MQAIOChatViewController topMsgListViewController]</div><div class="line">25639 ms  -[MQAIOChatViewController isSimplestModel]</div><div class="line">25639 ms  -[MQAIOChatViewController isSimplestModel]</div><div class="line">25639 ms  -[MQAIOChatViewController isSimplestModel]</div></pre></td></tr></table></figure>
<p>这便找到了一个上层撤回的调用，后面还会继续深入。</p>
<h4 id="Dtrace"><a href="#Dtrace" class="headerlink" title="Dtrace"></a>Dtrace</h4><p>讲<code>lldb</code>前，先讲下<code>Dtrace</code>这个Linux上的动态追踪神器，可以通过它来监控应用程序或者内核的调用，所以这里可以用于监控OC函数的调用。</p>
<p>新建文件<code>trace.d</code>，写入内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/usr/sbin/dtrace -s</div><div class="line"></div><div class="line">objc$target:MQAIOChatViewController::entry&#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后找到<code>QQ</code>的进程id <code>ps -e | grep QQ</code>。再运行<code>dtrace</code>脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./trace.d -p 24105</div></pre></td></tr></table></figure>
<p>撤回消息可得到如下输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">2  30436           -revokeMessages::entry</div><div class="line">2  44561  -topMsgListViewController:entry</div><div class="line">2  44561  -topMsgListViewController:entry</div><div class="line">2  30382 -scrollViewDidScrollToBottom::entry</div><div class="line">2  44569  -scheduleRecognitionLogic:entry</div><div class="line">2  44561  -topMsgListViewController:entry</div><div class="line">6  44608           -isSimplestModel:entry</div><div class="line">6  44608           -isSimplestModel:entry</div><div class="line">0  44608           -isSimplestModel:entry</div></pre></td></tr></table></figure>
<p>也可以直接运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dtrace -n &apos;objc$target:MQAIOChatViewController::entry&#123;&#125;&apos; -p 24105</div></pre></td></tr></table></figure>
<p>只是在文件里面可以进行更多的操作。</p>
<h4 id="lldb"><a href="#lldb" class="headerlink" title="lldb"></a>lldb</h4><p><code>lldb</code>这部分的动态跟踪在后面<code>Xcode</code>调试会有讲到。</p>
<h3 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h3><p>找到了函数之后，可以写个动态库注入为了方便调试以及动态库注入这里创建一个<code>dylib</code>的Xcode项目，选择<code>macOS Library</code>，点击创建，Type选择<code>Dynamic</code>。</p>
<p>为了<code>Hook</code>函数，先选择一个现成的库来做，可以选择:</p>
<ul>
<li><a href="https://github.com/alexzielenski/ZKSwizzle" target="_blank" rel="external">ZKSwizzle</a></li>
<li><a href="https://github.com/steipete/Aspects" target="_blank" rel="external">Aspects</a></li>
<li><a href="https://github.com/comex/substitute" target="_blank" rel="external">substitute</a></li>
<li>……</li>
</ul>
<p>这里你可能会想一个撤回一条命令一个文件哪有这么麻烦，而这些都是一般逆向中可能用到的，不针对功能。</p>
<p>我个人倾向于使用<code>substitute</code>，它有着和<code>substrate</code>一样的api接口。</p>
<p>那么首先要编译一个<code>Mac</code>平台的<code>substitute</code>动态库。</p>
<p>直接编译会报错<code>syscall</code>被弃用，到<a href="https://github.com/phracker/MacOSX-SDKs" target="_blank" rel="external">这里</a>下载一个早一点的比如<code>MacOSX10.11.sdk</code>，然后放到<code>/Applications/XCode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</code>下。</p>
<p>然后通过如下命令行编译:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --xcode-sdk macosx10.11 &amp;&amp; make -j8</div></pre></td></tr></table></figure>
<p>在<code>out</code>目录就可以看到生成的动态库。</p>
<p>查看动态库的加载地址，把其重命名为<code>libsubstitute.0.dylib</code>并拷贝到<code>/usr/local/lib/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  out git:(master) ✗ otool -L libsubstitute.dylib</div><div class="line">libsubstitute.dylib:</div><div class="line">	/usr/local/lib/libsubstitute.0.dylib (compatibility version 0.0.0, current version 0.0.0)</div></pre></td></tr></table></figure>
<p>然后把头文件和动态库引入Xcode项目， 然后在构造函数里面hook<code>-[MQAIOChatViewController revokeMessages:]</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &quot;substrate.h&quot;</div><div class="line"></div><div class="line">@class MQAIOChatViewController;</div><div class="line"></div><div class="line">static void (*origin_MQAIOChatViewController_revokeMessages)(MQAIOChatViewController*,SEL,id);</div><div class="line">static void new_MQAIOChatViewController_revokeMessages(MQAIOChatViewController* self,SEL _cmd,id arrays)&#123;</div><div class="line">    NSLog(@&quot;revokeMessages:%@&quot;,arrays);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __attribute__((constructor)) initialize(void) &#123;</div><div class="line">    MSHookMessageEx(objc_getClass(&quot;MQAIOChatViewController&quot;),  @selector(revokeMessages:), (IMP)&amp;new_MQAIOChatViewController_revokeMessages, (IMP*)&amp;origin_MQAIOChatViewController_revokeMessages);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译生成动态库<code>libMacQQRevoke.dylib</code>。</p>
<h3 id="动态库注入"><a href="#动态库注入" class="headerlink" title="动态库注入"></a>动态库注入</h3><p>动态库注入可以通过<code>DYLD_INSERT_LIBRARIES</code>注入，也可以直接注入到可执行文件的<code>Load Command</code>。</p>
<p>这里为了方便就直接通过环境变量注入了。</p>
<p>点击<code>Build Phases</code>左上角的<code>+</code>，然后点击<code>New Run Script Phase</code>。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496284722475.png" alt="image"></p>
<p>写入脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd $&#123;TARGET_BUILD_DIR&#125;</div><div class="line">export DYLD_INSERT_LIBRARIES=./libMacQQRevoke.dylib &amp;&amp; /Applications/QQ.app/Contents/MacOS/QQ</div></pre></td></tr></table></figure>
<p><code>Command + B</code>， 注入动态库，运行QQ。</p>
<p>然后撤回消息，发现消息还在，并且控制台有如下输出。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496285419802.png" alt="image"></p>
<p>也就是Hook生效了，但是重启QQ后，那条消息还是变成了撤回状态。</p>
<p>这个时候需要继续往上层调用去探索。</p>
<h3 id="符号还原-Xcode调试"><a href="#符号还原-Xcode调试" class="headerlink" title="符号还原+Xcode调试"></a>符号还原+Xcode调试</h3><p>为了能看到<code>revokeMessages:</code>被调用的堆栈，先使用<a href="https://github.com/tobefuturer/restore-symbol" target="_blank" rel="external">restore-symbol</a>还原符号，然后再使用<a href="https://github.com/steakknife/unsign" target="_blank" rel="external">unsign</a>去掉签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./restore-symbol QQ -o QQ_symbol</div><div class="line">mv QQ_symbol QQ</div><div class="line">./unsign QQ</div><div class="line">mv QQ.unsigned QQ</div></pre></td></tr></table></figure>
<p>替换原可执行文件之后，在<code>new_MQAIOChatViewController_revokeMessages</code>断点，<code>Command + B</code>重新运行。</p>
<p>然后选择<code>Debug -&gt; Attach to Process</code>。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496287517422.png" alt="image"></p>
<p>附加到QQ进程。</p>
<p>撤回消息，Xcode便断在了<code>new_MQAIOChatViewController_revokeMessages</code>。</p>
<p>查看堆栈如下:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496287617990.png" alt="image"></p>
<p>因为block的符号没恢复，所以看来是block里面调用过来的。</p>
<p>找到block内存地址<code>0x103a69663</code>减去加载基地址<code>0x0000000003757000</code>,对应到文件偏移<code>0x0000000100312663</code>。</p>
<p><code>Hopper</code>加载文件按<code>g</code>跳转到指定地址:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496288222865.png" alt="image"></p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496288264564.png" alt="image"></p>
<p>所以可以找到是从:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[BHMessageChatModel revokeMessageModel:]</div><div class="line">-[MQAIOChatViewController chatMessageModel]</div></pre></td></tr></table></figure>
<p>调过来的。<br>在<code>revokeMessageModel</code>下断点<code>b -[BHMessageChatModel revokeMessageModel:]</code>，再撤回，可以看到调用堆栈。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1496288458933.png" alt="image"></p>
<p>这下应该就比较清楚了。</p>
<p>那么就在比较上层的调用中去处理，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[RecallProcessor solveRecallNotify:isOnline:]</div><div class="line">-[QQMessageRevokeEngine handleRecallNotify:isOnline:]</div></pre></td></tr></table></figure>
<p>测试直接hook<code>-[QQMessageRevokeEngine handleRecallNotify:isOnline:]</code>是不会再本地删除的。</p>
<p>关于hook中的参数类型可以使用<a href="https://github.com/nygard/class-dump" target="_blank" rel="external">class-dump</a> dump出头文件，从头文件可以看到第一个参数是<code>struct RecallModel</code>类型。</p>
<h3 id="lldb-1"><a href="#lldb-1" class="headerlink" title="lldb"></a>lldb</h3><p>补充一下上面说的lldb跟踪程序，有了符号直接可以直接通过符号断点来跟踪程序。比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rb \[MQAIOChatViewController *\]</div><div class="line">br com add 1</div><div class="line">po $rdi</div><div class="line">x/s $rsi</div><div class="line">c</div><div class="line">DONE</div></pre></td></tr></table></figure>
<p>撤回消息即可看到打印结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">po $rdi</div><div class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</div><div class="line"></div><div class="line"> x/s $rsi</div><div class="line">0x10fa1f89e: &quot;revokeMessages:&quot;</div><div class="line"> c</div><div class="line">Process 35302 resuming</div><div class="line">Command #3 &apos;c&apos; continued the target.</div><div class="line"> po $rdi</div><div class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</div><div class="line"></div><div class="line"> x/s $rsi</div><div class="line">0x10fa07e45: &quot;topMsgListViewController&quot;</div><div class="line"> c</div><div class="line">Process 35302 resuming</div><div class="line">Command #3 &apos;c&apos; continued the target.</div><div class="line"> po $rdi</div><div class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</div><div class="line"></div><div class="line"> x/s $rsi</div><div class="line">0x10fa07e45: &quot;topMsgListViewController&quot;</div><div class="line"> c</div><div class="line">Process 35302 resuming</div><div class="line">Command #3 &apos;c&apos; continued the target.</div><div class="line"> po $rdi</div><div class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</div><div class="line"></div><div class="line"> x/s $rsi</div><div class="line">0x10fa1f973: &quot;scheduleRecognitionLogic&quot;</div><div class="line"> c</div><div class="line">Process 35302 resuming</div><div class="line">Command #3 &apos;c&apos; continued the target.</div><div class="line"> po $rdi</div><div class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</div><div class="line"></div><div class="line"> x/s $rsi</div><div class="line">0x10fa07e45: &quot;topMsgListViewController&quot;</div><div class="line"> c</div><div class="line">Process 35302 resuming</div><div class="line">Command #3 &apos;c&apos; continued the target.</div><div class="line"> po $rdi</div><div class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</div><div class="line"></div><div class="line"> x/s $rsi</div><div class="line">0x10f9e881c: &quot;isSimplestModel&quot;</div><div class="line"> c</div><div class="line">Process 35302 resuming</div><div class="line">Command #3 &apos;c&apos; continued the target.</div></pre></td></tr></table></figure>
<p>在x64汇编中，传递参数依次通过以下寄存器传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdi, rsi, rdx, rcx, r8, r9</div></pre></td></tr></table></figure>
<p>在很多动态分析的过程中可以借助lldb调试来帮助分析解决问题。</p>
<h3 id="MachO注入"><a href="#MachO注入" class="headerlink" title="MachO注入"></a>MachO注入</h3><p>为了避免每次从环境变量注入，还可以直接使用<a href="https://github.com/Tyilo/insert_dylib" target="_blank" rel="external">insert_dylib</a>注入可执行文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./insert_dylib --weak /path/to/dylib QQ QQ_patch</div><div class="line">mv QQ_patch QQ</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，Mac上的逆向和iOS逆向差不太多，反而Mac上面操作更方便一些，不用连着手机，还有像<code>Dtrace</code>这样的神器。</p>
<p>这篇文章主要还是领大家走进Mac逆向的世界，其它靠自己慢慢去探索~</p>
<p>相关工具和代码尽在github</p>
<p><a href="https://github.com/AloneMonkey/MacReverse" target="_blank" rel="external">https://github.com/AloneMonkey/MacReverse</a></p>
]]></content>
    
    <summary type="html">
    
      除了iOS上面的逆向，其实Mac上面的逆向原理都差不多，这篇文章就带大家来试一把Mac上面的逆向。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>关于反调试&amp;反反调试那些事</title>
    <link href="http://www.alonemonkey.com/2017/05/25/antiantidebug/"/>
    <id>http://www.alonemonkey.com/2017/05/25/antiantidebug/</id>
    <published>2017-05-24T16:00:00.000Z</published>
    <updated>2017-05-25T11:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在逆向和保护的过程中，总会涉及到反调试和反反调试的问题，这篇文章主要是总结一下几种常见的反调试手段以及反反调试的方法。</p>
<h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><h4 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h4><p>为了方便应用软件的开发和调试，从Unix的早期版本开始就提供了一种对运行中的进程进行跟踪和控制的手段，那就是系统调用<code>ptrace()</code>。<br>通过<code>ptrace</code>可以对另一个进程实现调试跟踪，同时<code>ptrace</code>还提供了一个非常有用的参数那就是<code>PT_DENY_ATTACH</code>，这个参数用来告诉系统，阻止调试器依附。</p>
<p>所以最常用的反调试方案就是通过调用<code>ptrace</code>来实现反调试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#ifndef PT_DENY_ATTACH</div><div class="line">    #define PT_DENY_ATTACH 31</div><div class="line">#endif</div><div class="line"></div><div class="line">typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);</div><div class="line"></div><div class="line">ptrace(PT_DENY_ATTACH, 0, 0, 0);</div><div class="line"></div><div class="line">void *handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);</div><div class="line">ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, &quot;ptrace&quot;);</div><div class="line">ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);</div></pre></td></tr></table></figure>
<h4 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h4><p>当一个进程被调试的时候，该进程会有一个标记来标记自己正在被调试，所以可以通过<code>sysctl</code>去查看当前进程的信息，看有没有这个标记位即可检查当前调试状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">BOOL isDebuggerPresent()&#123;</div><div class="line">    int name[4];                //指定查询信息的数组</div><div class="line">    </div><div class="line">    struct kinfo_proc info;     //查询的返回结果</div><div class="line">    size_t info_size = sizeof(info);</div><div class="line">    </div><div class="line">    info.kp_proc.p_flag = 0;</div><div class="line">    </div><div class="line">    name[0] = CTL_KERN;</div><div class="line">    name[1] = KERN_PROC;</div><div class="line">    name[2] = KERN_PROC_PID;</div><div class="line">    name[3] = getpid();         </div><div class="line">    </div><div class="line">    if(sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0) == -1)&#123;</div><div class="line">        NSLog(@&quot;sysctl error ...&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检测到调试器就退出，或者制造崩溃，或者隐藏工程啥的，当然也可以定时去查看有没有这个标记。</p>
<h4 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h4><p>为从实现从用户态切换到内核态，系统提供了一个系统调用函数<code>syscall</code>，上面讲到的<code>ptrace</code>也是通过系统调用去实现的。</p>
<p>在<a href="https://www.theiphonewiki.com/wiki/Kernel_Syscalls" target="_blank" rel="external">Kernel Syscalls</a>这里可以找到<code>ptrace</code>对应的编号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">26. ptrace               801e812c T</div></pre></td></tr></table></figure>
<p>所以如下的调用等同于调用<code>ptrace</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">syscall(26,31,0,0,0);</div></pre></td></tr></table></figure>
<h4 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h4><p><code>syscall</code>是通过软中断来实现从用户态到内核态，也可以通过汇编<code>svc</code>调用来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#ifdef __arm__</div><div class="line">        asm volatile(</div><div class="line">            &quot;mov r0,#31\n&quot;</div><div class="line">            &quot;mov r1,#0\n&quot;</div><div class="line">            &quot;mov r2,#0\n&quot;</div><div class="line">            &quot;mov r12,#26\n&quot;</div><div class="line">            &quot;svc #80\n&quot;</div><div class="line">        </div><div class="line">        );</div><div class="line">#endif</div><div class="line">#ifdef __arm64__</div><div class="line">        asm volatile(</div><div class="line">            &quot;mov x0,#26\n&quot;</div><div class="line">            &quot;mov x1,#31\n&quot;</div><div class="line">            &quot;mov x2,#0\n&quot;</div><div class="line">            &quot;mov x3,#0\n&quot;</div><div class="line">            &quot;mov x16,#0\n&quot;</div><div class="line">            &quot;svc #128\n&quot;</div><div class="line">        );</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>下面几种可能在实际中用到的比较少，不过也可以尝试一下。</p>
<h4 id="SIGSTOP"><a href="#SIGSTOP" class="headerlink" title="SIGSTOP"></a>SIGSTOP</h4><p>通过捕获系统<code>SIGSTOP</code>信号来判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, dispatch_get_main_queue());</div><div class="line">dispatch_source_set_event_handler(source, ^&#123;</div><div class="line">    NSLog(@&quot;SIGSTOP!!!&quot;);</div><div class="line">    exit(0);</div><div class="line">&#125;);</div><div class="line">dispatch_resume(source);</div></pre></td></tr></table></figure>
<h4 id="task-get-exception-ports"><a href="#task-get-exception-ports" class="headerlink" title="task_get_exception_ports"></a>task_get_exception_ports</h4><p>获取异常端口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct macosx_exception_info&#123;</div><div class="line">    exception_mask_t masks[EXC_TYPES_COUNT];</div><div class="line">    mach_port_t ports[EXC_TYPES_COUNT];</div><div class="line">    exception_behavior_t behaviors[EXC_TYPES_COUNT];</div><div class="line">    thread_state_flavor_t flavors[EXC_TYPES_COUNT];</div><div class="line">    mach_msg_type_number_t cout;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct macosx_exception_info *info = malloc(sizeof(struct macosx_exception_info));</div><div class="line">task_get_exception_ports(mach_task_self(),</div><div class="line">                                            EXC_MASK_ALL,</div><div class="line">                                            info-&gt;masks,</div><div class="line">                                            &amp;info-&gt;cout,</div><div class="line">                                            info-&gt;ports,</div><div class="line">                                            info-&gt;behaviors,</div><div class="line">                                            info-&gt;flavors);</div><div class="line"></div><div class="line">for(uint32_t i = 0; i &lt; info-&gt;cout; i ++)&#123;</div><div class="line">    if(info-&gt;ports[i] != 0 || info-&gt;flavors[i] == THREAD_STATE_NONE)&#123;</div><div class="line">        NSLog(@&quot;debugger detected via exception ports (null port)!\n&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="isatty"><a href="#isatty" class="headerlink" title="isatty"></a>isatty</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (isatty(1)) &#123;</div><div class="line">    NSLog(@&quot;Being Debugged isatty&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (!ioctl(1, TIOCGWINSZ)) &#123;</div><div class="line">    NSLog(@&quot;Being Debugged ioctl&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="反反调试-Tweak"><a href="#反反调试-Tweak" class="headerlink" title="反反调试(Tweak)"></a>反反调试(Tweak)</h3><p>了解了几种不同的反调试的方法，那么就可以根据几种常用的反调试方法来反反调试。</p>
<p>这里主要针对<code>ptrace</code>、<code>sysctl</code>、<code>syscall</code>来反反调试，做法就很简单了，hook函数，判断参数，返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">#import &lt;substrate.h&gt;</div><div class="line">#import &lt;sys/sysctl.h&gt;</div><div class="line"></div><div class="line">static int (*orig_ptrace) (int request, pid_t pid, caddr_t addr, int data);</div><div class="line">static int my_ptrace (int request, pid_t pid, caddr_t addr, int data)&#123;</div><div class="line">    if(request == 31)&#123;</div><div class="line">		NSLog(@&quot;[AntiAntiDebug] - ptrace request is PT_DENY_ATTACH&quot;);</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	return orig_ptrace(request,pid,addr,data);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void* (*orig_dlsym)(void* handle, const char* symbol);</div><div class="line">static void* my_dlsym(void* handle, const char* symbol)&#123;</div><div class="line">	if(strcmp(symbol, &quot;ptrace&quot;) == 0)&#123;</div><div class="line">		NSLog(@&quot;[AntiAntiDebug] - dlsym get ptrace symbol&quot;);</div><div class="line">		return (void*)my_ptrace;</div><div class="line">    &#125;</div><div class="line">   	return orig_dlsym(handle, symbol);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int (*orig_sysctl)(int * name, u_int namelen, void * info, size_t * infosize, void * newinfo, size_t newinfosize);</div><div class="line">static int my_sysctl(int * name, u_int namelen, void * info, size_t * infosize, void * newinfo, size_t newinfosize)&#123;</div><div class="line">	int ret = orig_sysctl(name,namelen,info,infosize,newinfo,newinfosize);</div><div class="line">	if(namelen == 4 &amp;&amp; name[0] == 1 &amp;&amp; name[1] == 14 &amp;&amp; name[2] == 1)&#123;</div><div class="line">		struct kinfo_proc *info_ptr = (struct kinfo_proc *)info;</div><div class="line">        if(info_ptr &amp;&amp; (info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) != 0)&#123;</div><div class="line">            NSLog(@&quot;[AntiAntiDebug] - sysctl query trace status.&quot;);</div><div class="line">            info_ptr-&gt;kp_proc.p_flag ^= P_TRACED;</div><div class="line">            if((info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) == 0)&#123;</div><div class="line">                NSLog(@&quot;[AntiAntiDebug] trace status reomve success!&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">	return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void* (*orig_syscall)(int code, va_list args);</div><div class="line">static void* my_syscall(int code, va_list args)&#123;</div><div class="line">	int request;</div><div class="line">    va_list newArgs;</div><div class="line">    va_copy(newArgs, args);</div><div class="line">    if(code == 26)&#123;</div><div class="line">        request = (long)args;</div><div class="line">        if(request == 31)&#123;</div><div class="line">            NSLog(@&quot;[AntiAntiDebug] - syscall call ptrace, and request is PT_DENY_ATTACH&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return (void*)orig_syscall(code, newArgs);</div><div class="line">&#125;</div><div class="line"></div><div class="line">%ctor&#123;</div><div class="line">	MSHookFunction((void *)MSFindSymbol(NULL,&quot;_ptrace&quot;),(void*)my_ptrace,(void**)&amp;orig_ptrace);</div><div class="line">	MSHookFunction((void *)dlsym,(void*)my_dlsym,(void**)&amp;orig_dlsym);</div><div class="line">	MSHookFunction((void *)sysctl,(void*)my_sysctl,(void**)&amp;orig_sysctl);</div><div class="line">	MSHookFunction((void *)syscall,(void*)my_syscall,(void**)&amp;orig_syscall);</div><div class="line"></div><div class="line">	NSLog(@&quot;[AntiAntiDebug] Module loaded!!!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="反反调试-lldb"><a href="#反反调试-lldb" class="headerlink" title="反反调试(lldb)"></a>反反调试(lldb)</h3><p>通过<code>lldb</code>下断点，然后修改参数，或者直接返回也可以达到反反调试的效果。不过这里讲的是通过<code>python</code>脚本把过程自动化的一种方法。</p>
<p>为了方便直接使用<code>facebook</code>的<code>chisel</code>来增加脚本。</p>
<p>新建一个文件夹，然后使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">commandsDirectory = os.path.join(lldbHelperDir, &apos;文件名&apos;)</div><div class="line">loadCommandsInDirectory(commandsDirectory)</div></pre></td></tr></table></figure>
<p>加载即可。</p>
<p>下面是<code>python</code>代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: utf-8 -*-</div><div class="line"></div><div class="line">&quot;&quot;&quot;</div><div class="line">反反调试脚本，过了反调试后记得:</div><div class="line">aadebug -d</div><div class="line">否则会很卡，如果有定时器定时检测，建议写tweak</div><div class="line">&quot;&quot;&quot;</div><div class="line"></div><div class="line">import lldb</div><div class="line">import fblldbbase as fb</div><div class="line">import fblldbobjcruntimehelpers as objc</div><div class="line"></div><div class="line">def lldbcommands():</div><div class="line">    return [</div><div class="line">        AMAntiAntiDebug()</div><div class="line">    ]</div><div class="line"></div><div class="line">class AMAntiAntiDebug(fb.FBCommand):</div><div class="line">    def name(self):</div><div class="line">        return &apos;aadebug&apos;</div><div class="line"></div><div class="line">    def description(self):</div><div class="line">        return &quot;anti anti debug ptrace syscall sysctl&quot;</div><div class="line"></div><div class="line">    def options(self):</div><div class="line">        return [</div><div class="line">            fb.FBCommandArgument(short=&apos;-d&apos;, long=&apos;--disable&apos;, arg=&apos;disable&apos;, boolean=True, default=False, help=&apos;disable anti anti debug.&apos;)</div><div class="line">        ]</div><div class="line"></div><div class="line">    def run(self, arguments, options):</div><div class="line">        if options.disable:</div><div class="line">            target = lldb.debugger.GetSelectedTarget()</div><div class="line">            target.BreakpointDelete(self.ptrace.id)</div><div class="line">            target.BreakpointDelete(self.syscall.id)</div><div class="line">            target.BreakpointDelete(self.sysctl.id)</div><div class="line">            print &quot;anti anti debug is disabled!!!&quot;</div><div class="line">        else:</div><div class="line">            self.antiPtrace()</div><div class="line">            self.antiSyscall()</div><div class="line">            self.antiSysctl()</div><div class="line">            print &quot;anti anti debug finished!!!&quot;</div><div class="line"></div><div class="line">    def antiPtrace(self):</div><div class="line">        ptrace = lldb.debugger.GetSelectedTarget().BreakpointCreateByName(&quot;ptrace&quot;)</div><div class="line">        if is64Bit():</div><div class="line">            ptrace.SetCondition(&apos;$x0==31&apos;)</div><div class="line">        else:</div><div class="line">            ptrace.SetCondition(&apos;$r0==31&apos;)</div><div class="line">        ptrace.SetScriptCallbackFunction(&apos;sys.modules[\&apos;&apos; + __name__ + &apos;\&apos;].ptrace_callback&apos;)</div><div class="line">        self.ptrace = ptrace</div><div class="line"></div><div class="line">    def antiSyscall(self):</div><div class="line">        syscall = lldb.debugger.GetSelectedTarget().BreakpointCreateByName(&quot;syscall&quot;)</div><div class="line">        if is64Bit():</div><div class="line">            syscall.SetCondition(&apos;$x0==26 &amp;&amp; *(int *)$sp==31&apos;)</div><div class="line">        else:</div><div class="line">            syscall.SetCondition(&apos;$r0==26 &amp;&amp; $r1==31&apos;)</div><div class="line">        syscall.SetScriptCallbackFunction(&apos;sys.modules[\&apos;&apos; + __name__ + &apos;\&apos;].syscall_callback&apos;)</div><div class="line">        self.syscall = syscall</div><div class="line"></div><div class="line">    def antiSysctl(self):</div><div class="line">        sysctl = lldb.debugger.GetSelectedTarget().BreakpointCreateByName(&quot;sysctl&quot;)</div><div class="line">        if is64Bit():</div><div class="line">            sysctl.SetCondition(&apos;$x1==4 &amp;&amp; *(int *)$x0==1 &amp;&amp; *(int *)($x0+4)==14 &amp;&amp; *(int *)($x0+8)==1&apos;)</div><div class="line">        else:</div><div class="line">            sysctl.SetCondition(&apos;$r1==4 &amp;&amp; *(int *)$r0==1 &amp;&amp; *(int *)($r0+4)==14 &amp;&amp; *(int *)($r0+8)==1&apos;)</div><div class="line">        sysctl.SetScriptCallbackFunction(&apos;sys.modules[\&apos;&apos; + __name__ + &apos;\&apos;].sysctl_callback&apos;)</div><div class="line">        self.sysctl = sysctl</div><div class="line"></div><div class="line">    def antiExit(self):</div><div class="line">        self.exit = lldb.debugger.GetSelectedTarget().BreakpointCreateByName(&quot;exit&quot;)</div><div class="line">        exit.SetScriptCallbackFunction(&apos;sys.modules[\&apos;&apos; + __name__ + &apos;\&apos;].exit_callback&apos;)</div><div class="line"></div><div class="line">#暂时只考虑armv7和arm64</div><div class="line">def is64Bit():</div><div class="line">    arch = objc.currentArch()</div><div class="line">    if arch == &quot;arm64&quot;:</div><div class="line">        return True</div><div class="line">    return False</div><div class="line"></div><div class="line">def ptrace_callback(frame, bp_loc, internal_dict):</div><div class="line">    print &quot;find ptrace&quot;</div><div class="line">    register = &quot;x0&quot;</div><div class="line">    if not is64Bit():</div><div class="line">        register = &quot;r0&quot;</div><div class="line">    frame.FindRegister(register).value = &quot;0&quot;</div><div class="line">    lldb.debugger.HandleCommand(&apos;continue&apos;)</div><div class="line"></div><div class="line">def syscall_callback(frame, bp_loc, internal_dict):</div><div class="line">    print &quot;find syscall&quot;</div><div class="line">    #不知道怎么用api修改sp指向的内容QAQ</div><div class="line">    lldb.debugger.GetSelectedTarget().GetProcess().SetSelectedThread(frame.GetThread())</div><div class="line">    if is64Bit():</div><div class="line">        lldb.debugger.HandleCommand(&apos;memory write &quot;$sp&quot; 0&apos;)</div><div class="line">    else:</div><div class="line">        lldb.debugger.HandleCommand(&apos;register write $r1 0&apos;)</div><div class="line">    lldb.debugger.HandleCommand(&apos;continue&apos;)</div><div class="line"></div><div class="line">def sysctl_callback(frame, bp_loc, internal_dict):</div><div class="line">    module = frame.GetThread().GetFrameAtIndex(1).GetModule()</div><div class="line">    currentModule = lldb.debugger.GetSelectedTarget().GetModuleAtIndex(0)</div><div class="line">    if module == currentModule:</div><div class="line">        print &quot;find sysctl&quot;</div><div class="line">        register = &quot;x2&quot;</div><div class="line">        if not is64Bit():</div><div class="line">            register = &quot;r2&quot;</div><div class="line">        frame.FindRegister(register).value = &quot;0&quot;</div><div class="line">    lldb.debugger.HandleCommand(&apos;continue&apos;)</div><div class="line"></div><div class="line">def exit_callback(frame, bp_loc, internal_dict):</div><div class="line">    print &quot;find exit&quot;</div><div class="line">    lldb.debugger.GetSelectedTarget().GetProcess().SetSelectedThread(frame.GetThread())</div><div class="line">    lldb.debugger.HandleCommand(&apos;thread return&apos;)</div><div class="line">    lldb.debugger.HandleCommand(&apos;continue&apos;)</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>反调试的方式有多种，可以通过:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ebugserver *:1234 -x auto /path/to/executable</div></pre></td></tr></table></figure>
<p>启动附加，然后断点测试。</p>
<p>本文代码地址:</p>
<p><a href="https://github.com/AloneMonkey/AntiAntiDebug" target="_blank" rel="external">AntiAntiDebug</a></p>
<p>有问题或者有更好的方法欢迎一起探讨。</p>
]]></content>
    
    <summary type="html">
    
      最近发现好多人在弄反反调试的东西，顺便把以前的东西整理一下。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>在Centos部署nodejs</title>
    <link href="http://www.alonemonkey.com/2017/05/01/nodejs-on-centos/"/>
    <id>http://www.alonemonkey.com/2017/05/01/nodejs-on-centos/</id>
    <published>2017-04-30T16:00:00.000Z</published>
    <updated>2017-05-01T14:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天突然发现自己买了一年快过期了的搬瓦工，除了少数时间拿来当梯子用用其它也没用上，所以流量还剩这么多。。。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1493644280591.png" alt="image"></p>
<p>所以就想试试把本地写的nodejs的demo部署上去看看。</p>
<p>顺便把原来买的域名解析上去QAQ</p>
<h3 id="安装node和npm"><a href="#安装node和npm" class="headerlink" title="安装node和npm"></a>安装node和npm</h3><p>在官网下载编译好的node包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget https://nodejs.org/dist/v6.10.2/node-v6.10.2-linux-x86.tar.xz</div><div class="line"></div><div class="line">xz -d node-v6.10.2-linux-x86.tar.xz</div><div class="line"></div><div class="line">tar -xf node-v6.10.2-linux-x86.tar</div></pre></td></tr></table></figure>
<p>解压后得到<code>node-v6.10.2-linux-x86</code>文件夹，里面有个<code>bin</code>目录，包含了我们需要的<code>node</code>和<code>npm</code>。</p>
<p>这里需要注意的是，<code>npm</code>是链接到<code>../lib/node_modules/npm/bin/npm-cli.js</code>的，不能直接拷贝到<code>/usr/bin/</code>,否则会出错，可以使用<code>ll</code>看到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-rwxrwxr-x 1 500 500 28746408 Apr  4 05:04 node</div><div class="line">lrwxrwxrwx 1 500 500       38 May  1 08:03 npm -&gt; ../lib/node_modules/npm/bin/npm-cli.js</div></pre></td></tr></table></figure>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>编辑<code>/etc/profile</code>文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/profile</div></pre></td></tr></table></figure>
<p>增加路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PATH=$PATH:/home/node-v6.10.2-linux-x86/bin</div><div class="line">export PATH</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile</div></pre></td></tr></table></figure>
<h3 id="新建nodejs项目"><a href="#新建nodejs项目" class="headerlink" title="新建nodejs项目"></a>新建nodejs项目</h3><p>我自己的代码就不献丑了，这里就拿网上的一个demo来看看效果好了。<a href="https://my.oschina.net/u/1416844/blog/660951" target="_blank" rel="external">demo</a></p>
<p>安装git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install git</div></pre></td></tr></table></figure>
<p>ok, 在服务器拉下demo的代码，<code>npm install</code>，然后使用<code>pm2</code>来运行程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install pm2 -g</div><div class="line">pm2 start start.js -n demo</div></pre></td></tr></table></figure>
<p>输入<code>IP:8080</code>就能看到<code>Hello World!</code>了！</p>
<p>停止项目:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pm2 stop demo -f</div></pre></td></tr></table></figure>
<h3 id="域名绑定到ip"><a href="#域名绑定到ip" class="headerlink" title="域名绑定到ip"></a>域名绑定到ip</h3><p>想起来原来有一个空闲的域名，正好试下域名绑定。</p>
<p>在域名的<code>A</code>记录填写服务器的ip地址，等其生效即可。</p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>然后通过域名直接访问，发现并不能访问到我们的程序，因为默认访问的端口是<code>80</code>，而我们监听的端口是<code>8080</code>。这里可以通过：</p>
<ul>
<li>Nginx 反向代理</li>
<li>iptables 端口转发</li>
</ul>
<p>为了简单，直接用<code>iptables</code>端口转发了。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</div><div class="line">service iptables save  //保存规则</div></pre></td></tr></table></figure>
<p>这下可以愉快的通过域名访问刚刚部署的nodejs服务了。。。</p>
]]></content>
    
    <summary type="html">
    
      突然发现自己买了一年快到期的搬瓦工一直没用，就想试试部署一个简单的nodejs服务玩玩
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - RxGesture</title>
    <link href="http://www.alonemonkey.com/2017/04/10/rxswift-part-fifteen/"/>
    <id>http://www.alonemonkey.com/2017/04/10/rxswift-part-fifteen/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-04-10T09:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>RxGesture是RxSwift社区的产物，是对view手势的封装。</p>
<p>项目地址:<a href="https://github.com/RxSwiftCommunity/RxGesture" target="_blank" rel="external">RxGesture</a></p>
<p>话不多说，直接来看它的用法吧。</p>
<h3 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">tapView.rx</div><div class="line">    .tapGesture()</div><div class="line">    .when(.recognized)</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            _ in</div><div class="line">            print(&quot;tapped!!!&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="双击"><a href="#双击" class="headerlink" title="双击"></a>双击</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">tapView.rx</div><div class="line">    .tapGesture(numberOfTapsRequired: 2)</div><div class="line">    .when(.recognized)</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            _ in</div><div class="line">            print(&quot;double tapped!!!&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="下划"><a href="#下划" class="headerlink" title="下划"></a>下划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">tapView.rx</div><div class="line">    .swipeGesture(.down)</div><div class="line">    .when(.recognized)</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            _ in</div><div class="line">            print(&quot;swipe down!!!&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="水平划动"><a href="#水平划动" class="headerlink" title="水平划动"></a>水平划动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">tapView.rx</div><div class="line">    .swipeGesture([.left, .right])</div><div class="line">    .when(.recognized)</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            _ in</div><div class="line">            print(&quot;swipe left or right!!!&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="长按"><a href="#长按" class="headerlink" title="长按"></a>长按</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">tapView.rx</div><div class="line">    .longPressGesture()</div><div class="line">    .when(.began)</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            _ in</div><div class="line">            print(&quot;long press&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="拖动"><a href="#拖动" class="headerlink" title="拖动"></a>拖动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let panGesture = tapView.rx.panGesture().shareReplay(1)</div><div class="line">        </div><div class="line">panGesture</div><div class="line">    .when(.changed)</div><div class="line">    .asTranslation()</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123;</div><div class="line">            [unowned self] translation, _ in</div><div class="line">            self.label.text = String(format: &quot;(%.2f, %.2f)&quot;,translation.x, translation.y)</div><div class="line">            self.tapView.transform = CGAffineTransform(translationX: translation.x, y: translation.y)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">panGesture</div><div class="line">    .when(.ended)</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123; _ in</div><div class="line">            print(&quot;panGesture end&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let rotationGesture = tapView.rx.rotationGesture().shareReplay(1)</div><div class="line">        </div><div class="line">rotationGesture</div><div class="line">    .when(.changed)</div><div class="line">    .asRotation()</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123;</div><div class="line">            [unowned self] rotation, _ in</div><div class="line">            self.label.text = String(format: &quot;%.2f rad&quot;, rotation)</div><div class="line">            self.tapView.transform = CGAffineTransform(rotationAngle: rotation)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">rotationGesture</div><div class="line">    .when(.ended)</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123; _ in</div><div class="line">            print(&quot;rotationGesture end&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let pinchGesture = view.rx.pinchGesture().shareReplay(1)</div><div class="line">        </div><div class="line">pinchGesture</div><div class="line">    .when(.changed)</div><div class="line">    .asScale()</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123;</div><div class="line">            [unowned self] scale, _ in</div><div class="line">            self.label.text = String(format: &quot;x%.2f&quot;, scale)</div><div class="line">            self.tapView.transform = CGAffineTransform(scaleX: scale, y: scale)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">pinchGesture</div><div class="line">    .when(.ended)</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123; _ in</div><div class="line">            print(&quot;pinchGesture end&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let transformGestures = view.rx.transformGestures().shareReplay(1)</div><div class="line">        </div><div class="line">transformGestures</div><div class="line">    .when(.changed)</div><div class="line">    .asTransform()</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123;</div><div class="line">            [unowned self] transform, _ in</div><div class="line">            self.label.numberOfLines = 3</div><div class="line">            self.label.text = String(format: &quot;[%.2f, %.2f,\n%.2f, %.2f,\n%.2f, %.2f]&quot;, transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty)</div><div class="line">            self.tapView.transform = transform</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">transformGestures</div><div class="line">    .when(.ended)</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123;</div><div class="line">            [unowned self] _ in</div><div class="line">            self.label.numberOfLines = 1</div><div class="line">            print(&quot;transformGestures end&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="屏幕边缘"><a href="#屏幕边缘" class="headerlink" title="屏幕边缘"></a>屏幕边缘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">view.rx</div><div class="line">    .screenEdgePanGesture(edges: .right)</div><div class="line">    .when(.recognized)</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123;</div><div class="line">            _ in</div><div class="line">            print(&quot;right edge&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">tapView.rx</div><div class="line">    .anyGesture(.tap(), .swipe([.up, .down]))</div><div class="line">    .when(.recognized)</div><div class="line">    .subscribe(</div><div class="line">        onNext: &#123;</div><div class="line">            _ in</div><div class="line">            print(&quot;tap or up down&quot;)</div><div class="line">        &#125;</div><div class="line">    ).disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>默认对手势是没有过滤的，所以你会收到初始化的第一个手势事件。</p>
<p>下面是几种手势对应的状态:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1491817777814.png" alt="image"></p>
<p>还可以组合不同条件的手势:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">tapView.rx</div><div class="line">    .anyGesture(</div><div class="line">        (.tap(), when: .recognized),</div><div class="line">        (.pan(), when: .ended)</div><div class="line">    )</div><div class="line">    .subscribe(onNext: &#123; gesture in</div><div class="line">        // Called whenever:</div><div class="line">        // - a tap is recognized (state == .recognized)</div><div class="line">        // - or a pan is ended (state == .ended)</div><div class="line">        print(&quot;tap is recognized or pan is ended&quot;)</div><div class="line">    &#125;)</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码见github:</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftRxGesture</a></p>
]]></content>
    
    <summary type="html">
    
      RxGesture是RxSwift社区的产物，是对view手势的封装。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - Action</title>
    <link href="http://www.alonemonkey.com/2017/04/08/rxswift-part-fourteen/"/>
    <id>http://www.alonemonkey.com/2017/04/08/rxswift-part-fourteen/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2017-04-08T09:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Action是observable的一个抽象库，它定义了一个动作，传入输入的事件，然后对事件进行处理，返回处理结果。它有如下特点:</p>
<ul>
<li>只有<code>enabled</code>的时候才会执行，可以传入<code>enabledIf</code>参数</li>
<li>同时只能执行一个，下次<code>input</code>必须等上次的<code>action</code>执行完</li>
<li>可以分别处理错误和next</li>
</ul>
<h3 id="创建Action"><a href="#创建Action" class="headerlink" title="创建Action"></a>创建Action</h3><p><code>Action</code>被定义为一个类<code>Action&lt;Input, Element&gt;</code>,<code>Input</code>是输入的元素，<code>Element</code>是<code>Action</code>处理完之后返回的元素。</p>
<p>一个简单的例子，没有输入也没有输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let buttonAction: Action&lt;Void, Void&gt; = Action &#123;</div><div class="line">    print(&quot;Doing some work&quot;)</div><div class="line">    return Observable.empty()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者传入用户名密码，返回登录结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let loginAction: Action&lt;(String,String), Bool&gt; = Action&#123;</div><div class="line">    (username, password) in</div><div class="line">    print(&quot;\(username) \(password)&quot;)</div><div class="line">    return Observable.just(true)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="连接Button"><a href="#连接Button" class="headerlink" title="连接Button"></a>连接Button</h3><p><code>buttonAction</code>怎么使用，你可以把它和<code>button</code>的点击绑定起来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.rx.action = buttonAction</div></pre></td></tr></table></figure>
<p>每次点击按钮<code>Action</code>都会执行，如果上一次的点击<code>Action</code>没有完成的话，这个的点击将会无效。</p>
<p>设置为<code>nil</code>去取消绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.rx.action = nil</div></pre></td></tr></table></figure>
<h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>我们可以把输入的账号密码绑定到上面的<code>loginAction</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let usernameAndPassword = Observable.combineLatest(username.rx.text.orEmpty, password.rx.text.orEmpty)</div><div class="line">        </div><div class="line">login.rx.tap.asObservable()</div><div class="line">    .withLatestFrom(usernameAndPassword)</div><div class="line">    .bindTo(loginAction.inputs)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">loginAction.elements</div><div class="line">    .filter&#123; $0 &#125;</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            _ in</div><div class="line">            print(&quot;login ok!&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">loginAction.errors</div><div class="line">    .subscribe(</div><div class="line">        onError:&#123;</div><div class="line">            error in</div><div class="line">            print(&quot;error&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>输入的账号密码绑定到<code>loginAction.inputs</code>，然后订阅<code>loginAction</code>的结果。</p>
<h3 id="cell点击"><a href="#cell点击" class="headerlink" title="cell点击"></a>cell点击</h3><p>可以给每个<code>UITableViewCell</code>里面的button去绑定一个<code>Action</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let items = Observable.just(</div><div class="line">            (0...20).map&#123; &quot;\($0)&quot; &#125;</div><div class="line">        )</div><div class="line">        </div><div class="line">items.bindTo(tableview.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: UITableViewCell.self))&#123;</div><div class="line">    (row, elememt, cell) in</div><div class="line">    </div><div class="line">    let title = cell.viewWithTag(100) as! UILabel</div><div class="line">    </div><div class="line">    title.text = elememt</div><div class="line">    </div><div class="line">    var button = cell.viewWithTag(101) as! UIButton</div><div class="line">    </div><div class="line">    button.rx.action = CocoaAction &#123;</div><div class="line">        print(&quot;to do something \(elememt)&quot;)</div><div class="line">        return .empty()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;.disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>除了绑定输入以外，还可以主动去执行<code>Action</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">loginAction.execute((&quot;admin&quot;,&quot;password&quot;))</div><div class="line">    .subscribe&#123;</div><div class="line">        print($0)</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>通过<code>execute</code>传入账号密码，然后执行<code>Action</code>并订阅结果。</p>
<h3 id="enabledIf"><a href="#enabledIf" class="headerlink" title="enabledIf"></a>enabledIf</h3><p>只有当条件满足的时候<code>Action</code>才会执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let usernameCount = username.rx.text</div><div class="line">            .orEmpty</div><div class="line">            .asObservable()</div><div class="line">            .map&#123;</div><div class="line">                $0.characters.count &gt; 6</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">let validateUsername:Action&lt;String, Bool&gt; = Action(enabledIf: usernameCount, workFactory: &#123; input in</div><div class="line">    print(&quot;username validating.....&quot;)</div><div class="line">    return Observable.just(true)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">username.rx.controlEvent(.editingDidEnd)</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            [unowned self] _ in</div><div class="line">            validateUsername.execute(self.username.text ?? &quot;&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="UIAlertAction"><a href="#UIAlertAction" class="headerlink" title="UIAlertAction"></a>UIAlertAction</h3><p><code>UIAlert</code>的<code>Action</code>绑定:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">validateUsername.elements</div><div class="line">    .observeOn(MainScheduler.instance)</div><div class="line">    .subscribe&#123;</div><div class="line">        [unowned self] _ in</div><div class="line">        print(&quot;username validate ok&quot;)</div><div class="line">        let alertController = UIAlertController(title: &quot;validate&quot;, message: &quot;username validate is ok!&quot;, preferredStyle: .alert)</div><div class="line">        var ok = UIAlertAction.Action(&quot;OK&quot;, style: .default)</div><div class="line">        ok.rx.action = CocoaAction &#123;</div><div class="line">            print(&quot;Alert&apos;s OK button was pressed&quot;)</div><div class="line">            return .empty()</div><div class="line">        &#125;</div><div class="line">        alertController.addAction(ok)</div><div class="line">        self.present(alertController, animated: true, completion: nil)</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Action</code>可以用来定一个动作触发后的一个行为，也可以绑定多个动态到同一个<code>Action</code>，和<code>MVVM</code>结合的时候变得尤为合适。</p>
<p>代码见github:</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftAction</a></p>
]]></content>
    
    <summary type="html">
    
      Action是observable的一个抽象库，它定义了一个动作，传入输入的事件，然后对事件进行处理，返回处理结果。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 多线程调度</title>
    <link href="http://www.alonemonkey.com/2017/04/06/rxswift-part-thirteen/"/>
    <id>http://www.alonemonkey.com/2017/04/06/rxswift-part-thirteen/</id>
    <published>2017-04-05T16:00:00.000Z</published>
    <updated>2017-04-06T15:02:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在前面我们基本都是在讲如何将事件转成序列，然后去驱动数据，很少考虑到当前在什么线程。</p>
<p>如果某些操作是耗时的、耗内存的是不应该在主线程进行，这样会阻塞主线程，导致界面卡顿等等。</p>
<p>所以我们要在不同的线程去执行不同的操作。</p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>当<code>Rx</code>进行一些操作时，如果不去主动切换线程，那么它将一直在同一个线程进行。</p>
<p>但是调度器并不等同于线程，准确的说它是一个处理发生的上下文，这个上下文可以是一个线程也是是一个调度队列，甚至<code>OperationQueueScheduler</code>里面使用的<code>NSOperation</code>。<br>你可以在同一线程创建多个调度器，或者在不同线程使用同一个调度器，虽然有点奇怪，但是确定可以。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1491484089713.png" alt="image"></p>
<p>有两种类型的调度器，串行调度器和并行调度器。</p>
<p>下面有几种不同的内建的调度器:</p>
<ul>
<li>当前线程调度器(CurrentThreadScheduler)(串行调度器)</li>
</ul>
<p>当前线程的调度，也是默认的调度器</p>
<ul>
<li>主调度器(MainScheduler)(串行调度器)</li>
</ul>
<p>主线程的调度</p>
<ul>
<li>串行调度队列调度器(SerialDispatchQueueScheduler)(串行调度)</li>
</ul>
<p>特殊队列调度<code>dispatch_queue_t</code></p>
<ul>
<li>并行调度队列调度器(ConcurrentDispatchQueueScheduler)(并发调度)</li>
</ul>
<p>特殊队列调度<code>dispatch_queue_t</code></p>
<ul>
<li>操作队列调度器(OperationQueueScheduler)(并发调度)</li>
</ul>
<p>特殊队列调度<code>NSOperationQueue</code>，适合在后台处理大块的工作。</p>
<p>传一个并行队列给串行调度器，会把它转化成串行队列。传一个串行队列给并行调度器，也不会引起任何问题，但是还是要避免这么做。</p>
<h3 id="subscribeOn-amp-observeOn"><a href="#subscribeOn-amp-observeOn" class="headerlink" title="subscribeOn() &amp; observeOn()"></a>subscribeOn() &amp; observeOn()</h3><h4 id="SubscribeOn"><a href="#SubscribeOn" class="headerlink" title="SubscribeOn"></a>SubscribeOn</h4><p>指定Observable自身在哪个调度器上执行</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1491488110688.png" alt="image"></p>
<h4 id="ObserveOn"><a href="#ObserveOn" class="headerlink" title="ObserveOn"></a>ObserveOn</h4><p>指定一个观察者在哪个调度器上观察这个Observable</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1491488168714.png" alt="image"></p>
<ul>
<li><code>SubscribeOn</code>的调用切换之前的线程。</li>
<li><code>ObserveOn</code>的调用切换之后的线程。</li>
<li><code>ObserveOn</code>之后，不可再调用<code>SubscribeOn</code>切换之后的线程。</li>
</ul>
<p>再来看下两者的组合使用:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1491488363703.png" alt="image"></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>来看一个简单的例子，使用<code>RxAlamofire</code>从<code>github</code>搜索他人的项目，然后使用<code>ObjectMapper</code>解析json，最后展示到界面。由于涉及到网络以及解析，还有UI操作所以需求切换线程。</p>
<p>老套路，创建项目，导入<code>pod</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use_frameworks!</div><div class="line"></div><div class="line">target &apos;RxSwiftMultithreading&apos; do</div><div class="line"></div><div class="line">pod &apos;RxAlamofire/RxCocoa&apos;</div><div class="line">pod &apos;ObjectMapper&apos;</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p>界面还是一个<code>UITableView</code>和<code>UISearchBar</code>。</p>
<p>然后获取搜索的输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var rx_searchBarText: Observable&lt;String&gt; &#123;</div><div class="line">    return searchbar</div><div class="line">        .rx.text</div><div class="line">        .orEmpty</div><div class="line">        .filter &#123; $0.characters.count &gt; 0 &#125; // notice the filter new line</div><div class="line">        .throttle(0.5, scheduler: MainScheduler.instance)</div><div class="line">        .distinctUntilChanged()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="网络和解析"><a href="#网络和解析" class="headerlink" title="网络和解析"></a>网络和解析</h3><p>创建<code>Model</code>类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Repository: Mappable &#123;</div><div class="line">    var identifier: Int!</div><div class="line">    var language: String!</div><div class="line">    var url: String!</div><div class="line">    var name: String!</div><div class="line">    </div><div class="line">    required init?(map: Map) &#123; &#125;</div><div class="line">    </div><div class="line">    func mapping(map: Map) &#123;</div><div class="line">        identifier &lt;- map[&quot;id&quot;]</div><div class="line">        language &lt;- map[&quot;language&quot;]</div><div class="line">        url &lt;- map[&quot;url&quot;]</div><div class="line">        name &lt;- map[&quot;name&quot;]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后发起网络请求，正常的写法那就是这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private func fetchRepositories() -&gt; Driver&lt;[Repository]&gt; &#123;</div><div class="line">    return repositoryName</div><div class="line">        .flatMapLatest &#123; text in</div><div class="line">            return RxAlamofire</div><div class="line">                .requestJSON(.GET, &quot;https://api.github.com/users/\(text)/repos&quot;)</div><div class="line">                .debug()</div><div class="line">                .catchError &#123; error in</div><div class="line">                    return Observable.never()</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        .map &#123; (response, json) -&gt; [Repository] in</div><div class="line">            if let repos = Mapper&lt;Repository&gt;().mapArray(json) &#123;</div><div class="line">                return repos</div><div class="line">            &#125; else &#123;</div><div class="line">                return []</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        .asDriver(onErrorJustReturn: [])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把输入的文字转成网络请求序列，然后对请求的结果进行<code>map</code>转成<code>Repository</code>数组，最后返回。这里使用了<code>Driver</code>保证回到主线程，并不抛出错误。</p>
<p>然后在<code>ViewController</code>里面订阅结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">searchViewModel</div><div class="line">    .rx_repositories</div><div class="line">    .drive(tableview.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: UITableViewCell.self)) &#123; (row, repository, cell) in</div><div class="line">        cell.textLabel?.text = repository.name</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">searchViewModel</div><div class="line">    .rx_repositories</div><div class="line">    .drive(</div><div class="line">        onNext: &#123;</div><div class="line">            repositories in</div><div class="line">            if repositories.count == 0 &#123;</div><div class="line">                let alert = UIAlertController(title: &quot;sorry!&quot;, message: &quot;No repositories for this user.&quot;, preferredStyle: .alert)</div><div class="line">                alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil))</div><div class="line">                if self.navigationController?.visibleViewController?.isMember(of: UIAlertController.self) != true &#123;</div><div class="line">                    self.present(alert, animated: true, completion: nil)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><p>我们要确保网络请求和json解析在后台线程运行，所以使用<code>observeOn</code>主动切换线程，如果还要在之前或者之前才操作UI的话，也要切换线程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">fileprivate func fetchRepositories() -&gt; Driver&lt;[Repository]&gt; &#123;</div><div class="line">    return repositoryName</div><div class="line">        .subscribeOn(MainScheduler.instance) // Make sure we are on MainScheduler</div><div class="line">        .do(onNext: &#123; response in</div><div class="line">            UIApplication.shared.isNetworkActivityIndicatorVisible = true</div><div class="line">        &#125;)</div><div class="line">        .observeOn(ConcurrentDispatchQueueScheduler(qos: .background))</div><div class="line">        .flatMapLatest &#123; text in // .background thread, network request</div><div class="line">            return RxAlamofire</div><div class="line">                .requestJSON(.get, &quot;https://api.github.com/users/\(text)/repos&quot;)</div><div class="line">                .debug()</div><div class="line">                .catchError &#123; error in</div><div class="line">                    return Observable.never()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        .observeOn(ConcurrentDispatchQueueScheduler(qos: .background))</div><div class="line">        .map &#123; (response, json) -&gt; [Repository] in // again back to .background, map objects</div><div class="line">            if let repos = Mapper&lt;Repository&gt;().mapArray(JSONObject: json) &#123;</div><div class="line">                return repos</div><div class="line">            &#125; else &#123;</div><div class="line">                return []</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        .observeOn(MainScheduler.instance) // switch to MainScheduler, UI updates</div><div class="line">        .do(onNext: &#123; response in</div><div class="line">            UIApplication.shared.isNetworkActivityIndicatorVisible = false</div><div class="line">        &#125;)</div><div class="line">        .asDriver(onErrorJustReturn: []) // This also makes sure that we are on MainScheduler</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在编写代码的时候要能意识到当前是在哪个线程进行的操作，并且把一些耗时操作放到后台，UI更新操作放到主线程。</p>
<p>代码见github:</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftMultithreading</a></p>
]]></content>
    
    <summary type="html">
    
      在进行某些耗时的操作时，常常需要切换到后台线程运行，更新UI的操作要确保在主线程进行，本文来看看Rx中的线程切换。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 城市搜索</title>
    <link href="http://www.alonemonkey.com/2017/04/05/rxswift-part-twelve/"/>
    <id>http://www.alonemonkey.com/2017/04/05/rxswift-part-twelve/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2017-04-06T12:40:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Demo介绍"><a href="#Demo介绍" class="headerlink" title="Demo介绍"></a>Demo介绍</h3><p>这是一个通过<code>SearchBar</code>来搜索<code>tableview</code>内容的一个简单的例子，界面如下:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1491380143544.png" alt="image"></p>
<h3 id="mock数据"><a href="#mock数据" class="headerlink" title="mock数据"></a>mock数据</h3><p>首先添加一个<code>mock</code>数据到<code>tableview</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//mock数据</div><div class="line">var shownCities = [String]() // Data source for UITableView</div><div class="line"></div><div class="line">let allCities = [&quot;ChangSha&quot;,</div><div class="line">                    &quot;HangZhou&quot;,</div><div class="line">                    &quot;ShangHai&quot;,</div><div class="line">                    &quot;BeiJing&quot;,</div><div class="line">                    &quot;ShenZhen&quot;,</div><div class="line">                    &quot;New York&quot;,</div><div class="line">                    &quot;London&quot;,</div><div class="line">                    &quot;Oslo&quot;,</div><div class="line">                    &quot;Warsaw&quot;,</div><div class="line">                    &quot;Berlin&quot;,</div><div class="line">                    &quot;Praga&quot;] // Our mocked API data source</div><div class="line"></div><div class="line">//数据源</div><div class="line">let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, String&gt;&gt;()</div><div class="line"></div><div class="line">dataSource.configureCell = &#123;</div><div class="line">    (_, tv, indexPath, element) in</div><div class="line">    let cell = tv.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)!</div><div class="line">    cell.textLabel?.text = &quot;\(element)&quot;</div><div class="line">    return cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h3><p>获取用户的搜索输入，并简单判断前缀来返回结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//获取输入</div><div class="line">let searchResult = searchbar.rx</div><div class="line">                        .text</div><div class="line">                        .orEmpty</div><div class="line">                        .flatMapLatest&#123;</div><div class="line">                            [unowned self] query -&gt; Observable&lt;[String]&gt; in</div><div class="line">                            print(&quot;\(query)&quot;)</div><div class="line">                            if query.isEmpty&#123;</div><div class="line">                                return Observable.just([])</div><div class="line">                            &#125;else&#123;</div><div class="line">                                let results = self.allCities.filter&#123; $0.hasPrefix(query)&#125;</div><div class="line">                                return Observable.just(results)</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        .shareReplay(1)</div></pre></td></tr></table></figure>
<h3 id="绑定结果"><a href="#绑定结果" class="headerlink" title="绑定结果"></a>绑定结果</h3><p>绑定结果到<code>dataSource</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">searchResult</div><div class="line">       .map&#123; [SectionModel(model:&quot;&quot;,items:$0)] &#125;</div><div class="line">       .bindTo(tableview.rx.items(dataSource: dataSource))</div><div class="line">       .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>现在已经能使用搜索了。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>运行后发现每次输入文字，都会发送请求，可以使用<code>debounce</code>指定一段时间后不再有输入再发送请求，同时使用<code>distinctUntilChanged</code>来过滤和上次一样的输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let searchResult = searchbar.rx</div><div class="line">            .text</div><div class="line">            .orEmpty</div><div class="line">            .debounce(0.5, scheduler: MainScheduler.instance)</div><div class="line">            .distinctUntilChanged()</div><div class="line">            .flatMapLatest&#123;</div><div class="line">                [unowned self] query -&gt; Observable&lt;[String]&gt; in</div><div class="line">                print(&quot;\(query)&quot;)</div><div class="line">                if query.isEmpty&#123;</div><div class="line">                    return Observable.just([])</div><div class="line">                &#125;else&#123;</div><div class="line">                    let results = self.allCities.filter&#123; $0.hasPrefix(query)&#125;</div><div class="line">                    return Observable.just(results)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            .shareReplay(1)</div></pre></td></tr></table></figure>
<p>还可以使用<code>filter</code>直接过滤空的搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let searchResult = searchbar.rx</div><div class="line">                        .text</div><div class="line">                        .orEmpty</div><div class="line">                        .debounce(0.5, scheduler: MainScheduler.instance)</div><div class="line">                        .distinctUntilChanged()</div><div class="line">                        .filter&#123; !$0.isEmpty &#125;</div><div class="line">                        .flatMapLatest&#123;</div><div class="line">                            [unowned self] query -&gt; Observable&lt;[String]&gt; in</div><div class="line">                            print(&quot;\(query)&quot;)</div><div class="line">                            return Observable.just(self.allCities.filter&#123; $0.hasPrefix(query)&#125;)</div><div class="line">                        &#125;</div><div class="line">                        .shareReplay(1)</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里主要用到节流来处理用户输入，大家可以结合网络实时从接口获取数据，但是要主要线程切换。</p>
<p>代码见github:</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftCitySearch</a></p>
]]></content>
    
    <summary type="html">
    
      有tableview的地方大都会有搜索功能，如何使用RxSwift写一个简单的搜索功能，请看本文内容。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - share vs replay vs shareReplay</title>
    <link href="http://www.alonemonkey.com/2017/04/02/rxswift-part-eleven/"/>
    <id>http://www.alonemonkey.com/2017/04/02/rxswift-part-eleven/</id>
    <published>2017-04-01T16:00:00.000Z</published>
    <updated>2017-04-05T06:31:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>开发中最容易犯的错误是忘了每个订阅者都会导致<code>observable</code>重新执行链式调用。</p>
<p>like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">func request() -&gt; Observable&lt;String&gt;&#123;</div><div class="line">        return Observable.create&#123;</div><div class="line">            observer in</div><div class="line">            print(&quot;发送网络请求&quot;)</div><div class="line">            observer.onNext(&quot;请求成功!&quot;)</div><div class="line">            return Disposables.create &#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">let results = query.rx.text</div><div class="line">            .orEmpty</div><div class="line">            .asObservable()</div><div class="line">            .filter&#123;</div><div class="line">                $0.characters.count &gt; 0</div><div class="line">            &#125;</div><div class="line">            .flatMapLatest&#123;</div><div class="line">                query in</div><div class="line">                self.request()</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        results.subscribe&#123;</div><div class="line">                print(&quot;订阅者 one: \($0)&quot;)</div><div class="line">            &#125;.disposed(by: disposeBag)</div><div class="line">        </div><div class="line">        results.subscribe&#123;</div><div class="line">                print(&quot;订阅者 two: \($0)&quot;)</div><div class="line">            &#125;.disposed(by: disposeBag)</div><div class="line">        </div><div class="line">        results.subscribe&#123;</div><div class="line">                print(&quot;订阅者 three: \($0)&quot;)</div><div class="line">            &#125;.disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>三个订阅者会发送三次请求。</p>
<h3 id="解决？"><a href="#解决？" class="headerlink" title="解决？"></a>解决？</h3><p>当有多个订阅者去订阅同一个<code>Observable</code>的时候，我们不希望<code>Observable</code>每次有新的订阅者都去执行。</p>
<p><code>RxSwift</code>提供了很多操作:</p>
<p><code>share()</code>、<code>replay()</code>、<code>replayAll()</code>、<code>shareReplay()</code>、<code>publish()</code>、<code>shareReplayLatesWhileConnected()</code>， 这么多个，应该选哪一个？</p>
<p>你现在能够说出他们之间的不同吗？</p>
<p>先看下总体的比较，有个大概的了解:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1491368007455.png" alt="image"></p>
<p>1 表示重播最多<code>bufferSize</code>个事件<br>2 表示当订阅者的引用计数大于0时，重播一个事件</p>
<p><strong>共享订阅者</strong></p>
<p>多个订阅者订共享一个订阅者对象</p>
<p><strong>可连接</strong></p>
<p>可连接序列只有调用<code>connect</code>后才会开始发射值，可以等多个订阅者订阅后再连接。</p>
<p><strong>引用计数</strong></p>
<p>返回的<code>observable</code>记录了订阅者的数量，当订阅者数量从0变成1，订阅源序列，当订阅者数量从1变成0，取消订阅并重置源序列。</p>
<p>每次订阅者数量从0变成1源序列将会重新被订阅。</p>
<p><strong>重播事件</strong></p>
<p>重播已经发射的事件给订阅者。</p>
<p><code>replay(bufferSize)</code>和<code>shareReplay(bufferSize)</code>最多重播<code>bufferSize</code>个，而<code>shareReplayLatestWhileConnected</code>最多一个，当订阅者的引用计数变成0，<code>buffer</code>会被清空，所以引用计数从0变成1，订阅者不会受到重播事件。</p>
<h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p>以下例子使用<code>interval</code>模拟用户输入文本，并进行搜索:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var results:Observable&lt;String&gt;!</div><div class="line">results = Observable&lt;Int&gt;</div><div class="line">            .interval(1, scheduler: MainScheduler.instance)</div><div class="line">            .map&#123;</div><div class="line">                &quot;\($0)&quot;</div><div class="line">            &#125;</div><div class="line">            .flatMapLatest&#123;</div><div class="line">                query in</div><div class="line">                self.request(query)</div></pre></td></tr></table></figure>
<p>然后去订阅结果:</p>
<p><code>publish</code>原来讲到过，只有<code>connect</code>之后才会发射值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">func publish()&#123;</div><div class="line">    let results = self.results.publish()</div><div class="line">    </div><div class="line">    results.subscribe&#123;</div><div class="line">            print(&quot;订阅者 one: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    results.subscribe&#123;</div><div class="line">            print(&quot;订阅者 two: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    _ = results.connect()</div><div class="line">    </div><div class="line">    delay(4)&#123;</div><div class="line">        print(&quot;three 订阅&quot;)</div><div class="line">        results.subscribe&#123;</div><div class="line">            print(&quot;订阅者 three: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: self.disposeBag)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">搜索 3  发送网络请求</div><div class="line">订阅者 one: next(3 请求成功!)</div><div class="line">订阅者 two: next(3 请求成功!)</div><div class="line">three 订阅                        //没有重播事件</div><div class="line">搜索 4  发送网络请求</div><div class="line">订阅者 one: next(4 请求成功!)</div><div class="line">订阅者 two: next(4 请求成功!)</div><div class="line">订阅者 three: next(4 请求成功!)</div></pre></td></tr></table></figure>
<h3 id="replayAll"><a href="#replayAll" class="headerlink" title="replayAll"></a>replayAll</h3><p>重播所有事件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">func replayAll()&#123;</div><div class="line">    </div><div class="line">    let results = self.results.replayAll()</div><div class="line">    </div><div class="line">    results.subscribe&#123;</div><div class="line">        print(&quot;订阅者 one: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    results.subscribe&#123;</div><div class="line">        print(&quot;订阅者 two: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    _ = results.connect()</div><div class="line">    </div><div class="line">    delay(4)&#123;</div><div class="line">        print(&quot;three 订阅&quot;)</div><div class="line">        results.subscribe&#123;</div><div class="line">            print(&quot;订阅者 three: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: self.disposeBag)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">搜索 3  发送网络请求</div><div class="line">订阅者 one: next(3 请求成功!)</div><div class="line">订阅者 two: next(3 请求成功!)</div><div class="line">three 订阅</div><div class="line">订阅者 three: next(0 请求成功!)     //订阅后，受到重播的所有事件</div><div class="line">订阅者 three: next(1 请求成功!)</div><div class="line">订阅者 three: next(2 请求成功!)</div><div class="line">订阅者 three: next(3 请求成功!)</div><div class="line">搜索 4  发送网络请求</div><div class="line">订阅者 one: next(4 请求成功!)</div><div class="line">订阅者 two: next(4 请求成功!)</div><div class="line">订阅者 three: next(4 请求成功!)</div></pre></td></tr></table></figure>
<h3 id="replay"><a href="#replay" class="headerlink" title="replay"></a>replay</h3><p><code>replay(bufferSize)</code>重播指定个数的事件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">func replay()&#123;</div><div class="line">    let results = self.results.replay(2)</div><div class="line">    </div><div class="line">    results.subscribe&#123;</div><div class="line">        print(&quot;订阅者 one: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    results.subscribe&#123;</div><div class="line">        print(&quot;订阅者 two: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    _ = results.connect()</div><div class="line">    </div><div class="line">    delay(4)&#123;</div><div class="line">        print(&quot;three 订阅&quot;)</div><div class="line">        results.subscribe&#123;</div><div class="line">            print(&quot;订阅者 three: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: self.disposeBag)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">搜索 3  发送网络请求</div><div class="line">订阅者 one: next(3 请求成功!)</div><div class="line">订阅者 two: next(3 请求成功!)</div><div class="line">three 订阅                        //重播最后2个事件</div><div class="line">订阅者 three: next(2 请求成功!)</div><div class="line">订阅者 three: next(3 请求成功!)</div><div class="line">搜索 4  发送网络请求</div><div class="line">订阅者 one: next(4 请求成功!)</div><div class="line">订阅者 two: next(4 请求成功!)</div><div class="line">订阅者 three: next(4 请求成功!)</div></pre></td></tr></table></figure>
<h3 id="share"><a href="#share" class="headerlink" title="share"></a>share</h3><p>订阅者从1变成0重置序列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">func share()&#123;</div><div class="line">    let results = self.results.share()</div><div class="line">    </div><div class="line">    let sub = results.subscribe&#123;</div><div class="line">        </div><div class="line">            print(&quot;订阅者 one: \($0)&quot;)</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    delay(4)&#123;</div><div class="line">        //订阅者从1变成0</div><div class="line">        //可被观察序列重新发射</div><div class="line">        print(&quot;订阅者 one被销毁&quot;)</div><div class="line">        </div><div class="line">        sub.dispose()</div><div class="line">        </div><div class="line">        results.subscribe&#123;</div><div class="line">            print(&quot;订阅者 two: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: self.disposeBag)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">搜索 3  发送网络请求</div><div class="line">订阅者 one: next(3 请求成功!)</div><div class="line">订阅者 one被销毁</div><div class="line">搜索 0  发送网络请求                //从0开始重新发射</div><div class="line">订阅者 two: next(0 请求成功!)</div></pre></td></tr></table></figure>
<h3 id="shareReplay-bufferSize"><a href="#shareReplay-bufferSize" class="headerlink" title="shareReplay(bufferSize)"></a>shareReplay(bufferSize)</h3><p>在<code>share</code>的基础重播<code>bufferSize</code>个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">func shareReplay()&#123;</div><div class="line">    let results = self.results.shareReplay(2)</div><div class="line">    </div><div class="line">    let sub1 = results.subscribe&#123;</div><div class="line">        print(&quot;订阅者 one: \($0)&quot;)</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    let sub2 = results.subscribe&#123;</div><div class="line">        print(&quot;订阅者 two: \($0)&quot;)</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    delay(4)&#123;</div><div class="line">        sub1.dispose()</div><div class="line">        sub2.dispose()</div><div class="line">        </div><div class="line">        print(&quot;three 订阅&quot;)</div><div class="line">        results.subscribe&#123;</div><div class="line">            print(&quot;订阅者 three: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: self.disposeBag)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">搜索 3  发送网络请求</div><div class="line">订阅者 one: next(3 请求成功!)</div><div class="line">订阅者 two: next(3 请求成功!)</div><div class="line">three 订阅</div><div class="line">订阅者 three: next(2 请求成功!)         //虽然订阅者都被销毁，但是仍收到最后两个值</div><div class="line">订阅者 three: next(3 请求成功!)</div><div class="line">搜索 0  发送网络请求</div><div class="line">订阅者 three: next(0 请求成功!)</div></pre></td></tr></table></figure>
<h3 id="shareReplayLatestWhileConnected"><a href="#shareReplayLatestWhileConnected" class="headerlink" title="shareReplayLatestWhileConnected"></a>shareReplayLatestWhileConnected</h3><p>订阅者从1变成0，缓存区被清空:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func shareReplayLatestWhileConnected()&#123;</div><div class="line">    let results = self.results.shareReplayLatestWhileConnected() // test  shareReplay(1)</div><div class="line">    </div><div class="line">    let sub = results.subscribe&#123;</div><div class="line">                print(&quot;订阅者 one: \($0)&quot;)</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">    delay(4)&#123;</div><div class="line">        sub.dispose()</div><div class="line">        //订阅者从1变成0， 缓存的一个值被清掉了，所以不会收到最后一个值</div><div class="line">        print(&quot;two 订阅&quot;)</div><div class="line">        results.subscribe&#123;</div><div class="line">            print(&quot;订阅者 two: \($0)&quot;)</div><div class="line">        &#125;.disposed(by: self.disposeBag)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">搜索 3  发送网络请求</div><div class="line">订阅者 one: next(3 请求成功!)</div><div class="line">two 订阅</div><div class="line">搜索 0  发送网络请求</div><div class="line">订阅者 two: next(0 请求成功!)</div><div class="line">搜索 1  发送网络请求</div><div class="line">订阅者 two: next(1 请求成功!)</div></pre></td></tr></table></figure>
<p>试试改成<code>shareReplay(1)</code>，或者不销毁<code>sub</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以结合上面的例子，在实际运用中选择合适的接口。</p>
<p>代码见github:</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftShareOrReplay</a></p>
]]></content>
    
    <summary type="html">
    
      share(), replay(), replayAll(), shareReplay(), publish(), and even shareReplayLatesWhileConnected()什么时候用哪个？？？
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 双向绑定</title>
    <link href="http://www.alonemonkey.com/2017/04/01/rxswift-part-ten/"/>
    <id>http://www.alonemonkey.com/2017/04/01/rxswift-part-ten/</id>
    <published>2017-03-31T16:00:00.000Z</published>
    <updated>2017-04-05T06:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>首先来看几个问题吧，我们知道监听<code>UITextField</code>可以通过如下的方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">textfield.rx.text</div><div class="line">        .asObservable()</div><div class="line">        .subscribe&#123;</div><div class="line">            print($0)</div><div class="line">        &#125;</div><div class="line">        .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>但是如果我们这样去改变它的值，是订阅不到的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textfield.text = &quot;这是我修改的值&quot;</div></pre></td></tr></table></figure>
<p>还有<code>UILabel</code>不是一个可被观察对象，所以下面这么写是会报错的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">label.rx.text</div><div class="line">            .asObservable()</div></pre></td></tr></table></figure>
<p>但是<code>UITextView</code>既可以被订阅，修改<code>text</code>也可以被订阅到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">textview.rx.text</div><div class="line">    .asObservable()</div><div class="line">    .subscribe&#123;</div><div class="line">        print(&quot;textview: \($0)&quot;)</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">textview.text = &quot;这是我修改的值&quot;</div></pre></td></tr></table></figure>
<p>为什么都是<code>UI</code>控件差别这么大(捂脸</p>
<h3 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h3><p>其实这个时候你要思考一下，为什么他们能被观察为什么又不可以？</p>
<p><code>UITextField</code>我们前面讲过，它的<code>.allEditingEvents</code>和<code>.valueChanged</code>事件会发射值，所以它可以作为被观察对象。</p>
<p>但是<code>textfield.text = &quot;这是我修改的值&quot;</code>并不会触发上面两种事件，所以你这样修改并没有被订阅到。</p>
<p><code>UILabel</code>是继承<code>UIView</code>不是继承<code>UIControl</code>所以它不会响应事件，也就不能作为可被观察对象。</p>
<p><code>UITextView</code>来看下它是怎么发射值的。</p>
<p>从源码可以看到它是通过<code>NSTextStorageDelegate.textStorage(_:didProcessEditing:range:changeInLength:)</code>这个<code>delegate</code>的回调来发射值的。所以可以作为一个被观察者。</p>
<p>当我们<code>textview.text = &quot;这是我修改的值&quot;</code>这样去修改<code>text</code>的时候，会触发上面<code>delegate</code>的回调，所以会被订阅到。</p>
<h3 id="解决？"><a href="#解决？" class="headerlink" title="解决？"></a>解决？</h3><p>问题已经找到了，怎么去解决这些问题？</p>
<p>比如我想要</p>
<p><code>textfield.text = &quot;这是我修改的值&quot;</code></p>
<p>这样去赋值也会发射事件。</p>
<p>这里我们可以用到双向绑定，把<code>UITextField</code>的修改和赋值绑定到一个<code>Subject</code>，同时还可以被订阅。</p>
<p>首先重载<code>&lt;-&gt;</code>操作符，后面我们通过这个操作符去进行双向绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">func &lt;-&gt; &lt;Base: UITextInput&gt;(textInput: TextInput&lt;Base&gt;, variable: Variable&lt;String&gt;) -&gt; Disposable &#123;</div><div class="line">    let bindToUIDisposable = variable.asObservable()</div><div class="line">        .bindTo(textInput.text)</div><div class="line">    let bindToVariable = textInput.text</div><div class="line">        .subscribe(onNext: &#123; [weak base = textInput.base] n in</div><div class="line">            guard let base = base else &#123;</div><div class="line">                return</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            let nonMarkedTextValue = nonMarkedText(base)</div><div class="line">            </div><div class="line">            /**</div><div class="line">             In some cases `textInput.textRangeFromPosition(start, toPosition: end)` will return nil even though the underlying</div><div class="line">             value is not nil. This appears to be an Apple bug. If it&apos;s not, and we are doing something wrong, please let us know.</div><div class="line">             The can be reproed easily if replace bottom code with</div><div class="line">             </div><div class="line">             if nonMarkedTextValue != variable.value &#123;</div><div class="line">             variable.value = nonMarkedTextValue ?? &quot;&quot;</div><div class="line">             &#125;</div><div class="line">             </div><div class="line">             and you hit &quot;Done&quot; button on keyboard.</div><div class="line">             */</div><div class="line">            if let nonMarkedTextValue = nonMarkedTextValue, nonMarkedTextValue != variable.value &#123;</div><div class="line">                variable.value = nonMarkedTextValue</div><div class="line">            &#125;</div><div class="line">            &#125;, onCompleted:  &#123;</div><div class="line">                bindToUIDisposable.dispose()</div><div class="line">        &#125;)</div><div class="line">    </div><div class="line">    return Disposables.create(bindToUIDisposable, bindToVariable)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>&lt;-&gt;</code>双向绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let text = Variable(&quot;双向绑定&quot;)</div><div class="line">        </div><div class="line">    _  = textfield.rx.textInput &lt;-&gt; text</div><div class="line">    </div><div class="line">    textfield.rx.text</div><div class="line">        .asObservable()</div><div class="line">        .subscribe&#123;</div><div class="line">            print(&quot;textfield: \($0)&quot;)</div><div class="line">        &#125;</div><div class="line">        .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>那么这样去修改<code>text</code>就能被订阅到了。</p>
<p>再来扩展一下<code>UILabel</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">extension UILabel &#123;</div><div class="line">    public var rx_text: ControlProperty&lt;String&gt; &#123;</div><div class="line">        // 观察text</div><div class="line">        let source: Observable&lt;String&gt; = self.rx.observe(String.self, &quot;text&quot;).map &#123; $0 ?? &quot;&quot; &#125;</div><div class="line">        let setter: (UILabel, String) -&gt; Void = &#123; $0.text = $1 &#125;</div><div class="line">        let bindingObserver = UIBindingObserver(UIElement: self, binding: setter)</div><div class="line">        return ControlProperty&lt;String&gt;(values: source, valueSink: bindingObserver)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察<code>text</code>的改变，改变的时候发射值，代码可以这么写了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">textfield.rx.text</div><div class="line">        .asObservable()</div><div class="line">        .subscribe&#123;</div><div class="line">            print(&quot;textfield: \($0)&quot;)</div><div class="line">        &#125;</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    textfield.text = &quot;这是我修改的值&quot;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以现在知道了为什么前面有几种不同的表现了吧。</p>
<p>其实很多<code>UIControl</code>的子类控件，都可以通过这种双向绑定的方式，以便我们修改它的值时能够被订阅者订阅到。</p>
<p>代码见github:</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftTwoWayBinding</a></p>
]]></content>
    
    <summary type="html">
    
      直接设置UITextField的text不会触发事件？UILabel为什么不是一个可被观察对象？
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 使用Result传递Error</title>
    <link href="http://www.alonemonkey.com/2017/03/31/rxswift-part-nine/"/>
    <id>http://www.alonemonkey.com/2017/03/31/rxswift-part-nine/</id>
    <published>2017-03-30T16:00:00.000Z</published>
    <updated>2017-04-05T06:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们知道一个可被观察序列在它们收到<code>error</code>或者<code>completed</code>事件的时候会终止，终止也就意味着它的订阅者不会收到任何新的消息了。当我们开始学习<code>Rx</code>的时候可能还不会意识到这条规则的后果。</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>很多的应用通常会在点击某个按钮的时候发网络请求，下面来看看这个例子。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490794130730.png" alt="image"></p>
<p>点击<code>Success</code>模拟调用一个api请求，返回成功，同样，点击<code>Failure</code>触发<code>error</code>，点击会增加计数。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>首先把成功的点击返回<code>true</code>，失败的点击返回<code>false</code>，然后合并成单个序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let successCount = Observable</div><div class="line">        .of(success.rx.tap.map &#123; true &#125;, failure.rx.tap.map &#123; false &#125;)</div><div class="line">        .merge()</div><div class="line">        .flatMap &#123;</div><div class="line">            [unowned self] performWithSuccess in</div><div class="line">            return self.performAPICall(shouldEndWithSuccess: performWithSuccess)</div><div class="line">        &#125;.scan(0) &#123; accumulator, _ in</div><div class="line">            return accumulator + 1</div><div class="line">        &#125;.map &#123; &quot;\($0)&quot; &#125;</div><div class="line">    </div><div class="line">    successCount.bindTo(self.successCount.rx.text)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    successCount.subscribe(</div><div class="line">        onDisposed:&#123;</div><div class="line">            print(&quot;dispose&quot;)</div><div class="line">        &#125;</div><div class="line">    ).disposed(by: disposeBag)</div><div class="line">  </div><div class="line">private func performAPICall(shouldEndWithSuccess: Bool) -&gt; Observable&lt;Void&gt; &#123;</div><div class="line">	if shouldEndWithSuccess &#123;</div><div class="line">		return .just(())</div><div class="line">	&#125; else &#123;</div><div class="line">		return .error(SampleError())</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>当点击<code>Success</code>的时候会增加成功次数，但是当你点击<code>Failure</code>的时候，整个可被观察序列会被释放，之后不管你怎么点<code>Success</code>都不会再增加成功次数。</p>
<p>当<code>performAPICall</code>返回了一个错误的事件的时候，其实和你在发送网络请求的时候也会出现。所以使用<code>flatMap</code>也会把内部的<code>next</code>和<code>error</code>事件传到主序列。</p>
<p>结果，主序列收到<code>error</code>事件，就终结了。。。</p>
<h3 id="如何处理？"><a href="#如何处理？" class="headerlink" title="如何处理？"></a>如何处理？</h3><p>上面的情况假如<code>Success</code>按钮是登录按钮，那么在错误后就不能点击了，这不是我们想要的。</p>
<p>这里我们可以借助<code>Result</code>来传递错误信息。</p>
<p>其实在上一篇<code>Moya</code>里面很多地方都有使用到<code>Result</code>来传递错误。</p>
<p>创建一个<code>Result</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">enum Result&lt;T&gt;&#123;</div><div class="line">    case success(T)</div><div class="line">    case failure(Swift.Error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改<code>performAPICall</code>返回<code>Result</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private func performAPICall2(shouldEndWithSuccess: Bool) -&gt; Observable&lt;Result&lt;Void&gt;&gt; &#123;</div><div class="line">    if shouldEndWithSuccess &#123;</div><div class="line">        return .just(Result.success())</div><div class="line">    &#125; else &#123;</div><div class="line">        return .just(Result.failure(SampleError()))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后分别处理成功和失败的情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">successCount</div><div class="line">    .flatMap&#123;</div><div class="line">        $0.filterValue()</div><div class="line">    &#125;</div><div class="line">    .scan(0) &#123; accumulator, _ in</div><div class="line">        return accumulator + 1</div><div class="line">    &#125;</div><div class="line">    .map &#123; &quot;\($0)&quot; &#125;</div><div class="line">    .bindTo(self.successCount.rx.text)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">successCount</div><div class="line">    .flatMap&#123;</div><div class="line">        $0.filterError()</div><div class="line">    &#125;</div><div class="line">    .scan(0) &#123; accumulator, _ in</div><div class="line">        return accumulator + 1</div><div class="line">    &#125;</div><div class="line">    .map &#123; &quot;\($0)&quot; &#125;</div><div class="line">    .bindTo(self.failureCount.rx.text)</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>这里增加了<code>filterValue</code>和<code>filterError</code>来获取我们想要的值。</p>
<p>如果不关心原来的错误，只处理成功，也可以增加如下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">func map&lt;T&gt;(transform: (Value) throws -&gt; T) -&gt; Result&lt;T&gt; &#123;</div><div class="line">    switch self &#123;</div><div class="line">    case .Success(let object):</div><div class="line">        do &#123;</div><div class="line">            let nextObject = try transform(object)</div><div class="line">            return Result&lt;T&gt;.Success(nextObject)</div><div class="line">        &#125; catch &#123;</div><div class="line">            return Result&lt;T&gt;.Failure(error)</div><div class="line">        &#125;</div><div class="line">    case .Failure(let error):</div><div class="line">        return Result&lt;T&gt;.Failure(error)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>错误接着往下传，执行逻辑，成功返回，发生错误传递错误。</p>
<h3 id="使用RxSwiftExt"><a href="#使用RxSwiftExt" class="headerlink" title="使用RxSwiftExt"></a>使用RxSwiftExt</h3><p>除了上面的方式，也可以使用<code>RxSwiftExt</code>提供的<code>materialize</code>操作。</p>
<p>它会把<code>Observable&lt;T&gt;</code>into<code>Observable&lt;Event&lt;T&gt;&gt;</code> , 通过下面两个方法分别获取值和错误:</p>
<ul>
<li>elements() which returns Observable<t></t></li>
<li>errors() which returns Observable<error></error></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">let result = Observable</div><div class="line">            .of(success.rx.tap.map &#123; true &#125;, failure.rx.tap.map &#123; false &#125;)</div><div class="line">            .merge()</div><div class="line">            .flatMap &#123; [unowned self] performWithSuccess in</div><div class="line">                return self.performAPICall(shouldEndWithSuccess: performWithSuccess)</div><div class="line">                    .materialize()</div><div class="line">    &#125;.share()  //share </div><div class="line">    </div><div class="line">    result.elements()</div><div class="line">        .scan(0) &#123; accumulator, _ in</div><div class="line">            return accumulator + 1</div><div class="line">        &#125;.map &#123; &quot;\($0)&quot; &#125;</div><div class="line">        .bindTo(successCount.rx.text)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    result.errors()</div><div class="line">        .scan(0) &#123; accumulator, _ in</div><div class="line">            return accumulator + 1</div><div class="line">        &#125;.map &#123; &quot;\($0)&quot; &#125;</div><div class="line">        .bindTo(failureCount.rx.text)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    result.subscribe(</div><div class="line">        onDisposed:&#123;</div><div class="line">            print(&quot;dispose&quot;)</div><div class="line">        &#125;</div><div class="line">    ).disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>和上次一样的把元素和错误一起包裹了一下，往下传递。</p>
<p>本文相关代码:</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftResult</a></p>
]]></content>
    
    <summary type="html">
    
      RxSwift中发生的错误应该怎么处理？
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - Moya + ObjectMapper</title>
    <link href="http://www.alonemonkey.com/2017/03/30/rxswift-part-eight/"/>
    <id>http://www.alonemonkey.com/2017/03/30/rxswift-part-eight/</id>
    <published>2017-03-29T16:00:00.000Z</published>
    <updated>2017-03-29T12:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Moya？"><a href="#什么是Moya？" class="headerlink" title="什么是Moya？"></a>什么是Moya？</h3><p><code>Moya</code>是一个基于<code>Alamofire</code>封装的一个抽象层，让我们更加关注自己的业务处理。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490776469921.png" alt="image"></p>
<p>同时还可以通过中间件的方式拦截和修改请求，mock数据等等。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490776597007.png" alt="image"></p>
<h3 id="使用Moya"><a href="#使用Moya" class="headerlink" title="使用Moya"></a>使用Moya</h3><p>来看一个简单的例子吧，在<code>Moya</code>中要发送一个网络请求，需要定义个枚举并实现<code>TargetType</code>协议中的方法。如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">//根据不同的枚举类型来配置不同的参数</div><div class="line">enum User&#123;</div><div class="line">    case list(Int,Int)</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension User : TargetType&#123;</div><div class="line">    var baseURL : URL&#123;</div><div class="line">        return URL(string: &quot;http://www.alonemonkey.com&quot;)!</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var path: String&#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .list:</div><div class="line">            return &quot;userlist&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var method: Moya.Method&#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .list:</div><div class="line">            return .get</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var parameters: [String: Any]?&#123;</div><div class="line">        switch self&#123;</div><div class="line">        case .list(let start, let size):</div><div class="line">            return [&quot;start&quot;: start, &quot;size&quot;: size]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var parameterEncoding: ParameterEncoding&#123;</div><div class="line">        return URLEncoding.default</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var task: Task&#123;</div><div class="line">        return .request</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    var sampleData: Data&#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .list(_, _):</div><div class="line">            if let path = Bundle.main.path(forResource: &quot;UserList&quot;, ofType: &quot;json&quot;) &#123;</div><div class="line">                do &#123;</div><div class="line">                    let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .alwaysMapped)</div><div class="line">                    return data</div><div class="line">                &#125; catch let error &#123;</div><div class="line">                    print(error.localizedDescription)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return Data()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面参数的函数大家看名字也就知道了。</p>
<p>然后需要一个<code>MoyaProvider</code>对象，这里使用<code>RxMoyaProvider</code>来进行响应式编程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let UserProvider = RxMoyaProvider&lt;User&gt;(stubClosure: MoyaProvider.immediatelyStub)</div></pre></td></tr></table></figure>
<p><code>stubClosure: MoyaProvider.immediatelyStub</code>表示使用本地mock数据。</p>
<p>然后使用生成的<code>RxMoyaProvider</code>对象发起请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">UserProvider</div><div class="line">    .request(.list(0, 10))</div><div class="line">    .mapJSON()</div><div class="line">    .subscribe&#123;</div><div class="line">        print($0)</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>运行就可以在控制台打印出本地<code>mock</code>的<code>json</code>数据了。</p>
<h3 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h3><p>获取了<code>json</code>数据后，需要把数据解析成对应的对象，这里我们使用<code>ObjectMapper</code>。已有<code>Moya-ObjectMapper</code>, 可以满足我们的需求。</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;Moya-ObjectMapper/RxSwift&apos;</div></pre></td></tr></table></figure>
<p>首先定义<code>Model</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct User : Mappable&#123;</div><div class="line">    var name: String!</div><div class="line">    var age: Int!</div><div class="line">    </div><div class="line">    init?(map: Map) &#123;&#125;</div><div class="line">    </div><div class="line">    mutating func mapping(map: Map)&#123;</div><div class="line">        name &lt;- map[&quot;name&quot;]</div><div class="line">        age  &lt;- map[&quot;age&quot;]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在请求的时候可以指定<code>Model</code>去解析数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">UserProvider</div><div class="line">    .request(.list(0, 10))</div><div class="line">    .mapArray(User.self)</div><div class="line">    .subscribe&#123;</div><div class="line">        event in</div><div class="line">        switch event&#123;</div><div class="line">        case .next(let users):</div><div class="line">            for user in users&#123;</div><div class="line">                print(&quot;\(user.name)  \(user.age)&quot;)</div><div class="line">            &#125;</div><div class="line">        default:</div><div class="line">            break</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="固定格式"><a href="#固定格式" class="headerlink" title="固定格式"></a>固定格式</h3><p>上面都是直接就返回了一个<code>User</code>的数组，但是实际开发中，都会返回一个固定的格式，表示状态、消息、结果，像下面这种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    code: 300,</div><div class="line">    message: &quot;xxxxxx&quot;,</div><div class="line">    result: xxxx     //这里才是我们需要的东西</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这情况怎么处理呢？</p>
<p>首先看一下<code>mapArray</code>是怎么处理的把:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public func mapArray&lt;T: BaseMappable&gt;(_ type: T.Type, context: MapContext? = nil) throws -&gt; [T] &#123;</div><div class="line">	guard let array = try mapJSON() as? [[String : Any]], let objects = Mapper&lt;T&gt;(context: context).mapArray(JSONArray: array) else &#123;</div><div class="line">      throw MoyaError.jsonMapping(self)</div><div class="line">    &#125;</div><div class="line">    return objects</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>首先调用了<code>mapJSON</code>转成<code>json</code>，然后调用<code>Mapper&lt;T&gt;(context: context).mapArray(JSONArray: array)</code>转成对象数组。</p>
<p>我们也可以写一个类似的方法，首先定义需要解析的公共部分结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct Status : Mappable&#123;</div><div class="line">    var code : Int!</div><div class="line">    var message : String?</div><div class="line">    var result : Any?</div><div class="line">    </div><div class="line">    init?(map: Map) &#123;&#125;</div><div class="line">    </div><div class="line">    mutating func mapping(map: Map) &#123;</div><div class="line">        code    &lt;-      map[&quot;code&quot;]</div><div class="line">        message &lt;-      map[&quot;message&quot;]</div><div class="line">        result  &lt;-      map[&quot;result&quot;]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后自己写一个<code>mapResult</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public extension Response &#123;</div><div class="line">    public func mapResult&lt;T: BaseMappable&gt;(_ type: T.Type, context: MapContext? = nil) throws -&gt; [T] &#123;</div><div class="line">        </div><div class="line">        let status = try mapObject(Status.self)</div><div class="line">        </div><div class="line">         guard let array = status.result as? [[String : Any]], let objects = Mapper&lt;T&gt;(context: context).mapArray(JSONArray: array) else &#123;</div><div class="line">            throw AMError.ParseResultError(status)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return objects</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public extension ObservableType where E == Response &#123;</div><div class="line">    public func mapResult&lt;T: BaseMappable&gt;(_ type: T.Type, context: MapContext? = nil) -&gt; Observable&lt;[T]&gt; &#123;</div><div class="line">        return flatMap &#123; response -&gt; Observable&lt;[T]&gt; in</div><div class="line">            return Observable.just(try response.mapResult(T.self, context: context))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后就能获取到对应的结果了，如果出错了的话，也可以获取到错误信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.subscribe&#123;</div><div class="line">    event in</div><div class="line">    switch event&#123;</div><div class="line">    case .next(let users):</div><div class="line">        for user in users&#123;</div><div class="line">            print(&quot;\(user.name)  \(user.age)&quot;)</div><div class="line">        &#125;</div><div class="line">    case .error(let error):</div><div class="line">        var message = &quot;出错了!&quot;</div><div class="line">        if let amerror = error as? AMError, let msg = amerror.message&#123;</div><div class="line">            message = msg</div><div class="line">        &#125;</div><div class="line">        print(message)</div><div class="line">    default:</div><div class="line">        break</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家想一想如果<code>result</code>返回的是单个对象的话，应该怎么写？</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Moya</code>本身提供了强大的扩展能力，可以对其进行扩展，再加上<code>Rx</code>和<code>ObjectMapper</code>，我们可以对网络请求的发送、处理以及解析通过链式调用的方法来处理，写出优雅的代码。</p>
<p>代码见github:</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftMoya</a></p>
]]></content>
    
    <summary type="html">
    
      在学习从网络获取数据然后更新视图之前，先来了解Moya，它是一个基于Alamofire封装的网络抽象层。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - UITableView操作</title>
    <link href="http://www.alonemonkey.com/2017/03/29/rxswift-part-seven/"/>
    <id>http://www.alonemonkey.com/2017/03/29/rxswift-part-seven/</id>
    <published>2017-03-28T16:00:00.000Z</published>
    <updated>2017-03-28T15:34:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正常开发"><a href="#正常开发" class="headerlink" title="正常开发"></a>正常开发</h3><p>在正常开发中要使用<code>UITableView</code>的话，需要设置<code>dataSource</code>和<code>delegate</code>，然后实现对应的协议方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">tableView.dataSource = self</div><div class="line">tableView.delegate = self</div><div class="line"></div><div class="line"></div><div class="line">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>来个简单的例子看看<code>Rx</code>中对<code>UITableView</code>是怎么处理的。</p>
<p>老套路，新建项目，引入<code>pod</code>，放个<code>UITableView</code>和<code>UITableViewCell</code>。</p>
<p>然后初始化一些数据使用<code>Rx</code>绑定到<code>UITableView</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">let items = Observable.just(</div><div class="line">            (0...20).map&#123; &quot;\($0)&quot; &#125;</div><div class="line">        )</div><div class="line"></div><div class="line">//使用数据初始化cell   </div><div class="line">items</div><div class="line">    .bindTo(tableview.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: UITableViewCell.self))&#123;</div><div class="line">        (row, elememt, cell) in</div><div class="line">        cell.textLabel?.text = &quot;\(elememt) @row \(row)&quot;</div><div class="line">    &#125;.disposed(by: disposeBag)</div><div class="line"></div><div class="line">//cell的点击事件</div><div class="line">tableview.rx</div><div class="line">    .modelSelected(String.self)</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            value in</div><div class="line">            print(&quot;click \(value)&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>通过简短的几行代码，就把通过设置<code>dataSource</code>和<code>delegate</code>的事来做了。</p>
<p>例子官方都有，下面来看看它的原理是什么？</p>
<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">items</div><div class="line">    .bindTo(tableview.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: UITableViewCell.self))&#123;</div><div class="line">        (row, elememt, cell) in</div><div class="line">        cell.textLabel?.text = &quot;\(elememt) @row \(row)&quot;</div><div class="line">    &#125;.disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>这段代码，简单来说，是在里面创建了一个<code>dataSource</code>的代理对象，然后代理对象的方法会使用传入的<code>items</code>以及<code>cell</code>设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">override func _tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</div><div class="line">    return itemModels?.count ?? 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">override func _tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;</div><div class="line">    return cellFactory(tableView, indexPath.item, itemModels![indexPath.row])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里调用的<code>itemModels</code>就是传入的<code>items</code>, 调用的<code>cellFactory</code>就是传入的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; (tv, i, item) in</div><div class="line">    let indexPath = IndexPath(item: i, section: 0)</div><div class="line">    let cell = tv.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! Cell</div><div class="line">    configureCell(i, item, cell)</div><div class="line">    return cell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而这个<code>configureCell</code>就是最开始的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    (row, elememt, cell) in</div><div class="line">    cell.textLabel?.text = &quot;\(elememt) @row \(row)&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>modelSelected</code>也是<code>delegate</code>的<code>tableView:didSelectRowAtIndexPath:</code>包装了下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public var itemSelected: ControlEvent&lt;IndexPath&gt; &#123;</div><div class="line">    let source = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didSelectRowAt:)))</div><div class="line">        .map &#123; a in</div><div class="line">            return try castOrThrow(IndexPath.self, a[1])</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    return ControlEvent(events: source)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家还是自己看看源码理一下吧~~ </p>
<h3 id="RxDataSource"><a href="#RxDataSource" class="headerlink" title="RxDataSource"></a>RxDataSource</h3><p>如果要显示多个<code>Section</code>的<code>tableview</code>的话，可以借助<code>RxDataSource</code>帮我们完成。</p>
<p>新建一个项目，pod导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">use_frameworks!</div><div class="line"></div><div class="line">target &apos;RxSwiftTableViewSection&apos; do</div><div class="line">	</div><div class="line">pod &apos;RxSwift&apos;</div><div class="line">pod &apos;RxCocoa&apos;</div><div class="line">pod &apos;RxDataSources&apos;</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<p>这里要额外引入<code>RxDataSources</code>。</p>
<p>首先创建一个<code>dataSource</code>对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, Double&gt;&gt;()</div></pre></td></tr></table></figure>
<p>然后创建自定义的数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">let items = Observable.just([</div><div class="line">    SectionModel(model: &quot;First&quot;, items:[</div><div class="line">            1.0,</div><div class="line">            2.0,</div><div class="line">            3.0</div><div class="line">        ]),</div><div class="line">    SectionModel(model: &quot;Second&quot;, items:[</div><div class="line">        1.0,</div><div class="line">        2.0,</div><div class="line">        3.0</div><div class="line">        ]),</div><div class="line">    SectionModel(model: &quot;Third&quot;, items:[</div><div class="line">        1.0,</div><div class="line">        2.0,</div><div class="line">        3.0</div><div class="line">        ])</div><div class="line">    ])</div></pre></td></tr></table></figure>
<p>配置<code>cell</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dataSource.configureCell = &#123;</div><div class="line">        (_, tv, indexPath, element) in</div><div class="line">        let cell = tv.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)!</div><div class="line">        cell.textLabel?.text = &quot;\(element) @ row \(indexPath.row)&quot;</div><div class="line">        return cell</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>设置<code>section</code>的<code>title</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dataSource.titleForHeaderInSection = &#123; dataSource, sectionIndex in</div><div class="line">    return dataSource[sectionIndex].model</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把数据绑定到<code>dataSource</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">items</div><div class="line">            .bindTo(tableview.rx.items(dataSource: dataSource))</div><div class="line">            .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>点击事件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">tableview.rx</div><div class="line">        .itemSelected</div><div class="line">        .map &#123; indexPath in</div><div class="line">            return (indexPath, dataSource[indexPath])</div><div class="line">        &#125;</div><div class="line">        .subscribe(onNext: &#123; indexPath, model in</div><div class="line">            print(&quot;Tapped `\(model)` @ \(indexPath)&quot;)</div><div class="line">        &#125;)</div><div class="line">        .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>虽然<code>RxDataSource</code>内部有一个代理对象，但是我们仍然可以设置<code>delegate</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tableview.rx</div><div class="line">            .setDelegate(self)</div><div class="line">            .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>然后实现<code>delegate</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">extension ViewController : UITableViewDelegate&#123;</div><div class="line">    func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCellEditingStyle &#123;</div><div class="line">        return .none</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;</div><div class="line">        return 40</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里和上面不同的是，我们主动创建了一个<code>dataSource</code>传了进去。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>上面我们提到了代理对象，这个代理对象到底是什么？</p>
<p>我们来看看源码中的解释:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490714597458.png" alt="image"></p>
<p>它就相当与一个中间拦截器，把原始的代码对象的方法转成一个个可被观察的序列发射出去，然后再转发给我们自定义的<code>delegate</code>。所以它既不影响我们自己设置的<code>delegate</code>，同时还可以以<code>Rx</code>的方式去处理这些事件。</p>
<p>本文的例子都是以为官方为例，后面会加入通过网络请求获取<code>Model</code>等操作。</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftTableView</a></p>
]]></content>
    
    <summary type="html">
    
      在开发中，除了前面讲到的注册或登录界面，打交道最后的应该是UITableView，来看看Rx中是怎么处理UITableView的。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - Observable 和 Driver</title>
    <link href="http://www.alonemonkey.com/2017/03/28/rxswift-part-six/"/>
    <id>http://www.alonemonkey.com/2017/03/28/rxswift-part-six/</id>
    <published>2017-03-27T16:00:00.000Z</published>
    <updated>2017-03-27T16:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Driver"><a href="#什么是Driver" class="headerlink" title="什么是Driver"></a>什么是Driver</h3><p><code>Driver</code>的出现是为了让我们在写UI层的响应式代码的时候更加直观。</p>
<p>为什么它的名字叫<code>Driver</code>？它意图更好的通过数据去驱动我们的应用程序。</p>
<p>比如:</p>
<ul>
<li>从数据模型去驱动UI</li>
<li>使用其它UI元素的值去驱动UI</li>
<li>…….</li>
</ul>
<p>在正常开发中，由于用户操作导致错误发生可能会使我们的应用程序崩溃。</p>
<p>由于UI元素操作通常不是线程安全的，要保证在主线程操作。</p>
<p>或者某个序列在有多个订阅者者时只需要<code>shareReplay(1)</code>。</p>
<h3 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h3><p>先来看一下经典的例子，看看我们在正常的开发中可能会写出如下的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let results = query.rx.text</div><div class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</div><div class="line">    .flatMapLatest &#123; query in</div><div class="line">        fetchAutoCompleteItems(query)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">results</div><div class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</div><div class="line">    .bind(to: resultCount.rx.text)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">results</div><div class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123; (_, result, cell) in</div><div class="line">        cell.textLabel?.text = &quot;\(result)&quot;</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>这段代码的意图是：</p>
<ul>
<li>对用户的输入进行节流</li>
<li>每次查询连接服务器搜索结果</li>
<li>绑定结果到UI结果</li>
</ul>
<p>我们来看看这段代码有什么问题？</p>
<ul>
<li>如果<code>fetchAutoCompleteItems</code>发生了错误，网络错误或者解析出错，这个错误会导致取消所有绑定，UI界面也不会更新新的结果。</li>
<li>如果<code>fetchAutoCompleteItems</code>在后台线程返回了结果，结果可能会在后台线程绑定到UI界面，这样会导致不确定的崩溃。</li>
<li>结果绑定到了两个UI元素，意味着，每次用户搜索，会发送2次请求，这不是我们想要的行为。</li>
</ul>
<p>所以规范一点的写法应该是这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let results = query.rx.text</div><div class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</div><div class="line">    .flatMapLatest &#123; query in</div><div class="line">        fetchAutoCompleteItems(query)</div><div class="line">            .observeOn(MainScheduler.instance)  // results are returned on MainScheduler</div><div class="line">            .catchErrorJustReturn([])           // in the worst case, errors are handled</div><div class="line">    &#125;</div><div class="line">    .shareReplay(1)                             // HTTP requests are shared and results replayed</div><div class="line">                                                // to all UI elements</div><div class="line"></div><div class="line">results</div><div class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</div><div class="line">    .bind(to: resultCount.rx.text)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">results</div><div class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123; (_, result, cell) in</div><div class="line">        cell.textLabel?.text = &quot;\(result)&quot;</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>要保证这些所有的情况都被处理在大的系统里面是很难的，这里有一种简单的方法哪就是使用<code>Driver</code>。来看下下面的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">let results = query.rx.text.asDriver()        // This converts a normal sequence into a `Driver` sequence.</div><div class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</div><div class="line">    .flatMapLatest &#123; query in</div><div class="line">        fetchAutoCompleteItems(query)</div><div class="line">            .asDriver(onErrorJustReturn: [])  // Builder just needs info about what to return in case of error.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">results</div><div class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</div><div class="line">    .drive(resultCount.rx.text)               // If there is a `drive` method available instead of `bindTo`,</div><div class="line">    .disposed(by: disposeBag)              // that means that the compiler has proven that all properties</div><div class="line">                                              // are satisfied.</div><div class="line">results</div><div class="line">    .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123; (_, result, cell) in</div><div class="line">        cell.textLabel?.text = &quot;\(result)&quot;</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="Driver特性"><a href="#Driver特性" class="headerlink" title="Driver特性"></a>Driver特性</h3><p>上面改进后的版本发生了什么？首先第一个<code>asDriver</code>把<code>ControlProperty</code>对象转换成了<code>Driver</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">query.rx.text.asDriver()</div></pre></td></tr></table></figure>
<p><code>Driver</code>拥有<code>ControlProperty</code>的所有属性，其实它是在上面包了一层。</p>
<p>第二个改变的地方是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.asDriver(onErrorJustReturn: [])</div></pre></td></tr></table></figure>
<p>任何的可被观察的序列都能转成<code>Driver</code>，只要满足以下3点:</p>
<ul>
<li>不能抛出错误</li>
<li>订阅在主线程</li>
<li>多个订阅者<code>shareReplay(1)</code></li>
</ul>
<p><code>asDriver(onErrorJustReturn: [])</code>其实等同于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let safeSequence = xs</div><div class="line">  .observeOn(MainScheduler.instance)       // observe events on main scheduler</div><div class="line">  .catchErrorJustReturn(onErrorJustReturn) // can&apos;t error out</div><div class="line">  .shareReplayLatestWhileConnected         // side effects sharing</div><div class="line">return Driver(raw: safeSequence)           // wrap it up</div></pre></td></tr></table></figure>
<p>最后一点就是使用<code>drive</code>代替<code>bindTo</code>。</p>
<p>所以下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let intDriver = sequenceOf(1, 2, 3, 4, 5, 6)</div><div class="line">    .asDriver(onErrorJustReturn: 1)</div><div class="line">    .map &#123; $0 + 1 &#125;</div><div class="line">    .filter &#123; $0 &lt; 5 &#125;</div></pre></td></tr></table></figure>
<p>等价:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let intObservable = sequenceOf(1, 2, 3, 4, 5, 6)</div><div class="line">    .observeOn(MainScheduler.sharedInstance)</div><div class="line">    .catchErrorJustReturn(1)</div><div class="line">    .map &#123; $0 + 1 &#125;</div><div class="line">    .filter &#123; $0 &lt; 5 &#125;</div><div class="line">    .shareReplay(1)</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过例子，大家也看到了什么时候应该使用<code>Driver</code>，如果你的代码需要满足上面三种情况的话，那么你可以使用<code>Driver</code>。否则如果你要多次切换线程、自己捕获传递错误、或者其它，可以仍用<code>Observable</code>。</p>
<p>大家试着把上一篇讲的注册项目改成<code>Driver</code>。</p>
<p>然后参考<code>Driver</code>的版本:</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftRegisterDriver</a></p>
]]></content>
    
    <summary type="html">
    
      什么是Driver，它有什么特点？和Observable用起来有哪些区别，我们来一起看看吧~ 
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 用户注册</title>
    <link href="http://www.alonemonkey.com/2017/03/27/rxswift-part-five/"/>
    <id>http://www.alonemonkey.com/2017/03/27/rxswift-part-five/</id>
    <published>2017-03-26T16:00:00.000Z</published>
    <updated>2017-04-19T09:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在本文开始前，我们先来理一理一个正常的注册流程中可能会有哪些需求:</p>
<ul>
<li>用户名或密码是否为空</li>
<li>用户名密码是否合法</li>
<li>重复密码是否一致</li>
<li>点击注册发送网络请求</li>
<li>处理返回结果</li>
<li>…….</li>
</ul>
<p>在这里其实可以把很多处理归并到<code>被观察者 - 订阅者</code>模式，通过某种事件触发某种行为，某种行为依赖不同事件的状态，所以我们可以通过<code>RxSwift</code>很方便的去解决我们的问题。</p>
<h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><p>新建项目<code>RxSwiftRegister</code>，<code>pod</code>引入<code>RxSwift</code>和<code>RxCocoa</code>。先来设计一个简单的界面，界面上会有账号和密码的输入框，注册按钮，以及提示信息，然后绑定到<code>LoginViewController</code>。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490535465031.png" alt="image"></p>
<h3 id="验证为空"><a href="#验证为空" class="headerlink" title="验证为空"></a>验证为空</h3><p>这里需要验证用户名是不是为空，是否已经注册，密码是否为空，重复密码是否一致。</p>
<p>为了让逻辑与视图分离，这里我们使用<code>MVVM</code>模式，如果你还不知道<code>MVVM</code>可以自己先了解一下。</p>
<p>新建<code>LoginViewModel</code>文件，接受账号、密码、重复密码作为被观察者，然后对其中的<code>text</code>进行验证处理，返回一个验证的结果(暂时用Bool表示)。</p>
<p>文件目录:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490539454404.png" alt="image"></p>
<p><code>LoginViewModel</code>编写如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">class RegisterViewModel &#123;</div><div class="line">    let validatedUsername: Observable&lt;Bool&gt;</div><div class="line">    let validatedPassword: Observable&lt;Bool&gt;</div><div class="line">    let validatedPasswordRepeated: Observable&lt;Bool&gt;</div><div class="line">    </div><div class="line">    init(input:(</div><div class="line">        username: Observable&lt;String&gt;,</div><div class="line">        password: Observable&lt;String&gt;,</div><div class="line">        repeatedPassword: Observable&lt;String&gt;,</div><div class="line">        registerTap: Observable&lt;Void&gt;</div><div class="line">        ))&#123;</div><div class="line">        </div><div class="line">        validatedUsername = input.username.map&#123;</div><div class="line">            username in</div><div class="line">            return username == &quot;&quot; ? false : true</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        validatedPassword = input.password.map&#123;</div><div class="line">            password in</div><div class="line">            return password == &quot;&quot; ? false : true</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        validatedPasswordRepeated = Observable.combineLatest(input.password, input.repeatedPassword)&#123;</div><div class="line">            password, repeatedPassword in</div><div class="line">            if repeatedPassword == &quot;&quot;&#123;</div><div class="line">                return false</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if password != repeatedPassword&#123;</div><div class="line">                return false</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            return true</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只是简单验证是否为空，后面再改进。</p>
<p><code>RegisterViewController</code>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">class RegisterViewController: UIViewController &#123;</div><div class="line"></div><div class="line">    @IBOutlet weak var username: UITextField!</div><div class="line">    @IBOutlet weak var usernameValidation: UILabel!</div><div class="line">    </div><div class="line">    @IBOutlet weak var password: UITextField!</div><div class="line">    @IBOutlet weak var passwordValidation: UILabel!</div><div class="line">    </div><div class="line">    @IBOutlet weak var repoatedPassword: UITextField!</div><div class="line">    @IBOutlet weak var repeatedPasswordValidation: UILabel!</div><div class="line">    </div><div class="line">    @IBOutlet weak var registerIndicator: UIActivityIndicatorView!</div><div class="line">    @IBOutlet weak var register: UIButton!</div><div class="line">    </div><div class="line">    let disposed = DisposeBag()</div><div class="line">    </div><div class="line">    override func viewDidLoad() &#123;</div><div class="line">        super.viewDidLoad()</div><div class="line">        </div><div class="line">        let viewModel = RegisterViewModel(input:(</div><div class="line">            username: username.rx.text.orEmpty.asObservable(),</div><div class="line">            password: password.rx.text.orEmpty.asObservable(),</div><div class="line">            repeatedPassword: repoatedPassword.rx.text.orEmpty.asObservable(),</div><div class="line">            registerTap: register.rx.tap.asObservable()</div><div class="line">        ))</div><div class="line">        </div><div class="line">        viewModel.validatedUsername.subscribe(</div><div class="line">            onNext:&#123;</div><div class="line">                valid in</div><div class="line">                print(&quot;username is \(valid)&quot;)</div><div class="line">            &#125;</div><div class="line">        ).disposed(by: disposed)</div><div class="line">        </div><div class="line">        viewModel.validatedPassword.subscribe(</div><div class="line">            onNext:&#123;</div><div class="line">                valid in</div><div class="line">                print(&quot;password is \(valid)&quot;)</div><div class="line">            &#125;</div><div class="line">        ).disposed(by: disposed)</div><div class="line">        </div><div class="line">        viewModel.validatedPasswordRepeated.subscribe(</div><div class="line">            onNext:&#123;</div><div class="line">                valid in</div><div class="line">                print(&quot;repoatedPassword is \(valid)&quot;)</div><div class="line">            &#125;</div><div class="line">        ).disposed(by: disposed)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override func didReceiveMemoryWarning() &#123;</div><div class="line">        super.didReceiveMemoryWarning()</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>订阅账号、密码、重复密码是否验证成功的值打印出来，运行可以得到验证，一开始都是false，输入了后变成true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">username is false</div><div class="line">password is false</div><div class="line">repoatedPassword is false</div><div class="line">username is false</div><div class="line">username is true</div><div class="line">username is true</div><div class="line">password is false</div><div class="line">repoatedPassword is false</div><div class="line">password is true</div><div class="line">repoatedPassword is false</div><div class="line">password is true</div><div class="line">repoatedPassword is false</div><div class="line">repoatedPassword is false</div><div class="line">repoatedPassword is false</div><div class="line">repoatedPassword is false</div><div class="line">repoatedPassword is true</div></pre></td></tr></table></figure>
<p>接下来来看一些问题，当有两个订阅者去订阅用户名是否验证ok，然后在验证的时候去打印一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">viewModel.validatedUsername.subscribe(</div><div class="line">    onNext:&#123;</div><div class="line">        valid in</div><div class="line">        print(&quot;username is \(valid)&quot;)</div><div class="line">    &#125;</div><div class="line">).disposed(by: disposed)</div><div class="line"></div><div class="line">viewModel.validatedUsername.subscribe(</div><div class="line">    onNext:&#123;</div><div class="line">        valid in</div><div class="line">        print(&quot;username 2 is \(valid)&quot;)</div><div class="line">    &#125;</div><div class="line">).disposed(by: disposed)</div><div class="line"></div><div class="line">-------------------------------------------</div><div class="line"></div><div class="line">validatedUsername = input.username.map&#123;</div><div class="line">    username in</div><div class="line">    print(username)</div><div class="line">    return username == &quot;&quot; ? false : true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会发现，多了一个订阅者后，验证的逻辑会执行两次，这并不是我们想要的效果，当验证是一个网络请求的话，会发出两个一样的。同一个值只需要验证一次，然后告诉所有的订阅者就行了。这里需要使用到<code>shareReplay(1)</code>，保证多个订阅者共享单个订阅，并重播最新的一次<code>replay</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">validatedUsername = input.username.map&#123;</div><div class="line">    username in</div><div class="line">    print(username)</div><div class="line">    return username == &quot;&quot; ? false : true</div><div class="line">&#125;.shareReplay(1)</div></pre></td></tr></table></figure>
<p>同样对密码和重复密码也只需要共享一次。</p>
<h3 id="绑定错误到Label"><a href="#绑定错误到Label" class="headerlink" title="绑定错误到Label"></a>绑定错误到Label</h3><p>上面只是通过控制台打印了验证的对或错，但是并不知道错的原因，也没有显示到<code>label</code>上，现在来实现这个效果，我们要定义个表示不同验证结果和信息的枚举。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum ValidationResult &#123;</div><div class="line">    case ok(message: String)    //验证成功和信息</div><div class="line">    case empty                  //输入为空</div><div class="line">    case validating</div><div class="line">    case failed(message: String)      //验证失败的原因</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后修改返回结果类型为<code>ValidationResult</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">enum ValidationResult &#123;</div><div class="line">    case ok(message: String)</div><div class="line">    case empty</div><div class="line">    case validating</div><div class="line">    case failed(message: String)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class RegisterViewModel &#123;</div><div class="line">    let validatedUsername: Observable&lt;ValidationResult&gt;</div><div class="line">    let validatedPassword: Observable&lt;ValidationResult&gt;</div><div class="line">    let validatedPasswordRepeated: Observable&lt;ValidationResult&gt;</div><div class="line">    </div><div class="line">    init(input:(</div><div class="line">        username: Observable&lt;String&gt;,</div><div class="line">        password: Observable&lt;String&gt;,</div><div class="line">        repeatedPassword: Observable&lt;String&gt;,</div><div class="line">        registerTap: Observable&lt;Void&gt;</div><div class="line">        ))&#123;</div><div class="line">        </div><div class="line">        validatedUsername = input.username.map&#123;</div><div class="line">            username in</div><div class="line">            return username == &quot;&quot; ? .empty : .ok(message: &quot;验证通过&quot;)</div><div class="line">        &#125;.shareReplay(1)</div><div class="line">        </div><div class="line">        validatedPassword = input.password.map&#123;</div><div class="line">            password in</div><div class="line">            return password == &quot;&quot; ? .empty : .ok(message: &quot;验证通过&quot;)</div><div class="line">        &#125;.shareReplay(1)</div><div class="line">        </div><div class="line">        validatedPasswordRepeated = Observable.combineLatest(input.password, input.repeatedPassword)&#123;</div><div class="line">            password, repeatedPassword in</div><div class="line">            if repeatedPassword == &quot;&quot;&#123;</div><div class="line">                return .empty</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if password != repeatedPassword&#123;</div><div class="line">                return .failed(message:&quot;两次输入的密码不一致&quot;)</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            return .ok(message: &quot;验证通过&quot;)</div><div class="line">        &#125;.shareReplay(1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后绑定错误到<code>label</code>，为了让<code>ValidationResult</code>能绑定到<code>label</code>，需要给出不同结果的文字颜色和文字信息，这时需要给<code>ValidationResult</code>扩展一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">extension ValidationResult: CustomStringConvertible &#123;</div><div class="line">    var description: String &#123;</div><div class="line">        switch self &#123;</div><div class="line">        case let .ok(message):</div><div class="line">            return message</div><div class="line">        case .empty:</div><div class="line">            return &quot;&quot;</div><div class="line">        case .validating:</div><div class="line">            return &quot;validating ...&quot;</div><div class="line">        case let .failed(message):</div><div class="line">            return message</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct ValidationColors &#123;</div><div class="line">    static let okColor = UIColor(red: 138.0 / 255.0, green: 221.0 / 255.0, blue: 109.0 / 255.0, alpha: 1.0)</div><div class="line">    static let errorColor = UIColor.red</div><div class="line">&#125;</div><div class="line"></div><div class="line">extension ValidationResult &#123;</div><div class="line">    var textColor: UIColor &#123;</div><div class="line">        switch self &#123;</div><div class="line">        case .ok:</div><div class="line">            return ValidationColors.okColor</div><div class="line">        case .empty:</div><div class="line">            return UIColor.black</div><div class="line">        case .validating:</div><div class="line">            return UIColor.black</div><div class="line">        case .failed:</div><div class="line">            return ValidationColors.errorColor</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样为了使<code>label</code>能够根据对应的信息和颜色更新，需要提供:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extension Reactive where Base: UILabel &#123;</div><div class="line">    var validationResult: UIBindingObserver&lt;Base, ValidationResult&gt; &#123;</div><div class="line">        return UIBindingObserver(UIElement: base) &#123; label, result in</div><div class="line">            label.textColor = result.textColor</div><div class="line">            label.text = result.description</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后绑定:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">viewModel.validatedUsername</div><div class="line">    .bindTo(usernameValidation.rx.validationResult)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line">        </div><div class="line">viewModel.validatedPassword</div><div class="line">    .bindTo(passwordValidation.rx.validationResult)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">viewModel.validatedPasswordRepeated</div><div class="line">    .bindTo(repeatedPasswordValidation.rx.validationResult)</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>效果如下:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490545656582.png" alt="image"></p>
<h3 id="注册按钮状态"><a href="#注册按钮状态" class="headerlink" title="注册按钮状态"></a>注册按钮状态</h3><p>接下来需要根据上面的验证结果来确定注册按钮的可点击状态，只有当账号、密码、重复密码都验证通过之后才会变成可点击的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">let registerEnabled: Observable&lt;Bool&gt;</div><div class="line"></div><div class="line">registerEnabled = Observable.combineLatest(validatedUsername, validatedPassword, validatedPasswordRepeated)&#123;</div><div class="line">    username, password, repeatedPassword in</div><div class="line">    username.isValid &amp;&amp;</div><div class="line">    password.isValid &amp;&amp;</div><div class="line">    repeatedPassword.isValid</div><div class="line">    &#125;</div><div class="line">    .distinctUntilChanged()</div><div class="line">    .shareReplay(1)</div><div class="line"></div><div class="line">viewModel.registerEnabled.subscribe(</div><div class="line">    onNext:&#123;</div><div class="line">        [weak self] valid in</div><div class="line">        guard let `self` = self else&#123;</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        self.register.isEnabled = valid</div><div class="line">        self.register.alpha = valid ? 1.0 : 0.5</div><div class="line">    &#125;</div><div class="line">).disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>这里有几点：</p>
<ul>
<li>只需要共享一次，使用<code>shareReplay</code></li>
<li>不用每次改变都发射给订阅者，只有当发生改变时再发射，使用<code>distinctUntilChanged</code></li>
<li>捕获<code>self</code>的弱引用，然后再里面转成强引用</li>
</ul>
<h3 id="网络验证"><a href="#网络验证" class="headerlink" title="网络验证"></a>网络验证</h3><p>前面只是在本地做了一个简单的验证，现在想要验证输入的账号是否能注册，就需要发送网络请求去验证。</p>
<p>这里参考官方给出的例子，通过url判断是否有效:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class GitHubAPI&#123;</div><div class="line">    let URLSession: URLSession</div><div class="line">    </div><div class="line">    static let sharedAPI = GitHubAPI(</div><div class="line">        URLSession: Foundation.URLSession.shared</div><div class="line">    )</div><div class="line">    </div><div class="line">    init(URLSession: URLSession)&#123;</div><div class="line">        self.URLSession = URLSession</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func usernameAvailable(_ username: String) -&gt; Observable&lt;Bool&gt;&#123;</div><div class="line">        let url = URL(string: &quot;https://github.com/\(username.URLEscaped)&quot;)!</div><div class="line">        let request = URLRequest(url: url)</div><div class="line">        return self.URLSession.rx.response(request: request)</div><div class="line">            .map&#123;</div><div class="line">                (response, _) in</div><div class="line">                return response.statusCode == 404</div><div class="line">            &#125;</div><div class="line">            .catchErrorJustReturn(false)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果url存在就认为已注册，否则就是没有。</p>
<p>那么用户名验证可以改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//flatMapLatest 如果有新的值发射出来，则会取消原来发出的网络请求</div><div class="line">//flatMap 则不会</div><div class="line">validatedUsername = input.username</div><div class="line">    .flatMapLatest&#123;</div><div class="line">    username -&gt; Observable&lt;ValidationResult&gt; in</div><div class="line">    //是否为空</div><div class="line">    if username.characters.count == 0&#123;</div><div class="line">        return Observable.just(.empty)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //是否是数字和字母</div><div class="line">    if username.rangeOfCharacter(from: CharacterSet.alphanumerics.inverted) != nil &#123;</div><div class="line">        return  Observable.just(.failed(message: &quot;Username can only contain numbers or digits&quot;))</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    let loadingValue = ValidationResult.validating</div><div class="line">    </div><div class="line">    return API.usernameAvailable(username)</div><div class="line">            .map&#123;</div><div class="line">                available in</div><div class="line">                if available &#123;</div><div class="line">                    return .ok(message: &quot;Username available&quot;)</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    return .failed(message: &quot;Username already taken&quot;)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            .startWith(loadingValue)  //开始发射一个正在验证的值</div><div class="line">            .observeOn(MainScheduler.instance)   //将监听事件绑定到主线程</div><div class="line">            .catchErrorJustReturn(.failed(message: &quot;Error contacting server&quot;))</div><div class="line">&#125;.shareReplay(1)</div></pre></td></tr></table></figure>
<p>同样把密码和重复密码也改下。</p>
<h3 id="注册请求"><a href="#注册请求" class="headerlink" title="注册请求"></a>注册请求</h3><p>这里和官方例子一样，模拟下注册过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func register(_ username: String, password: String) -&gt; Observable&lt;Bool&gt;&#123;</div><div class="line">    let registerResult = arc4random() % 5 == 0 ? false : true</div><div class="line">    return Observable.just(registerResult)</div><div class="line">            .delay(1.0, scheduler: MainScheduler.instance)  //延迟一秒</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后绑定注册的点击事件，执行注册请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//合并注册点击和账号密码序列，每次注册点击，从第二个序列取最新的值</div><div class="line">let usernameAndPassword = Observable.combineLatest(input.username, input.password) &#123; ($0, $1) &#125;</div><div class="line">        </div><div class="line">registered = input.registerTap.withLatestFrom(usernameAndPassword)</div><div class="line">    .flatMapLatest&#123;</div><div class="line">        (username, password) in</div><div class="line">        return API.register(username, password: password)</div><div class="line">                .observeOn(MainScheduler.instance)</div><div class="line">                .catchErrorJustReturn(false)</div><div class="line">                .trackActivity(registering)</div><div class="line">    &#125;.shareReplay(1)</div></pre></td></tr></table></figure>
<p><code>trackActivity</code>是官方例子里面的，用于监控序列的计算中和结束。</p>
<p>到此这个例子就结束了，如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490618590053.png" alt="image"></p>
<h3 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h3><p>有几点交互需要优化一下:</p>
<ul>
<li>点击背景收起键盘</li>
<li>点击键盘的<code>Next</code>调到下一个<code>UITextField</code></li>
<li>点击<code>Go</code>触发注册流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//点击背景收起键盘</div><div class="line">let tapBackground = UITapGestureRecognizer()</div><div class="line">tapBackground.rx.event</div><div class="line">    .subscribe(onNext: &#123; [unowned self] _ in</div><div class="line">        self.view.endEditing(true)</div><div class="line">    &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line">view.addGestureRecognizer(tapBackground)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">username.rx.controlEvent(.editingDidEnd)</div><div class="line">    .subscribe&#123;</div><div class="line">        [unowned self] _ in</div><div class="line">        self.password.becomeFirstResponder()</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">password.rx.controlEvent(.editingDidEnd)</div><div class="line">    .subscribe&#123;</div><div class="line">        [unowned self] _ in</div><div class="line">        self.repoatedPassword.becomeFirstResponder()</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">repoatedPassword.rx.controlEvent(.editingDidEndOnExit)</div><div class="line">    .bindTo(viewModel.registerTap)</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>完整源码见Github</p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftRegister</a></p>
]]></content>
    
    <summary type="html">
    
      本文以最常见的用户注册界面为例，学习RxSwift在实践中的更多应用。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 加法运算</title>
    <link href="http://www.alonemonkey.com/2017/03/25/rxswift-part-four/"/>
    <id>http://www.alonemonkey.com/2017/03/25/rxswift-part-four/</id>
    <published>2017-03-24T16:00:00.000Z</published>
    <updated>2017-03-25T10:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过前面几篇文章了解了很多<code>RxSwift</code>中的概念和序列操作。下面从一个最基础的例子来看看实际开发中的被观察者和订阅者。</p>
<p>这里要实现的仅仅是输入三个整数并实时把三个整数相加的结果显示出来。</p>
<h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><p>这里没有界面设计就是拖了几个<code>UITextField</code>。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490431861515.png" alt="image"></p>
<p>当每次上面的三个输入框输入改变了的话，就把三个值相加显示出来。</p>
<h3 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h3><p>首先创建一个<code>Swift</code>的项目<code>RxSwiftCalculator</code>，<code>Podfile</code>内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">use_frameworks!</div><div class="line"></div><div class="line">target &apos;RxSwiftCalculator&apos; do</div><div class="line"></div><div class="line">pod &apos;RxSwift&apos;</div><div class="line">pod &apos;RxCocoa&apos;</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure>
<p>因为需要用到UI控件里面的Rx扩展，所有引入了<code>RxCocoa</code>。</p>
<p><code>pod install</code>后打开<code>RxSwiftCalculator.xcworkspace</code>。</p>
<p>把界面拖一下, 然后关联到属性。</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490434019587.png" alt="image"></p>
<h3 id="UITextField-rx-text"><a href="#UITextField-rx-text" class="headerlink" title="UITextField.rx.text"></a>UITextField.rx.text</h3><p>在这个项目里面我们要监听<code>UITextField</code>的事件，然后把里面的数字取出来相加，最后显示到<code>result</code>这个<code>Label</code>上面。</p>
<p>所以本例中<code>UITextField</code>就是一个被观察者。</p>
<p>在<code>RxCocoa</code>里面已经对<code>UITextField</code>进行了扩展，把的里面的文本变成一个可被观察的对象<code>text</code>，源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">extension Reactive where Base: UITextField &#123;</div><div class="line">    /// Reactive wrapper for `text` property.</div><div class="line">    public var text: ControlProperty&lt;String?&gt; &#123;</div><div class="line">        return value</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /// Reactive wrapper for `text` property.</div><div class="line">    public var value: ControlProperty&lt;String?&gt; &#123;</div><div class="line">        return UIControl.rx.value(</div><div class="line">            base,</div><div class="line">            getter: &#123; textField in</div><div class="line">                textField.text</div><div class="line">            &#125;, setter: &#123; textField, value in</div><div class="line">                // This check is important because setting text value always clears control state</div><div class="line">                // including marked text selection which is imporant for proper input </div><div class="line">                // when IME input method is used.</div><div class="line">                if textField.text != value &#123;</div><div class="line">                    textField.text = value</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里返回的是一个<code>ControlProperty</code>类型的字符串，而<code>ControlProperty</code>实现了协议<code>ControlPropertyType</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public struct ControlProperty&lt;PropertyType&gt; : ControlPropertyType &#123;</div><div class="line">    //.....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟进<code>ControlPropertyType</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/// Protocol that enables extension of `ControlProperty`.</div><div class="line">public protocol ControlPropertyType : ObservableType, ObserverType &#123;</div><div class="line"></div><div class="line">    /// - returns: `ControlProperty` interface</div><div class="line">    func asControlProperty() -&gt; ControlProperty&lt;E&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>ControlPropertyType</code>实现了两个协议<code>ObservableType</code>和<code>ObserverType</code>。所以它即可是一个可被观察的对象，同时也可以作为观察者。</p>
<p>同时，我们看到这里返回了一个<code>UIControl.rx.value</code>生成的对象，跟进去看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static func value&lt;C: UIControl, T&gt;(_ control: C, getter: @escaping (C) -&gt; T, setter: @escaping (C, T) -&gt; Void) -&gt; ControlProperty&lt;T&gt; &#123;</div><div class="line">    let source: Observable&lt;T&gt; = Observable.create &#123; [weak weakControl = control] observer in</div><div class="line">            guard let control = weakControl else &#123;</div><div class="line">                observer.on(.completed)</div><div class="line">                return Disposables.create()</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            observer.on(.next(getter(control)))</div><div class="line"></div><div class="line">            let controlTarget = ControlTarget(control: control, controlEvents: [.allEditingEvents, .valueChanged]) &#123; _ in</div><div class="line">                if let control = weakControl &#123;</div><div class="line">                    observer.on(.next(getter(control)))</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            return Disposables.create(with: controlTarget.dispose)</div><div class="line">        &#125;</div><div class="line">        .takeUntil((control as NSObject).rx.deallocated)</div><div class="line"></div><div class="line">    let bindingObserver = UIBindingObserver(UIElement: control, binding: setter)</div><div class="line"></div><div class="line">    return ControlProperty&lt;T&gt;(values: source, valueSink: bindingObserver)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里创建了一个可被观察者，那么发射的值是什么时候发射的呢？ 跟进<code>ControlTarget</code>的<code>init</code>方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">init(control: Control, controlEvents: UIControlEvents, callback: @escaping Callback) &#123;</div><div class="line">    MainScheduler.ensureExecutingOnScheduler()</div><div class="line"></div><div class="line">    self.control = control</div><div class="line">    self.controlEvents = controlEvents</div><div class="line">    self.callback = callback</div><div class="line"></div><div class="line">    super.init()</div><div class="line"></div><div class="line">    control.addTarget(self, action: selector, for: controlEvents)</div><div class="line"></div><div class="line">    let method = self.method(for: selector)</div><div class="line">    if method == nil &#123;</div><div class="line">        rxFatalError(&quot;Can&apos;t find method&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>control</code>就传进来的<code>UITextField</code>对象，然后把它的<code>controlEvents</code>事件绑定到了<code>selector</code>,这个<code>selector</code>是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let selector: Selector = #selector(ControlTarget.eventHandler(_:))</div></pre></td></tr></table></figure>
<p>然后这个方法里面会调用初始化传进来的<code>callback</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func eventHandler(_ sender: Control!) &#123;</div><div class="line">    if let callback = self.callback, let control = self.control &#123;</div><div class="line">        callback(control)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后<code>callback</code>里面调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observer.on(.next(getter(control)))</div></pre></td></tr></table></figure>
<p>发射一个值，调用<code>getter</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getter: &#123; textField in</div><div class="line">                textField.text</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>也就是发射了一个<code>textField.text</code>。</p>
<p>这个时候应该明白是怎么回事了吧。</p>
<h3 id="监听UITextField"><a href="#监听UITextField" class="headerlink" title="监听UITextField"></a>监听UITextField</h3><p>这里测试一下监听<code>UITextField</code>的事件触发发射出来的<code>text</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">numberOne.rx.text.asObservable().subscribe&#123;</div><div class="line">            print($0)</div><div class="line">        &#125;.disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>把它变成一个可被观察者，然后订阅它。</p>
<p>程序启动会发射一个<code>Optional(&quot;&quot;)</code>, 获得焦点或也会发射一个<code>Optional(&quot;&quot;)</code>，然后每次输入都会把当前的文本发射出来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">next(Optional(&quot;&quot;))</div><div class="line">next(Optional(&quot;&quot;))</div><div class="line">next(Optional(&quot;1&quot;))</div><div class="line">next(Optional(&quot;12&quot;))</div><div class="line">next(Optional(&quot;123&quot;))</div><div class="line">next(Optional(&quot;1234&quot;))</div></pre></td></tr></table></figure>
<p>这里发现它是一个<code>Optional</code>的值，可以通过<code>orEmpty</code>可以把<code>String?</code>转成<code>String</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">numberOne.rx.text.orEmpty.asObservable().subscribe&#123;</div><div class="line">            print($0)</div><div class="line">        &#125;.disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">next()</div><div class="line">next()</div><div class="line">next(1)</div><div class="line">next(12)</div><div class="line">next(123)</div><div class="line">next(1234)</div></pre></td></tr></table></figure>
<p>我们再想把空字符串过滤掉，可以使用<code>filter</code>，就不会订阅到<code>next()</code>了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">numberOne.rx.text.orEmpty.asObservable()</div><div class="line">            .filter&#123;</div><div class="line">                return $0 != &quot;&quot;</div><div class="line">            &#125;</div><div class="line">            .subscribe&#123;</div><div class="line">            print($0)</div><div class="line">        &#125;.disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p>还记得我们的目的是获取最新的<code>text</code>然后相加再显示到<code>result</code>吧，那么这里我们可以使用<code>combineLatest</code>来获取最新序列的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.combineLatest(numberOne.rx.text.orEmpty,numberTwo.rx.text.orEmpty,numberThree.rx.text.orEmpty) &#123; (numberOneText, numberTwoText, numberThreeText) -&gt; Int in</div><div class="line">                return (Int(numberOneText) ?? 0) + (Int(numberTwoText) ?? 0) + (Int(numberThreeText) ?? 0)</div><div class="line">            &#125;.map&#123;</div><div class="line">                $0.description</div><div class="line">            &#125;.bindTo(result.rx.text)</div><div class="line">            .disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<p>首先获取最新输入的字符串，然后转成<code>Int</code>， 因为字母会转换失败，所以返回的是一个<code>Optional</code>，如果转换失败就默认0，然后相加返回，再转成字符串绑定到<code>result.rx.text</code>。</p>
<p>这里的<code>bindTo</code>其实就是订阅序列，然后更新<code>result.rx.text</code>的值。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然这个例子比较简单，但是相信大家能够体会到前面的一大堆概念在开发的应用以及带给我们的便利了，后续会继续学习复杂一点的例子。</p>
<p>本文代码地址: </p>
<p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftCalculator</a></p>
]]></content>
    
    <summary type="html">
    
      通过一个简单加法运算的Demo来了解实现中的被观察者和订阅者
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 序列的基本操作</title>
    <link href="http://www.alonemonkey.com/2017/03/24/rxswift-part-three/"/>
    <id>http://www.alonemonkey.com/2017/03/24/rxswift-part-three/</id>
    <published>2017-03-23T16:00:00.000Z</published>
    <updated>2017-04-10T14:00:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h3><p>合并多个序列或者值成单个序列。</p>
<h4 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a>startWith</h4><p>在序列触发值之前插入一个多个元素的特殊序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(&quot;🐶&quot;, &quot;🐱&quot;, &quot;🐭&quot;, &quot;🐹&quot;)</div><div class="line">    .startWith(&quot;1️⃣&quot;)</div><div class="line">    .startWith(&quot;2️⃣&quot;)</div><div class="line">    .startWith(&quot;3️⃣&quot;, &quot;🅰️&quot;, &quot;🅱️&quot;)</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">3️⃣</div><div class="line">🅰️</div><div class="line">🅱️</div><div class="line">2️⃣</div><div class="line">1️⃣</div><div class="line">🐶</div><div class="line">🐱</div><div class="line">🐭</div><div class="line">🐹</div></pre></td></tr></table></figure>
<p>最后插入的元素数组在最前面，如下图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490280474432.png" alt="image"></p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>把多个序列合并成单个序列，并按照事件触发的先后顺序，依次发射值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">let subject1 = PublishSubject&lt;String&gt;()</div><div class="line">let subject2 = PublishSubject&lt;String&gt;()</div><div class="line"></div><div class="line">Observable.of(subject1, subject2)</div><div class="line">    .merge()</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">subject1.onNext(&quot;🅰️&quot;)</div><div class="line"></div><div class="line">subject1.onNext(&quot;🅱️&quot;)</div><div class="line"></div><div class="line">subject2.onNext(&quot;①&quot;)</div><div class="line"></div><div class="line">subject2.onNext(&quot;②&quot;)</div><div class="line"></div><div class="line">subject1.onNext(&quot;🆎&quot;)</div><div class="line"></div><div class="line">subject2.onNext(&quot;③&quot;)</div><div class="line"></div><div class="line">output:</div><div class="line">🅰️</div><div class="line">🅱️</div><div class="line">①</div><div class="line">②</div><div class="line">🆎</div><div class="line">③</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490280841107.png" alt="image"></p>
<p>当其中某个序列发生了错误就会立即把错误发送到合并的序列并终止。</p>
<h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>把多个序列组合成到一起并触发一个值，但只有每一个序列都发射了一个值之后才会组合成一个新的值并发出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">let stringSubject = PublishSubject&lt;String&gt;()</div><div class="line">let intSubject = PublishSubject&lt;Int&gt;()</div><div class="line"></div><div class="line">Observable.zip(stringSubject, intSubject) &#123; stringElement, intElement in</div><div class="line">    &quot;\(stringElement) \(intElement)&quot;</div><div class="line">    &#125;</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">stringSubject.onNext(&quot;🅰️&quot;)</div><div class="line">stringSubject.onNext(&quot;🅱️&quot;)</div><div class="line"></div><div class="line">intSubject.onNext(1)</div><div class="line"></div><div class="line">intSubject.onNext(2)</div><div class="line"></div><div class="line">stringSubject.onNext(&quot;🆎&quot;)</div><div class="line">intSubject.onNext(3)</div><div class="line"></div><div class="line">output:</div><div class="line">🅰️ 1</div><div class="line">🅱️ 2</div><div class="line">🆎 3</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490281755102.png" alt="image"></p>
<h4 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h4><p>获取两个序列的最新值，并通过某个函数对其进行处理，处理完之后返回一个新的发射值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">let stringSubject = PublishSubject&lt;String&gt;()</div><div class="line">let intSubject = PublishSubject&lt;Int&gt;()</div><div class="line"></div><div class="line">Observable.combineLatest(stringSubject, intSubject) &#123; stringElement, intElement in</div><div class="line">        &quot;\(stringElement) \(intElement)&quot;</div><div class="line">    &#125;</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">stringSubject.onNext(&quot;🅰️&quot;)</div><div class="line"></div><div class="line">stringSubject.onNext(&quot;🅱️&quot;)</div><div class="line">intSubject.onNext(1)</div><div class="line"></div><div class="line">intSubject.onNext(2)</div><div class="line"></div><div class="line">stringSubject.onNext(&quot;🆎&quot;)</div><div class="line"></div><div class="line">output:</div><div class="line">🅱️ 1</div><div class="line">🅱️ 2</div><div class="line">🆎 2</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490282021214.png" alt="image"></p>
<p><code>combineLatest</code>还有一个变体可以接受一个数组，或者任何其他可被观察序列的集合。但是要求这些可被观察序列元素是同一类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">let stringObservable = Observable.just(&quot;❤️&quot;)</div><div class="line">let fruitObservable = Observable.from([&quot;🍎&quot;, &quot;🍐&quot;, &quot;🍊&quot;])</div><div class="line">let animalObservable = Observable.of(&quot;🐶&quot;, &quot;🐱&quot;, &quot;🐭&quot;, &quot;🐹&quot;)</div><div class="line"></div><div class="line">Observable.combineLatest([stringObservable, fruitObservable, animalObservable]) &#123;</div><div class="line">        &quot;\($0[0]) \($0[1]) \($0[2])&quot;</div><div class="line">    &#125;</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">❤️ 🍎 🐶</div><div class="line">❤️ 🍐 🐶</div><div class="line">❤️ 🍐 🐱</div><div class="line">❤️ 🍊 🐱</div><div class="line">❤️ 🍊 🐭</div><div class="line">❤️ 🍊 🐹</div></pre></td></tr></table></figure>
<h4 id="switchLatest"><a href="#switchLatest" class="headerlink" title="switchLatest"></a>switchLatest</h4><p>这个也是用来合并序列的，不过不同的是，每当一个新的序列发射时，原来序列将被丢弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">let subject1 = BehaviorSubject(value: &quot;⚽️&quot;)</div><div class="line">let subject2 = BehaviorSubject(value: &quot;🍎&quot;)</div><div class="line"></div><div class="line">let variable = Variable(subject1)</div><div class="line">    </div><div class="line">variable.asObservable()</div><div class="line">    .switchLatest()</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">subject1.onNext(&quot;🏈&quot;)</div><div class="line">subject1.onNext(&quot;🏀&quot;)</div><div class="line"></div><div class="line">variable.value = subject2   //这是发射了一个新的序列，而不是直接覆盖原来的序列</div><div class="line"></div><div class="line">subject1.onNext(&quot;⚾️&quot;)  //这里发射的值被忽略了</div><div class="line"></div><div class="line">subject2.onNext(&quot;🍐&quot;)</div><div class="line"></div><div class="line">output:</div><div class="line">⚽️</div><div class="line">🏈</div><div class="line">🏀</div><div class="line">🍎</div><div class="line">🍐</div></pre></td></tr></table></figure>
<p>大家想想把这里的<code>switchLatest</code>改成<code>merge</code>会输出什么？</p>
<p>图例:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490282812918.png" alt="image"></p>
<h4 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h4><p>当收到目标事件，就会从源序列取一个最新的事件，发送到序列，如果两次目标事件之间没有源序列的事件，则不发射值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let source = PublishSubject&lt;Int&gt;()</div><div class="line">let target = PublishSubject&lt;String&gt;()</div><div class="line"></div><div class="line">let subscription = source</div><div class="line">    .sample(target)</div><div class="line">    .subscribe &#123; event in</div><div class="line">        print(event)</div><div class="line">&#125;</div><div class="line">source.onNext(1)</div><div class="line">target.onNext(&quot;A&quot;)  //获取最新的source</div><div class="line">source.onNext(2)</div><div class="line">source.onNext(3)</div><div class="line">target.onNext(&quot;B&quot;)  //获取最新的source</div><div class="line">target.onNext(&quot;C&quot;)  //没有最新的source，不发射</div><div class="line"></div><div class="line">output:</div><div class="line">next(1)</div><div class="line">next(3)</div></pre></td></tr></table></figure>
<h3 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h3><p>对当前序列的值进行转换发射一个新的序列。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>和<code>Swift</code>里面的<code>map</code>类似，转换其中的每一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">Observable.of(1, 2, 3)</div><div class="line">    .map &#123; $0 * $0 &#125;</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">1</div><div class="line">4</div><div class="line">9</div></pre></td></tr></table></figure>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490283400716.png" alt="image"></p>
<h4 id="faltMap"><a href="#faltMap" class="headerlink" title="faltMap"></a>faltMap</h4><p>把当前序列的元素转换成一个新的序列，并把他们合并成一个序列，这个在我们的一个可被观察者序列本身又会触发一个序列的时候非常有用，比如发送一个新的网络请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">struct Player &#123;</div><div class="line">    var score: Variable&lt;Int&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let 👦🏻 = Player(score: Variable(80))</div><div class="line">let 👧🏼 = Player(score: Variable(90))</div><div class="line"></div><div class="line">let player = Variable(👦🏻)</div><div class="line"></div><div class="line">player.asObservable()</div><div class="line">    .flatMap &#123; $0.score.asObservable() &#125; // Change flatMap to flatMapLatest and observe change in printed output</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">👦🏻.score.value = 85</div><div class="line"></div><div class="line">player.value = 👧🏼</div><div class="line"></div><div class="line">👦🏻.score.value = 95 // Will be printed when using flatMap, but will not be printed when using flatMapLatest</div><div class="line"></div><div class="line">👧🏼.score.value = 100</div><div class="line"></div><div class="line">output:</div><div class="line">80</div><div class="line">85</div><div class="line">90</div><div class="line">95</div><div class="line">100</div></pre></td></tr></table></figure>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490284838774.png" alt="image"></p>
<h4 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h4><p>和<code>faltMap</code>不同的是，<code>flatMapLatest</code>在收到一个新的序列的时候，会丢弃原有的序列。那么我们把上面的代码里面的<code>flatMap</code>改成<code>flatMapLatest</code>会输出什么呢？</p>
<p><code>flatMapLatest</code>相当于<code>map</code>和<code>switchLatest</code>操作的组合。</p>
<h4 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h4><p>和<code>Swift</code>里面的<code>reduce</code>类似，给予一个初始值，依次对每个元素进行操作，最后返回操作的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(10, 100, 1000)</div><div class="line">    .scan(1) &#123; aggregateValue, newValue in</div><div class="line">        aggregateValue + newValue</div><div class="line">    &#125;</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">11</div><div class="line">111</div><div class="line">1111</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490353478542.png" alt="image"></p>
<h3 id="过滤和条件操作"><a href="#过滤和条件操作" class="headerlink" title="过滤和条件操作"></a>过滤和条件操作</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>和<code>Swift</code>里面的<code>filter</code>类似，用来过滤序列中指定条件的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(</div><div class="line">    &quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;,</div><div class="line">    &quot;🐸&quot;, &quot;🐱&quot;, &quot;🐰&quot;,</div><div class="line">    &quot;🐹&quot;, &quot;🐸&quot;, &quot;🐱&quot;)</div><div class="line">    .filter &#123;</div><div class="line">        $0 == &quot;🐱&quot;</div><div class="line">    &#125;</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🐱</div><div class="line">🐱</div><div class="line">🐱</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490353408255.png" alt="image"></p>
<h4 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h4><p>过滤掉连续发射的重复元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐷&quot;, &quot;🐱&quot;, &quot;🐱&quot;, &quot;🐱&quot;, &quot;🐵&quot;, &quot;🐱&quot;)</div><div class="line">    .distinctUntilChanged()</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🐱</div><div class="line">🐷</div><div class="line">🐱</div><div class="line">🐵</div><div class="line">🐱</div></pre></td></tr></table></figure>
<h4 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a>elementAt</h4><p>只发送指定位置的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;)</div><div class="line">    .elementAt(3)</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🐸</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490353954160.png" alt="image"></p>
<h4 id="single"><a href="#single" class="headerlink" title="single"></a>single</h4><p>发送单个元素，或者满足条件的第一个元素，如果有多个元素或者没有元素都会抛出错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;)</div><div class="line">        .single()</div><div class="line">        .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🐱</div><div class="line">Received unhandled error: /var/folders/h3/8n169g610_g69k50z7g_q4gc0000gp/T/./lldb/77046/playground61.swift:69:__lldb_expr_61 -&gt; Sequence contains more than one element.</div></pre></td></tr></table></figure>
<p>如果这里只有一个元素，则不会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;)</div><div class="line">        .single &#123; $0 == &quot;🐸&quot; &#125;</div><div class="line">        .subscribe &#123; print($0) &#125;</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">    </div><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;)</div><div class="line">    .single &#123; $0 == &quot;🐰&quot; &#125;</div><div class="line">    .subscribe &#123; print($0) &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;)</div><div class="line">    .single &#123; $0 == &quot;🔵&quot; &#125;</div><div class="line">    .subscribe &#123; print($0) &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">next(🐸)</div><div class="line">completed</div><div class="line">next(🐰)</div><div class="line">error(Sequence contains more than one element.)</div><div class="line">error(Sequence doesn&apos;t contain any elements.)</div></pre></td></tr></table></figure>
<h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><p>获取序列前多少个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;)</div><div class="line">    .take(3)</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">🐱</div><div class="line">🐰</div><div class="line">🐶</div></pre></td></tr></table></figure>
<h4 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h4><p>获取序列后多少个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;)</div><div class="line">    .takeLast(3)</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🐸</div><div class="line">🐷</div><div class="line">🐵</div></pre></td></tr></table></figure>
<h4 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h4><p>发射值值到条件变成false，变成false后，后面满足条件的值也不会发射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(1, 2, 3, 4, 5, 6)</div><div class="line">    .takeWhile &#123; $0 &lt; 4 &#125;</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure>
<p>如果在<code>4</code>后面加了个<code>1</code>会输出什么？</p>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490355879765.png" alt="image"></p>
<h4 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h4><p>发射原序列，直到新的序列发射了一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">let sourceSequence = PublishSubject&lt;String&gt;()</div><div class="line">let referenceSequence = PublishSubject&lt;String&gt;()</div><div class="line"></div><div class="line">sourceSequence</div><div class="line">    .takeUntil(referenceSequence)</div><div class="line">    .subscribe &#123; print($0) &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">sourceSequence.onNext(&quot;🐱&quot;)</div><div class="line">sourceSequence.onNext(&quot;🐰&quot;)</div><div class="line">sourceSequence.onNext(&quot;🐶&quot;)</div><div class="line"></div><div class="line">referenceSequence.onNext(&quot;🔴&quot;)</div><div class="line"></div><div class="line">sourceSequence.onNext(&quot;🐸&quot;)</div><div class="line">sourceSequence.onNext(&quot;🐷&quot;)</div><div class="line">sourceSequence.onNext(&quot;🐵&quot;)</div><div class="line"></div><div class="line">output:</div><div class="line">next(🐱)</div><div class="line">next(🐰)</div><div class="line">next(🐶)</div><div class="line">completed</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490356113971.png" alt="image"></p>
<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>跳过开头指定个数的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;)</div><div class="line">    .skip(2)</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🐶</div><div class="line">🐸</div><div class="line">🐷</div><div class="line">🐵</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490356216761.png" alt="image"></p>
<h4 id="skipWhile"><a href="#skipWhile" class="headerlink" title="skipWhile"></a>skipWhile</h4><p>跳过满足条件的值到条件变成false，变成false后，后面满足条件的值也不会跳过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(1, 2, 3, 4, 5, 6)</div><div class="line">    .skipWhile &#123; $0 &lt; 4 &#125;</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td></tr></table></figure>
<p>如果在<code>4</code>后面加了个<code>1</code>会输出什么？</p>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490356383977.png" alt="image"></p>
<h4 id="skipWhileWithIndex"><a href="#skipWhileWithIndex" class="headerlink" title="skipWhileWithIndex"></a>skipWhileWithIndex</h4><p>和<code>skipWhile</code>类似，只不过带上了<code>index</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(&quot;🐱&quot;, &quot;🐰&quot;, &quot;🐶&quot;, &quot;🐸&quot;, &quot;🐷&quot;, &quot;🐵&quot;)</div><div class="line">    .skipWhileWithIndex &#123; element, index in</div><div class="line">        index &lt; 3</div><div class="line">    &#125;</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🐸</div><div class="line">🐷</div><div class="line">🐵</div></pre></td></tr></table></figure>
<h4 id="skipUntil"><a href="#skipUntil" class="headerlink" title="skipUntil"></a>skipUntil</h4><p>和<code>takeUntil</code>相反，跳过原序列，直到新序列发射了一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">let sourceSequence = PublishSubject&lt;String&gt;()</div><div class="line">let referenceSequence = PublishSubject&lt;String&gt;()</div><div class="line"></div><div class="line">sourceSequence</div><div class="line">    .skipUntil(referenceSequence)</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">sourceSequence.onNext(&quot;🐱&quot;)</div><div class="line">sourceSequence.onNext(&quot;🐰&quot;)</div><div class="line">sourceSequence.onNext(&quot;🐶&quot;)</div><div class="line"></div><div class="line">referenceSequence.onNext(&quot;🔴&quot;)</div><div class="line"></div><div class="line">sourceSequence.onNext(&quot;🐸&quot;)</div><div class="line">sourceSequence.onNext(&quot;🐷&quot;)</div><div class="line">sourceSequence.onNext(&quot;🐵&quot;)</div><div class="line"></div><div class="line">output:</div><div class="line">🐸</div><div class="line">🐷</div><div class="line">🐵</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490356783253.png" alt="image"></p>
<h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><h4 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h4><p>把一个序列转成一个数组，然后作为新的一个值发射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.range(start: 1, count: 10)</div><div class="line">    .toArray()</div><div class="line">    .subscribe &#123; print($0) &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">next([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</div><div class="line">completed</div></pre></td></tr></table></figure>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>给一个初始值，然后和序列里的每个值进行运行，最后返回一个结果，然后把结果作为单个值发射出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">Observable.of(10, 100, 1000)</div><div class="line">    .reduce(1, accumulator: +)</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">1111</div></pre></td></tr></table></figure>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>串联多个序列，下一个序列必须等前一个序列完成才会发射出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">let subject1 = BehaviorSubject(value: &quot;🍎&quot;)</div><div class="line">let subject2 = BehaviorSubject(value: &quot;🐶&quot;)</div><div class="line"></div><div class="line">let variable = Variable(subject1)</div><div class="line"></div><div class="line">variable.asObservable()</div><div class="line">    .concat()</div><div class="line">    .subscribe &#123; print($0) &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">subject1.onNext(&quot;🍐&quot;)</div><div class="line">subject1.onNext(&quot;🍊&quot;)</div><div class="line"></div><div class="line">variable.value = subject2</div><div class="line"></div><div class="line">subject2.onNext(&quot;I would be ignored&quot;)</div><div class="line">subject2.onNext(&quot;🐱&quot;)</div><div class="line"></div><div class="line">subject1.onCompleted()</div><div class="line"></div><div class="line">subject2.onNext(&quot;🐭&quot;)</div><div class="line"></div><div class="line">output:</div><div class="line">next(🍎)</div><div class="line">next(🍐)</div><div class="line">next(🍊)</div><div class="line">next(🐱)</div><div class="line">next(🐭)</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490358501823.png" alt="image"></p>
<p>大家想一想下面会输出什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">let subject1 = PublishSubject&lt;String&gt;()</div><div class="line">let subject2 = PublishSubject&lt;String&gt;()</div><div class="line"></div><div class="line">let variable = Variable(subject1)</div><div class="line"></div><div class="line">variable.asObservable()</div><div class="line">    .concat()</div><div class="line">    .subscribe &#123; print($0) &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">subject1.onNext(&quot;🍐&quot;)</div><div class="line">subject1.onNext(&quot;🍊&quot;)</div><div class="line"></div><div class="line">variable.value = subject2</div><div class="line"></div><div class="line">subject2.onNext(&quot;I would be ignored&quot;)</div><div class="line">subject2.onNext(&quot;🐱&quot;)</div><div class="line"></div><div class="line">subject1.onCompleted()</div><div class="line"></div><div class="line">subject2.onNext(&quot;🐭&quot;)</div></pre></td></tr></table></figure>
<h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><p>可连接的序列和一般序列没有不同，除了只有当调用<code>connect()</code>之后才会开始发射值，通过这种方式，你可以等所有的订阅者订阅后才发射值。</p>
<p>先来看一个没有连接操作的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let interval = Observable&lt;Int&gt;.interval(2, scheduler: MainScheduler.instance)</div><div class="line">    </div><div class="line">_ = interval</div><div class="line">    .subscribe(onNext: &#123; print(&quot;Subscription: 1, Event: \($0)&quot;) &#125;)</div><div class="line"></div><div class="line">delay(5) &#123;</div><div class="line">    _ = interval</div><div class="line">        .subscribe(onNext: &#123; print(&quot;Subscription: 2, Event: \($0)&quot;) &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一行代码是在指定的线程每隔一定的时间发射一个信号。</p>
<p>那么这里我们可以看到在第一个订阅者订阅后，每隔2秒会收到一个值，而后面一个订阅5秒后才收到第一个值0，所以两个订阅者接收到的值是不同步的。</p>
<p>看输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Subscription: 1, Event: 0</div><div class="line">Subscription: 1, Event: 1</div><div class="line">Subscription: 1, Event: 2</div><div class="line">Subscription: 2, Event: 0   //这里是从0开始的</div><div class="line">Subscription: 1, Event: 3</div><div class="line">Subscription: 2, Event: 1</div><div class="line">Subscription: 1, Event: 4</div><div class="line">Subscription: 2, Event: 2</div><div class="line">.......</div></pre></td></tr></table></figure>
<h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><p>把一个序列转成一个可连接的序列。</p>
<p>首先来看一个没有连接的序列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let intSequence = Observable&lt;Int&gt;.interval(2, scheduler: MainScheduler.instance)</div><div class="line">    </div><div class="line">_ = intSequence</div><div class="line">    .subscribe(onNext: &#123; print(&quot;Subscription 1:, Event: \($0)&quot;) &#125;)</div><div class="line"></div><div class="line">delay(4) &#123;</div><div class="line">    _ = intSequence</div><div class="line">        .subscribe(onNext: &#123; print(&quot;Subscription 2:, Event: \($0)&quot;) &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">delay(5) &#123;</div><div class="line">    _ = intSequence</div><div class="line">        .subscribe(onNext: &#123; print(&quot;Subscription 3:, Event: \($0)&quot;) &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Subscription 1:, Event: 0     //第一个订阅者开始订阅</div><div class="line">Subscription 1:, Event: 1     </div><div class="line">Subscription 1:, Event: 2</div><div class="line">Subscription 2:, Event: 0     //第二个订阅者开始订阅，不过发射的是一个新的序列</div><div class="line">Subscription 3:, Event: 0     //第三个订阅者开始订阅，不过发射的是一个新的序列</div><div class="line">Subscription 1:, Event: 3</div><div class="line">Subscription 2:, Event: 1</div><div class="line">Subscription 3:, Event: 1</div><div class="line">Subscription 1:, Event: 4</div></pre></td></tr></table></figure>
<p>把第一行代码变成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let intSequence = Observable&lt;Int&gt;.interval(2, scheduler: MainScheduler.instance)</div><div class="line">        .publish()</div></pre></td></tr></table></figure>
<p>加了个<code>publish</code>后变成可连接序列了，但是并不会输出值，只有在调用<code>connect</code>之后才会开始发射值。而且与前面不同的是，前面的<code>Observable</code>被多次<code>subscribe</code>就会被多次触发。<code>publish + connect</code>的组合每次<code>subscribe</code>不会导致<code>Observable</code>重新针对<code>observer</code>处理一遍。</p>
<p>所以如果上面的代码写成这样会输出什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">let intSequence = Observable&lt;Int&gt;.interval(2, scheduler: MainScheduler.instance)</div><div class="line">        .publish()</div><div class="line">    </div><div class="line">print(&quot;1 订阅&quot;)</div><div class="line"></div><div class="line">_ = intSequence</div><div class="line">    .subscribe(onNext: &#123; print(&quot;Subscription 1:, Event: \($0)&quot;) &#125;)</div><div class="line"></div><div class="line">delay(1) &#123; _ = intSequence.connect() &#125;     //connect后，序列开始发射</div><div class="line"></div><div class="line">delay(4) &#123;</div><div class="line">    print(&quot;4 订阅&quot;)</div><div class="line">    _ = intSequence</div><div class="line">        .subscribe(onNext: &#123; print(&quot;Subscription 2:, Event: \($0)&quot;) &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">delay(5) &#123;</div><div class="line">    print(&quot;5 订阅&quot;)</div><div class="line">    _ = intSequence</div><div class="line">        .subscribe(onNext: &#123; print(&quot;Subscription 3:, Event: \($0)&quot;) &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">1 订阅</div><div class="line">Subscription 1:, Event: 0      //1订阅，收到值</div><div class="line">4 订阅</div><div class="line">5 订阅</div><div class="line">Subscription 1:, Event: 1      //4，5 订阅，收到的是原序列继续发射的值，而不是新的序列</div><div class="line">Subscription 2:, Event: 1</div><div class="line">Subscription 3:, Event: 1</div><div class="line">Subscription 1:, Event: 2</div><div class="line">Subscription 2:, Event: 2</div><div class="line">Subscription 3:, Event: 2</div><div class="line">Subscription 1:, Event: 3</div><div class="line">Subscription 2:, Event: 3</div><div class="line">Subscription 3:, Event: 3</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490415406410.png" alt="image"></p>
<h4 id="replay"><a href="#replay" class="headerlink" title="replay"></a>replay</h4><p>把源序列转换可连接的序列，并会给新的订阅者发送之前<code>bufferSize</code>个的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</div><div class="line">        .replay(5)</div><div class="line">print(&quot;1 订阅&quot;)</div><div class="line">_ = intSequence</div><div class="line">    .subscribe(onNext: &#123; print(&quot;Subscription 1:, Event: \($0)&quot;) &#125;)</div><div class="line"></div><div class="line">delay(1) &#123; _ = intSequence.connect() &#125;</div><div class="line"></div><div class="line">delay(4) &#123;</div><div class="line">    print(&quot;4 订阅&quot;)</div><div class="line">    _ = intSequence</div><div class="line">        .subscribe(onNext: &#123; print(&quot;Subscription 2:, Event: \($0)&quot;) &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">delay(5) &#123;</div><div class="line">    print(&quot;5 订阅&quot;)</div><div class="line">    _ = intSequence</div><div class="line">        .subscribe(onNext: &#123; print(&quot;Subscription 3:, Event: \($0)&quot;) &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">1 订阅</div><div class="line">Subscription 1:, Event: 0</div><div class="line">Subscription 1:, Event: 1</div><div class="line">4 订阅</div><div class="line">Subscription 2:, Event: 0</div><div class="line">Subscription 2:, Event: 1     //之前发射的值</div><div class="line">Subscription 1:, Event: 2</div><div class="line">Subscription 2:, Event: 2</div><div class="line">5 订阅</div><div class="line">Subscription 3:, Event: 0</div><div class="line">Subscription 3:, Event: 1</div><div class="line">Subscription 3:, Event: 2     //之前发射的值</div><div class="line">Subscription 1:, Event: 3</div><div class="line">Subscription 2:, Event: 3</div><div class="line">Subscription 3:, Event: 3</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490415512247.png" alt="image"></p>
<h4 id="multicast"><a href="#multicast" class="headerlink" title="multicast"></a>multicast</h4><p>传入一个<code>Subject</code>，每当序列发射都会触发这个<code>Subject</code>的发射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">let subject = PublishSubject&lt;Int&gt;()</div><div class="line">    </div><div class="line">_ = subject</div><div class="line">    .subscribe(onNext: &#123; print(&quot;Subject: \($0)&quot;) &#125;)</div><div class="line"></div><div class="line">let intSequence = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</div><div class="line">    .multicast(subject)</div><div class="line"></div><div class="line">_ = intSequence</div><div class="line">    .subscribe(onNext: &#123; print(&quot;\tSubscription 1:, Event: \($0)&quot;) &#125;)</div><div class="line"></div><div class="line">delay(2) &#123; _ = intSequence.connect() &#125;</div><div class="line"></div><div class="line">delay(4) &#123;</div><div class="line">    _ = intSequence</div><div class="line">        .subscribe(onNext: &#123; print(&quot;\tSubscription 2:, Event: \($0)&quot;) &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">delay(6) &#123;</div><div class="line">    _ = intSequence</div><div class="line">        .subscribe(onNext: &#123; print(&quot;\tSubscription 3:, Event: \($0)&quot;) &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">Subject: 0</div><div class="line">	Subscription 1:, Event: 0</div><div class="line">Subject: 1</div><div class="line">	Subscription 1:, Event: 1</div><div class="line">	Subscription 2:, Event: 1</div><div class="line">Subject: 2</div><div class="line">	Subscription 1:, Event: 2</div><div class="line">	Subscription 2:, Event: 2</div><div class="line">Subject: 3</div><div class="line">	Subscription 1:, Event: 3</div><div class="line">	Subscription 2:, Event: 3</div><div class="line">	Subscription 3:, Event: 3</div></pre></td></tr></table></figure>
<h3 id="错误操作"><a href="#错误操作" class="headerlink" title="错误操作"></a>错误操作</h3><h4 id="catchErrorJustReturn"><a href="#catchErrorJustReturn" class="headerlink" title="catchErrorJustReturn"></a>catchErrorJustReturn</h4><p>捕获到错误的时候，返回指定的值，然后终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">let sequenceThatFails = PublishSubject&lt;String&gt;()</div><div class="line"></div><div class="line">sequenceThatFails</div><div class="line">    .catchErrorJustReturn(&quot;😊&quot;)</div><div class="line">    .subscribe &#123; print($0) &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">sequenceThatFails.onNext(&quot;😬&quot;)</div><div class="line">sequenceThatFails.onNext(&quot;😨&quot;)</div><div class="line">sequenceThatFails.onNext(&quot;😡&quot;)</div><div class="line">sequenceThatFails.onNext(&quot;🔴&quot;)</div><div class="line">sequenceThatFails.onError(TestError.test)</div><div class="line"></div><div class="line">output:</div><div class="line">next(😬)</div><div class="line">next(😨)</div><div class="line">next(😡)</div><div class="line">next(🔴)</div><div class="line">next(😊)</div><div class="line">completed</div></pre></td></tr></table></figure>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490416164390.png" alt="image"></p>
<h4 id="catchError"><a href="#catchError" class="headerlink" title="catchError"></a>catchError</h4><p>捕获一个错误值，然后切换到新的序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()  </div><div class="line">let sequenceThatFails = PublishSubject&lt;String&gt;()</div><div class="line">let recoverySequence = PublishSubject&lt;String&gt;()</div><div class="line"></div><div class="line">sequenceThatFails</div><div class="line">    .catchError &#123;</div><div class="line">        print(&quot;Error:&quot;, $0)</div><div class="line">        return recoverySequence</div><div class="line">    &#125;</div><div class="line">    .subscribe &#123; print($0) &#125;</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">sequenceThatFails.onNext(&quot;😬&quot;)</div><div class="line">sequenceThatFails.onNext(&quot;😨&quot;)</div><div class="line">sequenceThatFails.onNext(&quot;😡&quot;)</div><div class="line">sequenceThatFails.onNext(&quot;🔴&quot;)</div><div class="line">sequenceThatFails.onError(TestError.test)</div><div class="line"></div><div class="line">recoverySequence.onNext(&quot;😊&quot;)</div><div class="line"></div><div class="line">output:</div><div class="line">next(😬)</div><div class="line">next(😨)</div><div class="line">next(😡)</div><div class="line">next(🔴)</div><div class="line">Error: test</div><div class="line">next(😊)</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490416336799.png" alt="image"></p>
<h4 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h4><p>捕获到错误的时候，重新订阅该序列。<code>retry(_:)</code> 表示最多重试多少次。 <code>retry(3)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    var count = 1</div><div class="line">    </div><div class="line">    let sequenceThatErrors = Observable&lt;String&gt;.create &#123; observer in</div><div class="line">        observer.onNext(&quot;🍎&quot;)</div><div class="line">        observer.onNext(&quot;🍐&quot;)</div><div class="line">        observer.onNext(&quot;🍊&quot;)</div><div class="line">        </div><div class="line">        if count == 1 &#123;</div><div class="line">            observer.onError(TestError.test)</div><div class="line">            print(&quot;Error encountered&quot;)</div><div class="line">            count += 1</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        observer.onNext(&quot;🐶&quot;)</div><div class="line">        observer.onNext(&quot;🐱&quot;)</div><div class="line">        observer.onNext(&quot;🐭&quot;)</div><div class="line">        observer.onCompleted()</div><div class="line">        </div><div class="line">        return Disposables.create()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    sequenceThatErrors</div><div class="line">        .retry()</div><div class="line">        .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🍎</div><div class="line">🍐</div><div class="line">🍊</div><div class="line">Error encountered</div><div class="line">🍎</div><div class="line">🍐</div><div class="line">🍊</div><div class="line">🐶</div><div class="line">🐱</div><div class="line">🐭</div></pre></td></tr></table></figure>
<p>如图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490416618803.png" alt="image"></p>
<h3 id="调试操作"><a href="#调试操作" class="headerlink" title="调试操作"></a>调试操作</h3><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>打印所有的订阅者、事件、和处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">var count = 1</div><div class="line"></div><div class="line">let sequenceThatErrors = Observable&lt;String&gt;.create &#123; observer in</div><div class="line">    observer.onNext(&quot;🍎&quot;)</div><div class="line">    observer.onNext(&quot;🍐&quot;)</div><div class="line">    observer.onNext(&quot;🍊&quot;)</div><div class="line">    </div><div class="line">    if count &lt; 5 &#123;</div><div class="line">        observer.onError(TestError.test)</div><div class="line">        print(&quot;Error encountered&quot;)</div><div class="line">        count += 1</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    observer.onNext(&quot;🐶&quot;)</div><div class="line">    observer.onNext(&quot;🐱&quot;)</div><div class="line">    observer.onNext(&quot;🐭&quot;)</div><div class="line">    observer.onCompleted()</div><div class="line">    </div><div class="line">    return Disposables.create()</div><div class="line">&#125;</div><div class="line"></div><div class="line">sequenceThatErrors</div><div class="line">    .retry(3)</div><div class="line">    .debug()</div><div class="line">    .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">2017-03-25 12:38:47.241: playground157.swift:42 (__lldb_expr_157) -&gt; subscribed</div><div class="line">2017-03-25 12:38:47.246: playground157.swift:42 (__lldb_expr_157) -&gt; Event next(🍎)</div><div class="line">🍎</div><div class="line">2017-03-25 12:38:47.247: playground157.swift:42 (__lldb_expr_157) -&gt; Event next(🍐)</div><div class="line">🍐</div><div class="line">2017-03-25 12:38:47.248: playground157.swift:42 (__lldb_expr_157) -&gt; Event next(🍊)</div><div class="line">🍊</div><div class="line">Error encountered</div><div class="line">2017-03-25 12:38:47.250: playground157.swift:42 (__lldb_expr_157) -&gt; Event next(🍎)</div><div class="line">🍎</div><div class="line">2017-03-25 12:38:47.250: playground157.swift:42 (__lldb_expr_157) -&gt; Event next(🍐)</div><div class="line">🍐</div><div class="line">2017-03-25 12:38:47.251: playground157.swift:42 (__lldb_expr_157) -&gt; Event next(🍊)</div><div class="line">🍊</div><div class="line">Error encountered</div><div class="line">2017-03-25 12:38:47.252: playground157.swift:42 (__lldb_expr_157) -&gt; Event next(🍎)</div><div class="line">🍎</div><div class="line">2017-03-25 12:38:47.253: playground157.swift:42 (__lldb_expr_157) -&gt; Event next(🍐)</div><div class="line">🍐</div><div class="line">2017-03-25 12:38:47.253: playground157.swift:42 (__lldb_expr_157) -&gt; Event next(🍊)</div><div class="line">🍊</div><div class="line">Error encountered</div><div class="line">2017-03-25 12:38:47.255: playground157.swift:42 (__lldb_expr_157) -&gt; Event error(test)</div><div class="line">Received unhandled error: /var/folders/h3/8n169g610_g69k50z7g_q4gc0000gp/T/./lldb/26516/playground157.swift:43:__lldb_expr_157 -&gt; test</div><div class="line">2017-03-25 12:38:47.283: playground157.swift:42 (__lldb_expr_157) -&gt; isDisposed</div></pre></td></tr></table></figure>
<h4 id="RxSwift-Resources-total"><a href="#RxSwift-Resources-total" class="headerlink" title="RxSwift.Resources.total"></a>RxSwift.Resources.total</h4><p>提供所有<code>Rx</code>申请资源的数量，在检查内存泄露的时候非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">print(RxSwift.Resources.total)</div><div class="line">    </div><div class="line">let disposeBag = DisposeBag()</div><div class="line"></div><div class="line">print(RxSwift.Resources.total)</div><div class="line"></div><div class="line">let variable = Variable(&quot;🍎&quot;)</div><div class="line"></div><div class="line">let subscription1 = variable.asObservable().subscribe(onNext: &#123; print($0) &#125;)</div><div class="line"></div><div class="line">print(RxSwift.Resources.total)</div><div class="line"></div><div class="line">let subscription2 = variable.asObservable().subscribe(onNext: &#123; print($0) &#125;)</div><div class="line"></div><div class="line">print(RxSwift.Resources.total)</div><div class="line"></div><div class="line">subscription1.dispose()</div><div class="line"></div><div class="line">print(RxSwift.Resources.total)</div><div class="line"></div><div class="line">subscription2.dispose()</div><div class="line"></div><div class="line">print(RxSwift.Resources.total)</div><div class="line"></div><div class="line">output:</div><div class="line">0</div><div class="line">2</div><div class="line">🍎</div><div class="line">8</div><div class="line">🍎</div><div class="line">10</div><div class="line">9</div><div class="line">8</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a></p>
<p><a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="external">Document</a></p>
<p><a href="http://rxmarbles.com/" target="_blank" rel="external">RxMarbles</a></p>
]]></content>
    
    <summary type="html">
    
      创建了一个序列后，可以针对这个序列进行组合、变换、过滤等等操作
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 被观察者和订阅者</title>
    <link href="http://www.alonemonkey.com/2017/03/23/rxswift-part-two/"/>
    <id>http://www.alonemonkey.com/2017/03/23/rxswift-part-two/</id>
    <published>2017-03-22T16:00:00.000Z</published>
    <updated>2017-03-23T07:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在开发中经常会遇到和处理的业务场景有: 利用<code>@IBAction</code>或<code>Target-action</code>响应用户的操作事件；设置Notification监听键盘的位置变化；使用closure异步处理网络请求返回的数据；使用KVO监听属性的变化，以做出相应操作等。</p>
<p>上面的场景都对应一个被观察的对象，当这个对象发生某种变化时，我们根据不同的变化事件去处理不同的业务逻辑。这无疑构成一个观察者模式，<code>RxSwift</code>中，被观察者和订阅者是其中两大重要角色。</p>
<h3 id="Observable-被观察者"><a href="#Observable-被观察者" class="headerlink" title="Observable(被观察者)"></a>Observable(被观察者)</h3><p>RxSwift中的Observable 是观察者模式中被观察的对象，相当于一个事件序列 (GeneratorType) ，会主动向订阅者发送新产生的事件信息。事件类型分为以下三种：</p>
<ul>
<li>.onNext(element)    表示新的事件数据。</li>
<li>.onError(error)         表示事件序列因异常而完结。</li>
<li>.onCompleted()       表示事件序列完结。</li>
</ul>
<h3 id="Subscribe-订阅者"><a href="#Subscribe-订阅者" class="headerlink" title="Subscribe(订阅者)"></a>Subscribe(订阅者)</h3><p>如果只有一个<code>Observable</code>被创建，而没有被任何的订阅者所订阅的话，那么什么事情都不会发生。所以我们需要创建一个订阅者，来响应事件的触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">_ = Observable&lt;String&gt;.create &#123; observerOfString in</div><div class="line">        print(&quot;Observable created&quot;)</div><div class="line">        observerOfString.on(.next(&quot;😉&quot;))</div><div class="line">        observerOfString.on(.completed)</div><div class="line">        return Disposables.create()</div><div class="line">    &#125;</div><div class="line">    .subscribe &#123; event in</div><div class="line">        print(event)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>subscribe</code>订阅之后，会受到两个消息，<code>.onNext(element)</code>和<code>.onCompleted()</code>，打印出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">next(😉)</div><div class="line">completed</div></pre></td></tr></table></figure>
<h3 id="创建并订阅"><a href="#创建并订阅" class="headerlink" title="创建并订阅"></a>创建并订阅</h3><p><code>RxSwift</code>本身提供了多种方式来创建和订阅一个被观察者，下面来一一介绍，以下的代码可以<code>git clone https://github.com/ReactiveX/RxSwift.git</code>，然后打开<code>Rx.playground</code>，新建一个<code>page</code>，import<code>RxSwift</code>即可。</p>
<h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>常见的两种方式来创建一个<code>Observable</code>对象，一种是通过引入<code>RxCocoa</code>(RxCocoa是对cocoa进行的Rx扩展)，它已经包含了我们常用到的<code>Observable</code>流，比如<code>button</code>的<code>tap</code>事件。一般做iOS开发的要使用到RxSwift都要用到RxCocoa的，这两个是相辅相成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let observable = loginButton.rx.tap.asObservable()</div></pre></td></tr></table></figure></p>
<p>也可以使用提供的<code>create</code>函数来创建一个<code>Observable</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">let observable = Observable&lt;String&gt;.create &#123; observerOfString -&gt; Disposable in</div><div class="line">        observerOfString.on(.next(&quot;😬&quot;))</div><div class="line">        observerOfString.on(.completed)</div><div class="line">        return Disposables.create()</div><div class="line">&#125;</div><div class="line">observable.subscribe &#123; print($0) &#125;</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">        </div><div class="line">output:</div><div class="line">next(😬)</div><div class="line">completed</div></pre></td></tr></table></figure>
<h4 id="never"><a href="#never" class="headerlink" title="never"></a>never</h4><p>创建一个序列，不会终止也不会发出任何事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">let neverSequence = Observable&lt;String&gt;.never()</div><div class="line"></div><div class="line">let neverSequenceSubscription = neverSequence</div><div class="line">    .subscribe &#123; _ in</div><div class="line">        print(&quot;This will never be printed&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">neverSequenceSubscription.disposed(by: disposeBag)</div></pre></td></tr></table></figure>
<h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4><p>创建一个空的序列，只会发出一个完成事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">    Observable&lt;Int&gt;.empty()</div><div class="line">        .subscribe &#123; event in</div><div class="line">            print(event)</div><div class="line">        &#125;</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">        </div><div class="line">output:    </div><div class="line">completed</div></pre></td></tr></table></figure>
<h4 id="just"><a href="#just" class="headerlink" title="just"></a>just</h4><p>创建一个单个元素的序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">    Observable.just(&quot;🔴&quot;)</div><div class="line">        .subscribe &#123; event in</div><div class="line">            print(event)</div><div class="line">        &#125;</div><div class="line">        .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:    </div><div class="line">next(🔴)</div><div class="line">completed</div></pre></td></tr></table></figure>
<h4 id="of"><a href="#of" class="headerlink" title="of"></a>of</h4><p>使用固定数量的元素创建一个序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">    Observable.of(&quot;🐶&quot;, &quot;🐱&quot;, &quot;🐭&quot;, &quot;🐹&quot;)</div><div class="line">        .subscribe(onNext: &#123; element in</div><div class="line">            print(element)</div><div class="line">        &#125;)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">    </div><div class="line">output:</div><div class="line">🐶</div><div class="line">🐱</div><div class="line">🐭</div><div class="line">🐹</div></pre></td></tr></table></figure>
<p>这里使用了<code>subscribe(onNext:)</code>而不是<code>subscribe(_:)</code>，可以通过前面一种方式来订阅某个事件，所以有如下的写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">someObservable.subscribe(</div><div class="line">    onNext: &#123; print(&quot;Element:&quot;, $0) &#125;,</div><div class="line">    onError: &#123; print(&quot;Error:&quot;, $0) &#125;,</div><div class="line">    onCompleted: &#123; print(&quot;Completed&quot;) &#125;,</div><div class="line">    onDisposed: &#123; print(&quot;Disposed&quot;) &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>可以只订阅其中某个，而不用全部订阅。</p>
<h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><p>从一个序列创建一个可被观察的序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">    Observable.from([&quot;🐶&quot;, &quot;🐱&quot;, &quot;🐭&quot;, &quot;🐹&quot;])</div><div class="line">        .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🐶</div><div class="line">🐱</div><div class="line">🐭</div><div class="line">🐹</div></pre></td></tr></table></figure>
<p>这里使用<code>$0</code>表示默认的第一个参数</p>
<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>创建一个发出一系列顺序整数然后终止的序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">    Observable.range(start: 1, count: 10)</div><div class="line">        .subscribe &#123; print($0) &#125;</div><div class="line">        .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">next(1)</div><div class="line">next(2)</div><div class="line">next(3)</div><div class="line">next(4)</div><div class="line">next(5)</div><div class="line">next(6)</div><div class="line">next(7)</div><div class="line">next(8)</div><div class="line">next(9)</div><div class="line">next(10)</div><div class="line">completed</div></pre></td></tr></table></figure>
<h4 id="repeatElement"><a href="#repeatElement" class="headerlink" title="repeatElement"></a>repeatElement</h4><p>创建一个给予元素的无限序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">    Observable.repeatElement(&quot;🔴&quot;)</div><div class="line">        .take(3)</div><div class="line">        .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line"></div><div class="line">output:</div><div class="line">🔴</div><div class="line">🔴</div><div class="line">🔴</div></pre></td></tr></table></figure>
<p>这里的<code>take(3)</code>表示只取前3个元素。</p>
<h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p>创建一个满足条件的序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">    Observable.generate(</div><div class="line">            initialState: 0,</div><div class="line">            condition: &#123; $0 &lt; 3 &#125;,</div><div class="line">            iterate: &#123; $0 + 1 &#125;</div><div class="line">        )</div><div class="line">        .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">        </div><div class="line">output:</div><div class="line">0</div><div class="line">1</div><div class="line">2</div></pre></td></tr></table></figure>
<h4 id="deferred"><a href="#deferred" class="headerlink" title="deferred"></a>deferred</h4><p>只有当有订阅者订阅的时候才会去创建序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    var count = 1</div><div class="line">    </div><div class="line">    let deferredSequence = Observable&lt;String&gt;.deferred &#123;</div><div class="line">        print(&quot;Creating \(count)&quot;)</div><div class="line">        count += 1</div><div class="line">        </div><div class="line">        return Observable.create &#123; observer in</div><div class="line">            print(&quot;Emitting...&quot;)</div><div class="line">            observer.onNext(&quot;🐶&quot;)</div><div class="line">            observer.onNext(&quot;🐱&quot;)</div><div class="line">            observer.onNext(&quot;🐵&quot;)</div><div class="line">            return Disposables.create()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    deferredSequence</div><div class="line">        .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">    </div><div class="line">    deferredSequence</div><div class="line">        .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">        </div><div class="line">output:</div><div class="line">Creating 1</div><div class="line">Emitting...</div><div class="line">🐶</div><div class="line">🐱</div><div class="line">🐵</div><div class="line">Creating 2</div><div class="line">Emitting...</div><div class="line">🐶</div><div class="line">🐱</div><div class="line">🐵</div></pre></td></tr></table></figure>
<p>如果把后面两个订阅去掉的话，是不会有<code>Creating</code>输出的。</p>
<h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>创建一个没有元素并以错误终止的序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public enum TestError : Error &#123;</div><div class="line">    case test</div><div class="line">&#125;</div><div class="line"></div><div class="line">let disposeBag = DisposeBag()</div><div class="line">    Observable&lt;Int&gt;.error(TestError.test)</div><div class="line">        .subscribe &#123; print($0) &#125;</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">        </div><div class="line">output:</div><div class="line">error(test)</div></pre></td></tr></table></figure>
<h4 id="doOn"><a href="#doOn" class="headerlink" title="doOn"></a>doOn</h4><p>在每个事情发出之后，可以调用其它处理，然后返回原事件，相当于一个拦截器，但是只能拦截不能修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">    </div><div class="line">    Observable.of(&quot;🍎&quot;, &quot;🍐&quot;, &quot;🍊&quot;, &quot;🍋&quot;)</div><div class="line">        .do(onNext: &#123; print(&quot;Intercepted:&quot;, $0) &#125;, onError: &#123; print(&quot;Intercepted error:&quot;, $0) &#125;, onCompleted: &#123; print(&quot;Completed&quot;)  &#125;)</div><div class="line">        .subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">        .disposed(by: disposeBag)</div><div class="line">        </div><div class="line">output:</div><div class="line">Intercepted: 🍎</div><div class="line">🍎</div><div class="line">Intercepted: 🍐</div><div class="line">🍐</div><div class="line">Intercepted: 🍊</div><div class="line">🍊</div><div class="line">Intercepted: 🍋</div><div class="line">🍋</div><div class="line">Completed</div></pre></td></tr></table></figure>
<p>同样可以针对不同的事件类型单独拦截。</p>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p><code>Subject</code>就相当于一个桥梁或者代理，它既可以作为一个<code>observer</code>也可以作为一个<code>Observable</code>。</p>
<p>下面来看几种不同的<code>Subject</code>:</p>
<h4 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h4><p><code>PublishSubject</code>只会发送给订阅者订阅之后的事件，之前发生的事件将不会发送。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">let subject = PublishSubject&lt;String&gt;()</div><div class="line"></div><div class="line">subject.addObserver(&quot;1&quot;).disposed(by: disposeBag)</div><div class="line">subject.onNext(&quot;🐶&quot;)</div><div class="line">subject.onNext(&quot;🐱&quot;)</div><div class="line"></div><div class="line">subject.addObserver(&quot;2&quot;).disposed(by: disposeBag)</div><div class="line">subject.onNext(&quot;🅰️&quot;)</div><div class="line">subject.onNext(&quot;🅱️&quot;)</div><div class="line">    </div><div class="line">output:</div><div class="line">Subscription: 1 Event: next(🐶)</div><div class="line">Subscription: 1 Event: next(🐱)</div><div class="line">Subscription: 1 Event: next(🅰️)</div><div class="line">Subscription: 2 Event: next(🅰️)</div><div class="line">Subscription: 1 Event: next(🅱️)</div><div class="line">Subscription: 2 Event: next(🅱️)</div></pre></td></tr></table></figure>
<p>订阅者2只能收到订阅后传过来的事件，如图:<br><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490251409393.png" alt="image"></p>
<p>如果要保证所有事件都能被订阅到，可以使用<code>Create</code>主动创建或使用<code>ReplaySubject</code>。<br>如果被观察者因为错误被终止，<code>PublishSubject</code>只会发出一个错误的通知。</p>
<h4 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h4><p>不管订阅者什么时候订阅的都<code>可以</code>把所有发生过的事件发送给订阅者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">let subject = ReplaySubject&lt;String&gt;.createUnbounded()</div><div class="line"></div><div class="line">subject.addObserver(&quot;1&quot;).disposed(by: disposeBag)</div><div class="line">subject.onNext(&quot;🐶&quot;)</div><div class="line">subject.onNext(&quot;🐱&quot;)</div><div class="line"></div><div class="line">subject.addObserver(&quot;2&quot;).disposed(by: disposeBag)</div><div class="line">subject.onNext(&quot;🅰️&quot;)</div><div class="line">subject.onNext(&quot;🅱️&quot;)</div><div class="line"></div><div class="line">output:</div><div class="line">Subscription: 1 Event: next(🐶)</div><div class="line">Subscription: 1 Event: next(🐱)</div><div class="line">Subscription: 2 Event: next(🐶)</div><div class="line">Subscription: 2 Event: next(🐱)</div><div class="line">Subscription: 1 Event: next(🅰️)</div><div class="line">Subscription: 2 Event: next(🅰️)</div><div class="line">Subscription: 1 Event: next(🅱️)</div><div class="line">Subscription: 2 Event: next(🅱️)</div></pre></td></tr></table></figure>
<p>当然你也指定重发事件的缓冲区大小，比如上面的例子如果这样创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 1)</div></pre></td></tr></table></figure>
<p>指定缓冲区大小为1，那么订阅者2就不会收到<code>🐶</code>了。<br><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490252744268.png" alt="image"></p>
<h4 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h4><p>广播所有事件给订阅者，对于新的订阅者，广播最近的一个事件或者默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">let subject = BehaviorSubject(value: &quot;🔴&quot;)</div><div class="line"></div><div class="line">subject.addObserver(&quot;1&quot;).disposed(by: disposeBag)</div><div class="line">subject.onNext(&quot;🐶&quot;)</div><div class="line">subject.onNext(&quot;🐱&quot;)</div><div class="line"></div><div class="line">subject.addObserver(&quot;2&quot;).disposed(by: disposeBag)</div><div class="line">subject.onNext(&quot;🅰️&quot;)</div><div class="line">subject.onNext(&quot;🅱️&quot;)</div><div class="line"></div><div class="line">subject.addObserver(&quot;3&quot;).disposed(by: disposeBag)</div><div class="line">subject.onNext(&quot;🍐&quot;)</div><div class="line">subject.onNext(&quot;🍊&quot;)</div><div class="line"></div><div class="line">output:</div><div class="line">Subscription: 1 Event: next(🔴)</div><div class="line">Subscription: 1 Event: next(🐶)</div><div class="line">Subscription: 1 Event: next(🐱)</div><div class="line">Subscription: 2 Event: next(🐱)</div><div class="line">Subscription: 1 Event: next(🅰️)</div><div class="line">Subscription: 2 Event: next(🅰️)</div><div class="line">Subscription: 1 Event: next(🅱️)</div><div class="line">Subscription: 2 Event: next(🅱️)</div><div class="line">Subscription: 3 Event: next(🅱️)</div><div class="line">Subscription: 1 Event: next(🍐)</div><div class="line">Subscription: 2 Event: next(🍐)</div><div class="line">Subscription: 3 Event: next(🍐)</div><div class="line">Subscription: 1 Event: next(🍊)</div><div class="line">Subscription: 2 Event: next(🍊)</div><div class="line">Subscription: 3 Event: next(🍊)</div></pre></td></tr></table></figure></p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490254112871.png" alt="image"></p>
<p><code>PublishSubject</code>, <code>ReplaySubject</code>, and <code>BehaviorSubject</code>不会自动发送完成事件当他们被回收时。</p>
<h4 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h4><p><code>Variable</code>是<code>BehaviorSubject</code>的封装，它和<code>BehaviorSubject</code>不同之处在于，不能向<code>Variable</code>发送<code>.Complete</code>和<code>.Error</code>，它会在生命周期结束被释放的时候自动发送<code>.Complete</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">let disposeBag = DisposeBag()</div><div class="line">let variable = Variable(&quot;🔴&quot;)</div><div class="line"></div><div class="line">variable.asObservable().addObserver(&quot;1&quot;).disposed(by: disposeBag)</div><div class="line">variable.value = &quot;🐶&quot;</div><div class="line">variable.value = &quot;🐱&quot;</div><div class="line"></div><div class="line">variable.asObservable().addObserver(&quot;2&quot;).disposed(by: disposeBag)</div><div class="line">variable.value = &quot;🅰️&quot;</div><div class="line">variable.value = &quot;🅱️&quot;</div><div class="line"></div><div class="line">output:</div><div class="line">Subscription: 1 Event: next(🔴)</div><div class="line">Subscription: 1 Event: next(🐶)</div><div class="line">Subscription: 1 Event: next(🐱)</div><div class="line">Subscription: 2 Event: next(🐱)</div><div class="line">Subscription: 1 Event: next(🅰️)</div><div class="line">Subscription: 2 Event: next(🅰️)</div><div class="line">Subscription: 1 Event: next(🅱️)</div><div class="line">Subscription: 2 Event: next(🅱️)</div><div class="line">Subscription: 1 Event: completed</div><div class="line">Subscription: 2 Event: completed</div></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a></p>
<p><a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="external">Document</a></p>
]]></content>
    
    <summary type="html">
    
      RxSwift中有两个很重要的概念就是被观察者和订阅者，被观察者可以发出一系列事件信号，订阅号可以收到这些信号并进行相应的处理。 
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 初章</title>
    <link href="http://www.alonemonkey.com/2017/03/22/rxswift-part-one/"/>
    <id>http://www.alonemonkey.com/2017/03/22/rxswift-part-one/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-22T15:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>在开始学习RxSwift之前，我们需要了解什么是函数式编程以及函数式编程的思想，便于你在后面的学习中更好的去掌握和使用RxSwift进行函数响应式编程。</p>
<p>如果你已经学习了Swift，你会发现它吸收众多语言的优点，并且在语言层面更好的去保障代码的安全，当然也可以在Swift中看到<code>map</code>、<code>filter</code>、<code>reduce</code>等函数式特性。它们接受一个转换函数对每一个元素进行转换处理然后返回一个新的对象。</p>
<p>所以函数在Swift中是一等值(first-class-values)或者一等公民，你可以把它和一个普通的变量对等起来，它可以作为参数被传递到其它函数，也可以作为其它函数的返回值。</p>
<p>或许讲到这里，你还不是很明白这个一等值以及它的魅力所在，下面来看一个《functional-swift》中提到的一个例子， 相信你在看完这个例子对Swift中的函数有一个全新的概念。</p>
<h3 id="战舰游戏"><a href="#战舰游戏" class="headerlink" title="战舰游戏"></a>战舰游戏</h3><p>现在在编写一个战舰类游戏，需要确定当前战舰的攻击范围，有以下几点：</p>
<ol>
<li>这个范围在该战舰的攻击范围</li>
<li>这个范围不能离自己太近</li>
<li>这个范围不能离友方战舰太近</li>
</ol>
<p>如下图:</p>
<p><img src="http://7xtdl4.com1.z0.glb.clouddn.com/script_1490172241211.png" alt="image"></p>
<p>现在需要计算的范围就是图中的阴影区域。</p>
<h4 id="常规套路"><a href="#常规套路" class="headerlink" title="常规套路"></a>常规套路</h4><p><strong>问题分解:</strong>首先假设战舰在原点，计算以原点为中心的一个范围，先定义两种类型，距离和点。(尽量把变量定义成有意义的名字)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typealias Distance = Double</div><div class="line"></div><div class="line">struct Position&#123;</div><div class="line">    var x: Double</div><div class="line">    var y: Double</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给<code>Position</code>添加一个函数<code>inRange(_:)</code>，检验一个点是否在某个范围区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">extension Position&#123;</div><div class="line">    func inRange(range: Distance) -&gt; Bool&#123;</div><div class="line">        return sqrt(x * x + y * y) &lt;= range</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>问题进化:</strong>当战舰不在原点的情况，需要把<code>Position</code>作为战舰<code>Ship</code>的一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct Ship&#123;</div><div class="line">    var position: Position</div><div class="line">    var firingRange: Distance   //可攻击范围</div><div class="line">    var unsafeRange: Distance  //自身的不安全范围</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给<code>Ship</code>添加一个<code>canSafelyEngageShip(_:)</code>,检测另一个战舰是否在可攻击范围内，但是又不能距离自身太近，也就是<code>unsafeRange</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extension Ship&#123;</div><div class="line">   func canSafelyEngageShip(target: Ship) -&gt; Bool &#123;</div><div class="line">        let dx = target.position.x - position.x</div><div class="line">        let dy = target.position.y - position.y</div><div class="line">        let targetDistance = sqrt(dx * dx + dy * dy)</div><div class="line">        return targetDistance &lt;=  ringRange &amp;&amp; targetDistance &gt; unsafeRange</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还要避免战绩攻击范围不能距离友方战舰太近，也就是友方战舰不能和敌方战舰太近。所以<code>canSafelyEngageShip</code>进阶为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">extension Ship&#123;</div><div class="line">   func canSafelyEngageShip(target: Ship, friendly: Ship) -&gt; Bool &#123;</div><div class="line">        let dx = target.position.x - position.x</div><div class="line">        let dy = target.position.y - position.y</div><div class="line">        let targetDistance = sqrt(dx * dx + dy * dy)</div><div class="line">        let friendlyDx = friendly.position.x - target.position.x </div><div class="line">        let friendlyDy = friendly.position.y -   target.position.y </div><div class="line">        let friendlyDistance = sqrt(friendlyDx * friendlyDx + friendlyDy * friendlyDy)</div><div class="line">        return targetDistance &lt;=  ringRange</div><div class="line">                    &amp;&amp; targetDistance &gt; unsafeRange </div><div class="line">                    &amp;&amp; (friendlyDistance &gt; unsafeRange)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>解决问题:</strong>现在发现代码已经变得不是那么好维护了，而且同一个函数中存在处理同样问题的函数(计算距离)。当然可以把这些计算放到<code>Position</code>里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extension Position&#123;</div><div class="line">    func minus(p: Position) -&gt; Position&#123;</div><div class="line">        return Position(x: x - p.x, y: y - p.y)</div><div class="line">    &#125;</div><div class="line">    var length: Double&#123;</div><div class="line">        return sqrt(x * x + y * y)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么代码可以变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extension Ship &#123;</div><div class="line">func canSafelyEngageShip(target: Ship, friendly: Ship) -&gt; Bool &#123;</div><div class="line">        let targetDistance = target.position.minus(position).length</div><div class="line">        let friendlyDistance = friendly.position.minus(target.position).length</div><div class="line">         return targetDistance &lt;=  ringRange</div><div class="line">                    &amp;&amp; targetDistance &gt; unsafeRange </div><div class="line">                    &amp;&amp; (friendlyDistance &gt; unsafeRange)</div><div class="line">&#125; &#125;</div></pre></td></tr></table></figure>
<h4 id="函数式思维"><a href="#函数式思维" class="headerlink" title="函数式思维"></a>函数式思维</h4><p>虽然上面已经解决了我们的问题，但是通过函数式的思维把上面解决的问题抽象化，前面提到函数在Swift里面是一等值，所以可以把我们要解决的问题抽象化，用函数的方式去声明。</p>
<p>比如在上面遇到的一个问题是判断一个点是不是在某个区域内。问题分解：</p>
<p>输入： 某个点 <code>Position</code><br>输出:   这个点是不是在该区域<br>怎么描述这个区域：暂时还不知道，它可能是一个圆，也可能是一个矩形或者其它的形状。</p>
<p>写成函数是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func pointInRange(point: Position) -&gt; Bool&#123;</div><div class="line">    //怎么描述这个区域，暂时还不知道</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为函数就是一等公民，所以可以定义成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typealias Region = Position -&gt; Bool</div></pre></td></tr></table></figure>
<p>怎么描述一个区域，你到时跟我说吧，反正你给一个点，我就能告诉你这个点在不在你描述的这个区域，其实就是定义的一个区域范围。<br>假设战舰还是在原点，定义一个在圆心在圆点的一个圆表示它的攻击范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func circle(radius: Distance) -&gt; Region&#123;</div><div class="line">    return &#123;point in point.length &lt;= radius&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后把圆心的位置加进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func circle(radius: Distance, center: Position) -&gt; Region&#123;</div><div class="line">    return &#123;point in point.minus(center).length &lt;= radius&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样每次在创建这个圆的时候都要指定圆点，是不是可以通过对一个在圆点的圆做一个变换之后来得到一个新的圆呢？ 比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func shift(region: Region, offset: Position) -&gt; Region &#123;</div><div class="line">     return &#123; point in region(point.minus(offset)) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传一个区域和移动的偏移来生成一个新的圆。代码可以从:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Region circle = circle(10,Position(x:5, y:5))</div></pre></td></tr></table></figure>
<p>变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Region circle = circle(10)</div><div class="line">Region newCircle = shift(circle, Position(x:5, y:5))</div></pre></td></tr></table></figure>
<p>尽量把一些可变的东西抽象出来！</p>
<p>然后可以基于这个<code>Region</code>操作，比如反转区域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func invert(region: Region) -&gt; Region &#123;</div><div class="line">     return &#123; point in !region(point) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取交集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func intersection(region1: Region, _ region2: Region) -&gt; Region &#123; </div><div class="line">    return &#123; point in region1(point) &amp;&amp; region2(point) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取并集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func union(region1: Region, _ region2: Region) -&gt; Region &#123; </div><div class="line">    return &#123; point in region1(point) || region2(point) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在第一个区域不在第二个区域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func difference(region: Region, minus: Region) -&gt; Region &#123; </div><div class="line">    return intersection(region, invert(minus))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>针对一开始的函数<code>canSafelyEngageShip</code>可以改写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extension Ship &#123;</div><div class="line">    func canSafelyEngageShip(target: Ship, friendly: Ship) -&gt; Bool &#123;</div><div class="line">        let rangeRegion = difference(circle( ringRange), minus: circle(unsafeRange))</div><div class="line">        let  ringRegion = shift(rangeRegion, offset: position) </div><div class="line">        let friendlyRegion = shift(circle(unsafeRange), offset: friendly.position)</div><div class="line">        let resultRegion = difference( ringRegion, minus: friendlyRegion) </div><div class="line">        return resultRegion(target.position)</div><div class="line">&#125; &#125;</div></pre></td></tr></table></figure>
<p>在上面的例子中，还可以把<code>Region</code>作为一个<code>struct</code>，从而写出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rangeRegion.shift(ownPosition).difference(friendlyRegion)</div></pre></td></tr></table></figure>
<h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>那么什么是响应式编程，来看个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int a = 3;</div><div class="line">int b = 4;</div><div class="line">int c = a + b;</div><div class="line">NSLog(@&quot;c is %d&quot;, c);   // =&gt; 7</div><div class="line">a = 5;</div><div class="line">b = 7;</div><div class="line">NSLog(@&quot;c is %d&quot;, c);   // 仍然是7</div></pre></td></tr></table></figure>
<p>在这里把<code>a,b,c</code>当成某个状态，<code>c</code>是<code>a,b</code>两个状态的组合，正常的编程中，在计算了<code>c</code>的状态之后，再去改变<code>a,b</code>的状态是不会影响到<code>c</code>的状态的。所以在正常编程中我们要去记录很多状态并及时更新状态，比如网络请求的状态，下拉刷新的状态。各种各样的事件响应方式，无形中增加了编码的复杂度。而在响应式编程中，每一个状态的改变都会发出一个信号，更新与之关联的状态。</p>
<p>比如上面<code>a,b</code>的状态改变之后能够及时更新<code>c</code>的状态，而不用重新通过<code>a+b</code>计算<code>c</code>的状态了，在响应式编程中，我们可以创建很多被观察者对象，当这些对象的状态发生改变时，我们能够链式的去更新和处理各个状态的变化和数据。</p>
<p>后面我们会讲到<code>RxSwift</code>中的被观察者和订阅者。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个例子告诉我们，在 <code>Swift</code> 中计算和传递函数的方式与整型或布尔型没有任何不同。这让我 们能够写出一些基础的图形组件 (比如圆)，进而能以这些组件为基础，来构建一系列函数。每 个函数都能修改或是合并区域，并以此创建新的区域。比起写复杂的函数来解决某个具体的问 题，现在我们完全可以通过将一些小型函数装配起来，广泛地解决各种各样的问题。</p>
]]></content>
    
    <summary type="html">
    
      走进函数响应式编程的世界~ 
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>第十一期 Coder群周报</title>
    <link href="http://www.alonemonkey.com/2016/12/22/weekly/"/>
    <id>http://www.alonemonkey.com/2016/12/22/weekly/</id>
    <published>2016-12-21T16:00:00.000Z</published>
    <updated>2017-03-05T09:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>LLVM</p>
</blockquote>
<h3 id="LLVM-官方文档"><a href="#LLVM-官方文档" class="headerlink" title="LLVM 官方文档"></a><a href="http://clang.llvm.org/docs/index.html" target="_blank" rel="external">LLVM 官方文档</a></h3><p>介绍: LLVM的官方文档，你想知道的都可以在这里找到。</p>
<h3 id="LLVM-PROJECT-BLOG"><a href="#LLVM-PROJECT-BLOG" class="headerlink" title="LLVM PROJECT BLOG"></a><a href="http://blog.llvm.org/" target="_blank" rel="external">LLVM PROJECT BLOG</a></h3><p>介绍: LLVM Project News and Details from the Trenches</p>
<h3 id="The-Compiler"><a href="#The-Compiler" class="headerlink" title="The Compiler"></a><a href="https://www.objc.io/issues/6-build-tools/compiler/" target="_blank" rel="external">The Compiler</a></h3><p>介绍: 介绍了编译器的工作流程以及Clang工具。</p>
<h3 id="LLVM-Tutorial"><a href="#LLVM-Tutorial" class="headerlink" title="LLVM Tutorial"></a><a href="http://llvm.org/docs/tutorial/index.html" target="_blank" rel="external">LLVM Tutorial</a></h3><p>介绍: 动手搞事情。</p>
<h3 id="Clang-tutorial"><a href="#Clang-tutorial" class="headerlink" title="Clang-tutorial"></a><a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">Clang-tutorial</a></h3><p>介绍: A collection of code samples showing usage of clang and llvm as a library</p>
<h3 id="GETTING-STARTED-WITH-LLVM-CLANG-ON-OS-X"><a href="#GETTING-STARTED-WITH-LLVM-CLANG-ON-OS-X" class="headerlink" title="GETTING STARTED WITH LLVM/CLANG ON OS X"></a><a href="http://lowlevelbits.org/getting-started-with-llvm/clang-on-os-x/" target="_blank" rel="external">GETTING STARTED WITH LLVM/CLANG ON OS X</a></h3><p>介绍: This article is a guide how to set up development environment for Clang on OS X. The following topics are covered:1.getting sources 2.setting up IDE/compiling 3.debugging</p>
<h3 id="Clang-Tutorial"><a href="#Clang-Tutorial" class="headerlink" title="Clang Tutorial"></a><a href="https://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-i-introduction/" target="_blank" rel="external">Clang Tutorial</a></h3><p>介绍: 老司机带你上路。</p>
<h3 id="Implementing-a-code-generator-with-libclang"><a href="#Implementing-a-code-generator-with-libclang" class="headerlink" title="Implementing a code generator with libclang"></a><a href="http://szelei.me/code-generator/" target="_blank" rel="external">Implementing a code generator with libclang</a></h3><p>介绍: RT</p>
<h3 id="基于LLVM的代码混淆"><a href="#基于LLVM的代码混淆" class="headerlink" title="基于LLVM的代码混淆"></a><a href="http://zke1ev3n.me/2016/01/18/%E5%9F%BA%E4%BA%8ELLVM%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/" target="_blank" rel="external">基于LLVM的代码混淆</a></h3><p>介绍: 从LLVM编译，Pass到集成NDK。</p>
<h3 id="Implementing-a-JIT-Compiled-Language-with-Haskell-and-LLVM"><a href="#Implementing-a-JIT-Compiled-Language-with-Haskell-and-LLVM" class="headerlink" title="Implementing a JIT Compiled Language with Haskell and LLVM"></a><a href="http://www.stephendiehl.com/llvm/" target="_blank" rel="external">Implementing a JIT Compiled Language with Haskell and LLVM</a></h3><h3 id="Let’s-Write-an-LLVM-Specializer-for-Python"><a href="#Let’s-Write-an-LLVM-Specializer-for-Python" class="headerlink" title="Let’s Write an LLVM Specializer for Python!"></a><a href="http://dev.stephendiehl.com/numpile/" target="_blank" rel="external">Let’s Write an LLVM Specializer for Python!</a></h3><p>介绍: 直接搞语言了，高端。</p>
<h3 id="Clang-Tutorial-翻译"><a href="#Clang-Tutorial-翻译" class="headerlink" title="Clang Tutorial 翻译"></a><a href="http://jszhujun2010.farbox.com/archive" target="_blank" rel="external">Clang Tutorial 翻译</a></h3><h3 id="CLANG技术分享系列"><a href="#CLANG技术分享系列" class="headerlink" title="CLANG技术分享系列"></a><a href="https://kangwang1988.github.io/tech/2016/10/31/write-your-first-clang-plugin.html" target="_blank" rel="external">CLANG技术分享系列</a></h3><h3 id="JSPatch-Convertor-实现原理详解"><a href="#JSPatch-Convertor-实现原理详解" class="headerlink" title="JSPatch Convertor 实现原理详解"></a><a href="http://blog.cnbang.net/tech/2915/#more-2915" target="_blank" rel="external">JSPatch Convertor 实现原理详解</a></h3><h3 id="基于clang插件的一种iOS包大小瘦身方案"><a href="#基于clang插件的一种iOS包大小瘦身方案" class="headerlink" title="基于clang插件的一种iOS包大小瘦身方案"></a><a href="https://www.zybuluo.com/pockry/note/566013" target="_blank" rel="external">基于clang插件的一种iOS包大小瘦身方案</a></h3><h3 id="obfuscator-llvm"><a href="#obfuscator-llvm" class="headerlink" title="obfuscator-llvm"></a><a href="https://github.com/obfuscator-llvm/obfuscator" target="_blank" rel="external">obfuscator-llvm</a></h3><h3 id="LLVM二三事"><a href="#LLVM二三事" class="headerlink" title="LLVM二三事"></a><a href="http://feimengspirit.com/llvm" target="_blank" rel="external">LLVM二三事</a></h3><p><br><br><blockquote class="blockquote-center"><p>LLVM 书籍</p>
</blockquote></p>
<h3 id="Getting-Started-with-LLVM-Core-Libraries"><a href="#Getting-Started-with-LLVM-Core-Libraries" class="headerlink" title="Getting Started with LLVM Core Libraries"></a>Getting Started with LLVM Core Libraries</h3><h3 id="LLVM-Cookbook"><a href="#LLVM-Cookbook" class="headerlink" title="LLVM Cookbook"></a>LLVM Cookbook</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;LLVM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;LLVM-官方文档&quot;&gt;&lt;a href=&quot;#LLVM-官方文档&quot; class=&quot;headerlink&quot; title=&quot;LLVM 官方文档&quot;
    
    </summary>
    
      <category term="weekly" scheme="http://www.alonemonkey.com/categories/weekly/"/>
    
    
  </entry>
  
</feed>
