<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AloneMonkey</title>
  
  <subtitle>Coder Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.alonemonkey.com/"/>
  <updated>2019-01-02T13:57:29.592Z</updated>
  <id>http://www.alonemonkey.com/</id>
  
  <author>
    <name>AloneMonkey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《iOS应用逆向与安全》首发抽奖!</title>
    <link href="http://www.alonemonkey.com/2018/06/01/new-ios-reverse-book/"/>
    <id>http://www.alonemonkey.com/2018/06/01/new-ios-reverse-book/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.592Z</updated>
    
    <content type="html"><![CDATA[<p>时隔一年，答应大家的书终于出版了，首先感谢一直等待的人，谢谢你们的支持。</p><p>首先写这本书一方面为了总结梳理一下自己学过的东西，另一方面也是为了有个沉淀希望能够帮助到别人。所以这本书的内容也是根据我自己学习历程进行的整理，包括环境工具准备、基础理论理解、实战分析、安全保护几个方面。</p><p>我个人一直倡导的学习方式是能够从一个工具的使用或者一个技术的实现去探索它的原理，通过理解掌握的基础上再去举一反三才能形成一种学习的良性循环。所以对于本书的定位也是这样，一方面新手可以快速上手，另外一方面会从表面现象深入到内部理解和掌握，而且如今的市场需要和行业需要，也不是浅尝辄止就能应付得了的。</p><p>所以我建议大家在看的时候不要认为你明白了，而且在认真阅读和实践之后告诉自己: “哦，原来是这样”。只要大家在阅读的时候觉得自己能够从中获得新的知识、技巧或者灵感都是笔者最值得欣慰的事情。</p><p>目前本书已经开始预售，书名《iOS应用逆向与安全》:</p><p>天猫认准 <a href="https://detail.tmall.com/item.htm?spm=a220m.1000858.1000725.1.1fe01be0HqmLHQ&amp;id=570691214072&amp;areaId=330100&amp;user_id=1932014659&amp;cat_id=2&amp;is_b=1&amp;rn=6a473fe67e704e19db33cb5af613e5f3&amp;sm=true&amp;sm=true&amp;sm=true&amp;smToken=8c8a39cdeb6444629e3f2b7152a2f894&amp;smSign=RoiUdcLPEGU7tzyn70i6wA==" target="_blank" rel="noopener">电子工业出版社官方旗舰店</a></p><p>京东认准 <a href="https://item.jd.com/12361729.html" target="_blank" rel="noopener">京东自营</a></p><p>封面如下:</p><p><img src="http://img.cdn.blogfshare.com/script_1527776075809.png" alt="image"></p><p>同样在这里也会送出5本签名版书籍给大家，谢谢大家一直以来的支持！</p><p><img src="http://img.cdn.blogfshare.com/script_1527776197341.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      时隔一年，答应大家的书终于出版了，送出5本签名版书籍给大家，谢谢大家一直以来的支持！
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>通过MonkeyDev加载网络或者自己的cy脚本</title>
    <link href="http://www.alonemonkey.com/2018/04/20/monkeydev-cycript/"/>
    <id>http://www.alonemonkey.com/2018/04/20/monkeydev-cycript/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一开始想到这个功能的时候是因为Hank老师在我的微信公众号(blogfshare)里面问了一个问题:</p><p><img src="http://img.cdn.blogfshare.com/script_1524240173321.png" alt="image"></p><h3 id="越狱设备"><a href="#越狱设备" class="headerlink" title="越狱设备"></a>越狱设备</h3><p>在越狱设备上面，可以将自己的脚本放到<code>/usr/lib/cycript0.9/</code>下面，然后通过<code>@import xxx</code>来导入即可使用自定义脚本里面封装的一些函数，极为方便。比如其自带的<code>/usr/lib/cycript0.9/com/saurik/substrate/MS.cy</code>就可以通过<code>@import com.saurik.substrate.MS</code>来导入这个模块，同样也可以放入一些自己的脚本来导入。那么在非越狱环境怎么去解决使用自定义脚本的问题呢？</p><h3 id="非越狱设备"><a href="#非越狱设备" class="headerlink" title="非越狱设备"></a>非越狱设备</h3><p>其实非越狱设备实现这个很简单，只要让cycript能找到我们自己的脚本所在的位置就行了，修改<code>libcycript.cy</code>文件的<code>require.resolve</code>函数，使其从当前应用目录或者沙盒目录里面去查找脚本，然后程序从网络下载脚本保存到沙盒目录就可以了，修改部分如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">require.resolve = function(name) &#123;</span><br><span class="line">......</span><br><span class="line">let library = GetLibraryPath();</span><br><span class="line">    let path = ResolveFile(true, library + &quot;/&quot; + name + &quot;.cy&quot;);</span><br><span class="line">    if (path != null)</span><br><span class="line">        return path;</span><br><span class="line"></span><br><span class="line">    let document = GetDocumentPath();</span><br><span class="line">    path = ResolveFile(true, document + &quot;/cycript/&quot; + name + &quot;.cy&quot;);</span><br><span class="line">    if (path != null)</span><br><span class="line">        return path;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>然后笔者在MonkeyDev的模块中增加了一个文件用于配置下载脚本的名字以及url:</p><p><img src="http://img.cdn.blogfshare.com/script_1524239271670.png" alt=""></p><p>key是脚本导入时候的名字，value是脚本所在的url，程序启动会自动下载脚本保存在Document的目录下面，然后在终端通过如下方式导入使用即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">➜  cycript_0.9.594 ./cycript -r 192.168.2.248:6666</span><br><span class="line">cy# @import md</span><br><span class="line">&#123;constants:&#123;APPID:@&quot;com.alonemonkey.TestCycript&quot;,APPPATH:@&quot;/var/containers/Bundle/Application/FF940D03-A857-4BBC-A01A-23585A86F76E/TestCycript.app&quot;,APPHOME:@&quot;/var/mobile/Containers/Data/Application/DADEBC7F-6472-40F3-8C1E-4383C4843405&quot;,APPDOC:@&quot;/var/mobile/Containers/Data/Application/DADEBC7F-6472-40F3-8C1E-4383C4843405/Documents&quot;,APPLIBRARY:@&quot;/var/mobile/Containers/Data/Application/DADEBC7F-6472-40F3-8C1E-4383C4843405/Library&quot;,APPCACHE:@&quot;/var/mobile/Containers/Data/Application/DADEBC7F-6472-40F3-8C1E-4383C4843405/Library/Caches&quot;&#125;,pviews:function ()&#123;return UIApp.keyWindow.recursiveDescription().toString()&#125;,pvcs:function ()&#123;return UIWindow.keyWindow().rootViewController._printHierarchy().toString()&#125;,rp:function (t)&#123;var e;e=&quot;&quot;+t.toString();while(t.nextResponder)&#123;e+=&quot;\n&quot;+t.nextResponder.toString();t=t.nextResponder&#125;return e&#125;,pactions:function (r)&#123;var e,t,n,i;i=&quot;&quot;;n=r.allTargets.allObjects();for(e=0;e&lt;n.length;e++)&#123;t=objc_msgSend(r,&quot;actionsForTarget:forControlEvent:&quot;,n[e],0);i+=n[e]+&quot; &quot;+objc_msgSend(t,&quot;componentsJoinedByString:&quot;,Instance.box(&quot;,&quot;))&#125;return i&#125;&#125;</span><br><span class="line">cy# APPID</span><br><span class="line">@&quot;com.alonemonkey.TestCycript&quot;</span><br><span class="line">cy# pviews()</span><br><span class="line">`&lt;UIWindow: 0x105313b60; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1c425bae0&gt;; layer = &lt;UIWindowLayer: 0x1c40394e0&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x1053205d0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x1c403bd80&gt;&gt;</span><br><span class="line">   |    | &lt;UILabel: 0x10531e7d0; frame = (102.5 45; 170 40); text = &apos;AloneMonkey&apos;; opaque = NO; autoresize = RM+BM; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x1c408c0d0&gt;&gt;</span><br><span class="line">   |    | &lt;UILabel: 0x1053207b0; frame = (97.5 110; 180 40); text = &apos;You are the best!!!&apos;; opaque = NO; autoresize = RM+BM; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x1c408e150&gt;&gt;</span><br><span class="line">   |    | &lt;UITextView: 0x105836000; frame = (26 230; 343 427); text = &apos;/opt/MonkeyDev/bin/md</span><br><span class="line"></span><br><span class="line">- ...&apos;; clipsToBounds = YES; autoresize = RM+BM; gestureRecognizers = &lt;NSArray: 0x1c0058fc0&gt;; layer = &lt;CALayer: 0x1c002f1a0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;343, 317&#125;; adjustedContentInset: &#123;0, 0, 0, 0&#125;&gt;</span><br><span class="line">   |    |    | &lt;&lt;_UITextContainerView: 0x105318060; frame = (0 0; 343 317); layer = &lt;__UITextTiledLayer: 0x1c40c42f0&gt;&gt; minSize = &#123;0, 0&#125;, maxSize = &#123;1.7976931348623157e+308, 1.7976931348623157e+308&#125;, textContainer = &lt;NSTextContainer: 0x1c0105fa0 size = (343.000000,inf); widthTracksTextView = YES; heightTracksTextView = NO&gt;; exclusionPaths = 0x1c40025e0; lineBreakMode = 0&gt;</span><br><span class="line">   |    |    |    | &lt;__UITileLayer: 0x1c0240780&gt; (layer)</span><br><span class="line">   |    |    |    | &lt;__UITileLayer: 0x1c0240720&gt; (layer)</span><br><span class="line">   |    |    |    | &lt;__UITileLayer: 0x1c0240a20&gt; (layer)</span><br><span class="line">   |    |    | &lt;UIImageView: 0x105322260; frame = (3 421.5; 337 2.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1c403c620&gt;&gt;</span><br><span class="line">   |    |    | &lt;UIImageView: 0x105322490; frame = (337.5 380; 2.5 44); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &lt;CALayer: 0x1c403c6e0&gt;&gt;</span><br><span class="line">   |    | &lt;UIButton: 0x1053163b0; frame = (127.5 175; 120 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x1c4039aa0&gt;&gt;</span><br><span class="line">   |    |    | &lt;UIButtonLabel: 0x10540fcf0; frame = (2 6; 116.5 18); text = &apos;ShowChangeLog&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x1c0087b70&gt;&gt;</span><br><span class="line">   |    | &lt;_UILayoutGuide: 0x105320fa0; frame = (0 0; 0 20); hidden = YES; layer = &lt;CALayer: 0x1c403bfe0&gt;&gt;</span><br><span class="line">   |    | &lt;_UILayoutGuide: 0x1053213a0; frame = (0 667; 0 0); hidden = YES; layer = &lt;CALayer: 0x1c403bee0&gt;&gt;`</span><br><span class="line">cy# pvcs()</span><br><span class="line">&quot;&lt;CustomViewController 0x1053133f0&gt;, state: appeared, view: &lt;UIView 0x1053205d0&gt;&quot;</span><br><span class="line">cy# pactions(#0x1053163b0)</span><br><span class="line">&quot;&lt;CustomViewController: 0x1053133f0&gt; showChangeLog:&quot;</span><br><span class="line">cy# rp(#0x1053163b0)</span><br><span class="line">`&lt;UIButton: 0x1053163b0; frame = (127.5 175; 120 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x1c4039aa0&gt;&gt;</span><br><span class="line">&lt;UIView: 0x1053205d0; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x1c403bd80&gt;&gt;</span><br><span class="line">&lt;CustomViewController: 0x1053133f0&gt;</span><br><span class="line">&lt;UIWindow: 0x105313b60; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x1c425bae0&gt;; layer = &lt;UIWindowLayer: 0x1c40394e0&gt;&gt;</span><br><span class="line">&lt;UIApplication: 0x105406120&gt;</span><br><span class="line">&lt;AppDelegate: 0x1c002b1a0&gt;`</span><br><span class="line">cy# ?exit</span><br></pre></td></tr></table></figure><p>当时在本地的脚本可以拷贝到Frameworks的目录下面:</p><p><img src="http://img.cdn.blogfshare.com/script_1524241423079.png" alt="image"></p><p>然后通过<code>@import new</code>就可以导入使用了，是不是很方便！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这个功能实现确实很简单，但是目前还没有把里面带的MS.cy弄进来，后面看看再弄吧。</p>]]></content>
    
    <summary type="html">
    
      在非越狱的环境下通过MonkeyDev来加载自定义的cy脚本文件来方便cycript的分析。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>旅行的青蛙Unity游戏逆向修改--iOS篇</title>
    <link href="http://www.alonemonkey.com/2018/02/03/unity-reverse-ios/"/>
    <id>http://www.alonemonkey.com/2018/02/03/unity-reverse-ios/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前写了一篇分析Android C#脚本的文章，主要也是为了给这篇文章做铺垫吧，因为在iOS现在都是IL2CPP模式，C#脚本已经被转成了c代码。所以要单独分析iOS的话难度会大很多，如果从Android的C#脚本入手的话，因为iOS和Android脚本都是一样的话，可以从Android分析的函数名来对应iOS的c函数然后进行hook修改。</p><h3 id="提取ipa"><a href="#提取ipa" class="headerlink" title="提取ipa"></a>提取ipa</h3><p>首先从越狱设备上面提取旅行青蛙的ipa包，使用<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a>一键提取即可。由于是日文名字，先通过<code>./dump.py -l</code>把名字列出来，然后复制名字或者通过bundle id去dump就可以了。</p><h3 id="IL2CPP符号还原"><a href="#IL2CPP符号还原" class="headerlink" title="IL2CPP符号还原"></a>IL2CPP符号还原</h3><p>由于使用IL2CPP选项编译unity游戏，会生成cpp的代码，直接使用IDA看是看不到函数和函数名的，而且游戏中使用的字符串都被保存在global-metadata.dat的资源文件里。首先要通过提取global-metadata.dat文件里面的字符串对对应的c函数进行符号还原。具体也有现成的文章:<a href="https://www.nevermoe.com/?p=572" target="_blank" rel="noopener">还原使用IL2CPP编译的unity游戏的symbol</a>，github上面也有线程的项目也做这件事情<a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="noopener">Il2CppDumper</a>。下载release的工具，运行Il2CppDumper.exe并依次选择il2cpp的可执行文件和global-metadata.dat文件，然后选择Auto(Plus)模式，将生成dump.cs文件和script.py脚本。使用IDA打开可执行文件然后使用script.py脚本即可还原符号。</p><p><img src="http://img.cdn.blogfshare.com/hexo/il2cppdumper.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Making method name...</span><br><span class="line">Make method name done</span><br><span class="line">Setting String...</span><br><span class="line">Set string done</span><br><span class="line">Making function...</span><br><span class="line">Make function done, please wait for IDA to complete the analysis</span><br><span class="line">Script finish !</span><br></pre></td></tr></table></figure><h3 id="根据函数hook代码"><a href="#根据函数hook代码" class="headerlink" title="根据函数hook代码"></a>根据函数hook代码</h3><p>还原之后就可以根据之前分析到的函数名来hook对应的代码了，首先是三叶草的数目通过<code>SuperGameMaster.CloverPointStock()</code>获取的，在IDA搜索<code>CloverPointStock</code>如下:</p><p><img src="http://img.cdn.blogfshare.com/hexo/gamemaster_cloverpointstock.jpg" alt=""></p><p>接着就可以直接hook这个函数了，由于要inline hook目前是在越狱机器上面，后面会讲到非越狱机器hook的方案。使用<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a>新建一个<code>Logos Tweak</code>项目，清空<code>.xm</code>的内容并写入如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;substrate.h&gt;</span><br><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line">#import &lt;mach-o/dyld.h&gt;</span><br><span class="line"></span><br><span class="line">int (*old_clover_point_stock)(void);</span><br><span class="line"></span><br><span class="line">int new_clover_point_stock(void)</span><br><span class="line">&#123;</span><br><span class="line">    return 9999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%ctor</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned long clover_point_stock = _dyld_get_image_vmaddr_slide(0) + 0x100093A2C;</span><br><span class="line">        MSHookFunction((void *)clover_point_stock, (void *)&amp;new_clover_point_stock, (void **)&amp;old_clover_point_stock);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在build settings里面设置端口和设备密码然后command + b安装就能看到效果了，其它函数的hook也是一样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;substrate.h&gt;</span><br><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line">#import &lt;mach-o/dyld.h&gt;</span><br><span class="line"></span><br><span class="line">int (*old_clover_point_stock)(void);</span><br><span class="line"></span><br><span class="line">int new_clover_point_stock(void)</span><br><span class="line">&#123;</span><br><span class="line">    return 9999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int (*old_ticket_stock)(void);</span><br><span class="line"></span><br><span class="line">int new_ticket_stock(void)</span><br><span class="line">&#123;</span><br><span class="line">    return 9999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void (*old_lotterycheck)(uint64_t obj);</span><br><span class="line"></span><br><span class="line">void new_lotterycheck(uint64_t obj)</span><br><span class="line">&#123;</span><br><span class="line">    *(int*)(obj + 80) = rand() % 4 + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t (*old_new_clover_object)(uint64_t obj, int index, uint64_t cloverData, uint64_t cloversObj, int fourLeafFlag);</span><br><span class="line"></span><br><span class="line">uint64_t new_new_clover_object(uint64_t obj, int index, uint64_t cloverData, uint64_t cloversObj, int fourLeafFlag)</span><br><span class="line">&#123;</span><br><span class="line">    return old_new_clover_object(obj,index,cloverData,cloversObj,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%ctor</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned long clover_point_stock = _dyld_get_image_vmaddr_slide(0) + 0x100093A2C;</span><br><span class="line">        MSHookFunction((void *)clover_point_stock, (void *)&amp;new_clover_point_stock, (void **)&amp;old_clover_point_stock);</span><br><span class="line">        </span><br><span class="line">        unsigned long ticket_stock = _dyld_get_image_vmaddr_slide(0) + 0x100093AA4;</span><br><span class="line">        MSHookFunction((void *)ticket_stock, (void *)&amp;new_ticket_stock, (void **)&amp;old_ticket_stock);</span><br><span class="line">        </span><br><span class="line">        unsigned long lotterycheck = _dyld_get_image_vmaddr_slide(0) + 0x100086CF4;</span><br><span class="line">        MSHookFunction((void *)lotterycheck, (void *)&amp;new_lotterycheck, (void **)&amp;old_lotterycheck);</span><br><span class="line">        </span><br><span class="line">        unsigned long new_clover_object = _dyld_get_image_vmaddr_slide(0) + 0x100037100;</span><br><span class="line">        MSHookFunction((void *)new_clover_object, (void *)&amp;new_new_clover_object, (void **)&amp;old_new_clover_object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个函数<code>RaffelPanel$$LotteryCheck</code>要修改里面的result的值，就要根据汇编或者伪代码来看result的赋值是在什么位置了，该函数通过F5获得的伪代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall RaffelPanel__LotteryCheck(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; // x19</span><br><span class="line">  __int64 v2; // x0</span><br><span class="line">  __int64 v3; // x0</span><br><span class="line">  int v4; // w20</span><br><span class="line">  int v5; // w23</span><br><span class="line">  signed int v6; // w24</span><br><span class="line">  __int64 v7; // x0</span><br><span class="line">  __int64 result; // x0</span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  if ( !(byte_10137EDBB &amp; 1) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_100DEAD34(6810LL);</span><br><span class="line">    byte_10137EDBB = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = qword_101439198;</span><br><span class="line">  if ( *(_BYTE *)(qword_101439198 + 266) &amp; 1 &amp;&amp; !*(_DWORD *)(qword_101439198 + 188) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_100DFF71C();</span><br><span class="line">    v2 = qword_101439198;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( !*(_QWORD *)(*(_QWORD *)(v2 + 160) + 192LL) )</span><br><span class="line">LABEL_17:</span><br><span class="line">    sub_100DE28B4();</span><br><span class="line">  v3 = sub_1000FB954();</span><br><span class="line">  v4 = Random__Range_71094(0LL, 0LL, v3, 0LL);</span><br><span class="line">  v5 = 0;</span><br><span class="line">  *(_DWORD *)(v1 + 80) = 0;   this.result = Rank.White;  //默认都是白色的球</span><br><span class="line">  v6 = -1;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = qword_101439198;</span><br><span class="line">    if ( *(_BYTE *)(qword_101439198 + 266) &amp; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !*(_DWORD *)(qword_101439198 + 188) )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_100DFF71C();</span><br><span class="line">        v7 = qword_101439198;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !*(_QWORD *)(*(_QWORD *)(v7 + 160) + 192LL) )</span><br><span class="line">      goto LABEL_17;</span><br><span class="line">    result = sub_1000FB954();</span><br><span class="line">    v5 += result;</span><br><span class="line">    if ( v4 &lt; v5 )  //if (num &lt; num2)</span><br><span class="line">      break;    </span><br><span class="line">    if ( ++v6 &gt;= 4 )</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_DWORD *)(v1 + 80) = v6 + 1;  //this.result = (Rank)i;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>*(_DWORD *)(v1 + 80)</code>的位置其实就是<code>this.result</code>所以直接修改<code>80</code>偏移位置的值就可以了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结来说的话，要分析iOS里面转换后的脚本C代码还是不容易的，如果能够根据Android C#脚本分析的结果然后对iOS的符号进行恢复一下的话，就可以直接根据Android分析到的函数直接来Hook iOS对应的函数来修改参数或者值了。不过这里还是在越狱设备上面进行的hook，然后会讲到非越狱设备同样也可以进行静态的hook操作。</p>]]></content>
    
    <summary type="html">
    
      尝试iOS Unity3D游戏逆向，脚本转成的c函数hook，以当前流行的旅行的青蛙为例。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>旅行的青蛙Unity游戏逆向修改--Android篇</title>
    <link href="http://www.alonemonkey.com/2018/02/02/unity-reverse-android/"/>
    <id>http://www.alonemonkey.com/2018/02/02/unity-reverse-android/</id>
    <published>2018-02-01T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实这篇文章也没有太多的技术含量，主要是试一试Android上面Unity3D游戏C#脚本的分析与修改，话不多说先准备好旅行青蛙的apk就开始吧。</p><h3 id="C-脚本"><a href="#C-脚本" class="headerlink" title="C#脚本"></a>C#脚本</h3><p>首先将Android apk安装包解压，查看<code>assets/bin/Data/Managed</code>文件夹下面的dll文件，其中<code>Assembly-CSharp.dll</code>便是游戏中的C#脚本，使用<a href="https://www.red-gate.com/products/dotnet-development/reflector/" target="_blank" rel="noopener">Reflector</a>或者<a href="https://github.com/0xd4d/dnSpy" target="_blank" rel="noopener">dnSpy</a>进行反编译都可以，如何出现反编译出错的情况，那可能就是脚本被加密了，一般在尝试在<code>libmono.so</code>中的<code>mono_image_open_from_data_with_name</code>中获取解密后的dll脚本，而当前分析的游戏C#脚本并没有加密。在dnSpy中的反编译结果如下:</p><p><img src="http://img.cdn.blogfshare.com/dnspy-qingwa.jpg" alt="image"></p><p>左侧就可以看到对应的类，点击类就可以看到反编译出来的代码，下面先跟游戏里面的一些特征来分析反编译出来的脚本。</p><h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>首先使用<code>adb install tabikaeru.apk</code>命令安装apk文件，然后打开游戏可以看到如下界面:</p><p><img src="http://img.cdn.blogfshare.com/hexo/device-2018-02-03-2001441517659518.png" alt=""></p><p>首先来看看怎么修改显示的文字以达到汉化的效果，使用dnSpy点击<code>编辑-&gt;搜索程序集</code>搜索右边选择<code>数字/字符串</code>然后搜索<code>名前</code>:</p><p><img src="http://img.cdn.blogfshare.com/hexo/QQ20180203200914.jpg" alt=""></p><p>点击<code>CallTutorial</code>可以找到刚刚在屏幕上面显示的文字:</p><p><img src="http://img.cdn.blogfshare.com/hexo/qingwa_calltutorial.jpg" alt=""></p><p>鼠标点击右键选择<code>编辑IL指令</code>，修改刚刚看到的文字为汉字:</p><p><img src="http://img.cdn.blogfshare.com/hexo/qingwa_rename.jpg" alt=""></p><p>然后点击应用即可看到修改后的效果:</p><p><img src="http://img.cdn.blogfshare.com/hexo/qingwa_rename_result.jpg" alt=""></p><p>点击<code>文件-&gt;全部保存</code>替换<code>assets/bin/Data/Managed</code>文件夹下面对应的文件即可，然后将文件打包成apk使用jarsinger、signapk.jar或Android助手重签名安装到手机就能看到修改后的效果了。</p><p><img src="http://img.cdn.blogfshare.com/hexo/device-2018-02-03-203204.png" alt=""></p><h3 id="修改三叶草数"><a href="#修改三叶草数" class="headerlink" title="修改三叶草数"></a>修改三叶草数</h3><p>要修改三叶草数可以从购买的时候入手，比如提示三叶草不足的时候:</p><p><img src="http://img.cdn.blogfshare.com/hexo/device-2018-02-03-204107.png" alt=""></p><p>直接搜索<code>足</code>找到目标代码:</p><p><img src="http://img.cdn.blogfshare.com/hexo/search_no_enough.jpg" alt=""></p><p>根据找到的如下代码来分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">if (SuperGameMaster.CloverPointStock() &gt;= itemDataFormat.price)</span><br><span class="line">&#123;</span><br><span class="line">    if (SuperGameMaster.FindItemStock(shopDataFormat.itemId) &lt; 99)</span><br><span class="line">    &#123;</span><br><span class="line">        base.GetComponent&lt;FlickCheaker&gt;().stopFlick(true);</span><br><span class="line">        ConfilmPanel confilm = this.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;();</span><br><span class="line">        if (itemDataFormat.type == Item.Type.LunchBox)</span><br><span class="line">        &#123;</span><br><span class="line">            confilm.OpenPanel_YesNo(string.Concat(new object[]</span><br><span class="line">            &#123;</span><br><span class="line">                itemDataFormat.name,</span><br><span class="line">                &quot;\nを買いますか？\n（所持数\u3000&quot;,</span><br><span class="line">                SuperGameMaster.FindItemStock(shopDataFormat.itemId),</span><br><span class="line">                &quot;）&quot;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            confilm.OpenPanel_YesNo(itemDataFormat.name + &quot;\nを買いますか？&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        confilm.ResetOnClick_Yes();</span><br><span class="line">        confilm.SetOnClick_Yes(delegate</span><br><span class="line">        &#123;</span><br><span class="line">            confilm.ClosePanel();</span><br><span class="line">        &#125;);</span><br><span class="line">        confilm.SetOnClick_Yes(delegate</span><br><span class="line">        &#123;</span><br><span class="line">            this.GetComponent&lt;FlickCheaker&gt;().stopFlick(false);</span><br><span class="line">        &#125;);</span><br><span class="line">        confilm.SetOnClick_Yes(delegate</span><br><span class="line">        &#123;</span><br><span class="line">            this.BuyItem();</span><br><span class="line">        &#125;);</span><br><span class="line">        confilm.ResetOnClick_No();</span><br><span class="line">        confilm.SetOnClick_No(delegate</span><br><span class="line">        &#123;</span><br><span class="line">            confilm.ClosePanel();</span><br><span class="line">        &#125;);</span><br><span class="line">        confilm.SetOnClick_No(delegate</span><br><span class="line">        &#123;</span><br><span class="line">            this.GetComponent&lt;FlickCheaker&gt;().stopFlick(false);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        base.GetComponent&lt;FlickCheaker&gt;().stopFlick(true);</span><br><span class="line">        ConfilmPanel confilm = this.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;();</span><br><span class="line">        confilm.OpenPanel(&quot;もちものがいっぱいです&quot;);</span><br><span class="line">        confilm.ResetOnClick_Screen();</span><br><span class="line">        confilm.SetOnClick_Screen(delegate</span><br><span class="line">        &#123;</span><br><span class="line">            confilm.ClosePanel();</span><br><span class="line">        &#125;);</span><br><span class="line">        confilm.SetOnClick_Screen(delegate</span><br><span class="line">        &#123;</span><br><span class="line">            this.GetComponent&lt;FlickCheaker&gt;().stopFlick(false);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当三叶草的存储小于当前商品的价格的时候就会弹出这个提示，点击<code>SuperGameMaster.CloverPointStock()</code>得到如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int CloverPointStock()</span><br><span class="line">&#123;</span><br><span class="line">    return SuperGameMaster.saveData.CloverPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的是一个从<code>saveData.CloverPoint</code>中获取的整数，可以尝试将其修改成返回一个特定的数字每次查询三叶草的数目都是这么多，右键点击<code>编辑IL指令</code>，然后点击重置并右键删除第一条指令，因为只是返回一个数字的话两条指令就够了:</p><p><img src="http://img.cdn.blogfshare.com/hexo/del_il_code.jpg" alt=""></p><p>然后修改第二条指令为一个数字，具体的指令代表的类型可以查看IL指令说明:</p><p><img src="http://img.cdn.blogfshare.com/hexo/change_colver_num.jpg" alt=""></p><p>点击确定后就能看到修改代码的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int CloverPointStock()</span><br><span class="line">&#123;</span><br><span class="line">    return 9999;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新签名安装之后每次购买商品之后三叶草的数目也不会减少，一直是9999。</p><h3 id="修改抽奖券"><a href="#修改抽奖券" class="headerlink" title="修改抽奖券"></a>修改抽奖券</h3><p>修改抽奖券也是同样的套路，搜索<code>足</code>找到目标代码，其实刚刚搜索的时候就已经看到了。</p><p><img src="http://img.cdn.blogfshare.com/hexo/device-2018-02-03-205515.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (SuperGameMaster.TicketStock() &lt; 5)</span><br><span class="line">&#123;</span><br><span class="line">    ConfilmPanel confilm = this.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;();</span><br><span class="line">    confilm.OpenPanel(&quot;ふくびき券が足りません&quot;);</span><br><span class="line">    confilm.ResetOnClick_Screen();</span><br><span class="line">    confilm.SetOnClick_Screen(delegate</span><br><span class="line">    &#123;</span><br><span class="line">        confilm.ClosePanel();</span><br><span class="line">    &#125;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击<code>SuperGameMaster.TicketStock()</code>也是差不多的代码同样修改返回数字即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int TicketStock()</span><br><span class="line">&#123;</span><br><span class="line">    return SuperGameMaster.saveData.ticket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int TicketStock()</span><br><span class="line">&#123;</span><br><span class="line">    return 9999;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改抽奖概率"><a href="#修改抽奖概率" class="headerlink" title="修改抽奖概率"></a>修改抽奖概率</h3><p>每次抽奖都是抽到白球就不是很开心了，怎么能够提供抽奖的概率呢？抽到其它颜色的球的时候会提示:</p><p><img src="http://img.cdn.blogfshare.com/hexo/device-2018-02-03-210802.png" alt=""></p><p>搜索<code>白玉</code>找到如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static readonly Dictionary&lt;Rank, string&gt; PrizeBallName = new Dictionary&lt;Rank, string&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.White,</span><br><span class="line">        &quot;白玉&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Blue,</span><br><span class="line">        &quot;青玉&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Green,</span><br><span class="line">        &quot;緑玉&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Red,</span><br><span class="line">        &quot;赤玉&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Gold,</span><br><span class="line">        &quot;黄玉&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>右键点击<code>PrizeBallName</code>选择分析找到在那里被使用的:</p><p><img src="http://img.cdn.blogfshare.com/hexo/user_prizeballname.jpg" alt=""></p><p>双击<code>PrizeBallName</code>得到如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void PushRollButton()</span><br><span class="line">&#123;</span><br><span class="line">    if (SuperGameMaster.TicketStock() &lt; 5)</span><br><span class="line">    &#123;</span><br><span class="line">        ConfilmPanel confilm = this.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;();</span><br><span class="line">        confilm.OpenPanel(&quot;ふくびき券が足りません&quot;);</span><br><span class="line">        confilm.ResetOnClick_Screen();</span><br><span class="line">        confilm.SetOnClick_Screen(delegate</span><br><span class="line">        &#123;</span><br><span class="line">            confilm.ClosePanel();</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    SuperGameMaster.GetTicket(-5);</span><br><span class="line">    SuperGameMaster.set_FlagAdd(Flag.Type.ROLL_NUM, 1);</span><br><span class="line">    base.GetComponentInParent&lt;UIMaster&gt;().freezeObject(true);</span><br><span class="line">    base.GetComponentInParent&lt;UIMaster&gt;().blockUI(true, new Color(0f, 0f, 0f, 0.3f));</span><br><span class="line">    this.LotteryCheck();</span><br><span class="line">    this.ResultButton.GetComponent&lt;RollResultButton&gt;().CngImage((int)this.result);</span><br><span class="line">    this.ResultButton.GetComponent&lt;RollResultButton&gt;().CngResultText(Define.PrizeBallName[this.result] + &quot;がでました&quot;);</span><br><span class="line">    this.LotteryWheelPanel.GetComponent&lt;LotteryWheelPanel&gt;().OpenPanel(this.result);</span><br><span class="line">    SuperGameMaster.SetTmpRaffleResult((int)this.result);</span><br><span class="line">    SuperGameMaster.SaveData();</span><br><span class="line">    SuperGameMaster.audioMgr.PlaySE(Define.SEDict[&quot;SE_Raffle&quot;]);</span><br><span class="line">    this.BackFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码来看就是刚刚抽奖结果提示的地方，来分析下这个结果是怎么生成的，可以看到<code>Define.PrizeBallName[this.result]</code>这个result决定了抽到的是什么颜色的球，那么看看这个result是在哪里生成的。在当前文件中看到了两处赋值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void LotteryCheck()</span><br><span class="line">&#123;</span><br><span class="line">    int num = Random.Range(0, Define.PrizeBalls[Rank.RankMax]);</span><br><span class="line">    this.result = Rank.White;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int num2 = 0;</span><br><span class="line">    while (i &lt; 5)</span><br><span class="line">    &#123;</span><br><span class="line">        num2 += Define.PrizeBalls[(Rank)i];</span><br><span class="line">        if (num &lt; num2)</span><br><span class="line">        &#123;</span><br><span class="line">            this.result = (Rank)i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ublic void SetTmpResult()</span><br><span class="line">&#123;</span><br><span class="line">    this.result = (Rank)SuperGameMaster.GetTmpRaffleResult();</span><br><span class="line">    this.BackFunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是在<code>UIMaster_raffle.UI_Start</code>中调用的，判断之前的奖品有没有领取，<code>LotteryCheck</code>这个刚好是在显示结果之前调用的，猜测就是这里控制的不同颜色的球的出现概率，分析下这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void LotteryCheck()</span><br><span class="line">&#123;</span><br><span class="line">    int num = Random.Range(0, Define.PrizeBalls[Rank.RankMax]); //Rank.RankMax是5，Define.PrizeBalls[Rank.RankMax]是100，从0-100随机生成一个数</span><br><span class="line">    this.result = Rank.White;  //默认都是白色的球</span><br><span class="line">    int i = 0;</span><br><span class="line">    int num2 = 0;</span><br><span class="line">    while (i &lt; 5)</span><br><span class="line">    &#123;</span><br><span class="line">        num2 += Define.PrizeBalls[(Rank)i];  //根据PrizeBalls的值小于60是白色，大于等于60并且少于87是蓝色，大于等于87小于96是绿色，大于等于96小于99是红色，大于等于99是金色。</span><br><span class="line">        if (num &lt; num2)</span><br><span class="line">        &#123;</span><br><span class="line">            this.result = (Rank)i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码分析PrizeBalls中就定义了不同颜色的球摇出概率:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static readonly Dictionary&lt;Rank, int&gt; PrizeBalls = new Dictionary&lt;Rank, int&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.White,</span><br><span class="line">        60</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Blue,</span><br><span class="line">        27</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Green,</span><br><span class="line">        9</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Red,</span><br><span class="line">        3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Gold,</span><br><span class="line">        1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.RankMax,</span><br><span class="line">        100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以直接修改这里的数字就控制摇出的概率了，比如不出白球，其它球的概率都一样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static readonly Dictionary&lt;Rank, int&gt; PrizeBalls = new Dictionary&lt;Rank, int&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.White,</span><br><span class="line">        0   //不存在白球</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Blue,</span><br><span class="line">        25</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Green,</span><br><span class="line">        25</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Red,</span><br><span class="line">        25</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.Gold,</span><br><span class="line">        25</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        Rank.RankMax,</span><br><span class="line">        100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="修改农场四叶草数"><a href="#修改农场四叶草数" class="headerlink" title="修改农场四叶草数"></a>修改农场四叶草数</h3><p>农场里面大部分都是三叶草、四叶草的概率是很小的，那么怎么修改这个呢？在界面上面好像不太好找关联，先试试搜索三叶草的英语<code>clover</code>，点击<code>checkCloverCreate</code>看起来就是控制生成的函数:</p><p><img src="http://img.cdn.blogfshare.com/hexo/clover_create.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public void checkCloverCreate()</span><br><span class="line">&#123;</span><br><span class="line">    this.cloverList = SuperGameMaster.GetCloverList();</span><br><span class="line">    bool flag = false;</span><br><span class="line">    if (this.cloverList.Count == 0)  </span><br><span class="line">    &#123;</span><br><span class="line">        flag = true;</span><br><span class="line">        //这句话翻译的意思就是:有了四叶草的初期化标志。四叶草生成</span><br><span class="line">        //也就是flag为true的时候会生成四叶草</span><br><span class="line">        Debug.Log(&quot;[CloverFarm] クローバーの初期化フラグが立ちました。四葉を生成します&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.cloverList.Count &lt; this.cloverMax)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(string.Concat(new object[]</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;[CloverFarm] クローバーの数を調整します：&quot;,</span><br><span class="line">            this.cloverList.Count,</span><br><span class="line">            &quot; &gt; &quot;,</span><br><span class="line">            this.cloverMax</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    while (this.cloverList.Count &lt; this.cloverMax)</span><br><span class="line">    &#123;</span><br><span class="line">        CloverDataFormat cloverDataFormat = new CloverDataFormat();</span><br><span class="line">        cloverDataFormat.lastHarvest = new DateTime(1970, 1, 1);</span><br><span class="line">        cloverDataFormat.timeSpanSec = -this.cloverList.Count - 1;</span><br><span class="line">        cloverDataFormat.newFlag = true;</span><br><span class="line">        this.cloverList.Add(cloverDataFormat);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.cloverList.Count &gt; this.cloverMax)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(string.Concat(new object[]</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;[CloverFarm] クローバーの数を調整します：&quot;,</span><br><span class="line">            this.cloverList.Count,</span><br><span class="line">            &quot; &gt; &quot;,</span><br><span class="line">            this.cloverMax</span><br><span class="line">        &#125;));</span><br><span class="line">        this.cloverList.RemoveRange(this.cloverMax - 1, this.cloverList.Count - this.cloverMax);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;GameObject&gt; list = new List&lt;GameObject&gt;();</span><br><span class="line">    for (int i = 0; i &lt; this.cloverList.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!this.cloverList[i].newFlag &amp;&amp; this.cloverList[i].timeSpanSec &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            list.Add(this.LoadCloverObject(i, this.cloverList[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int num = 0;</span><br><span class="line">    for (int j = 0; j &lt; this.cloverList.Count; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this.cloverList[j].newFlag)</span><br><span class="line">        &#123;</span><br><span class="line">            //这里根据flag调用不同的函数，</span><br><span class="line">            if (!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                //生成三叶草</span><br><span class="line">                list.Add(this.NewCloverObject(j, this.cloverList[j], list));</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //生成四叶草，不同的是第四个参数为true</span><br><span class="line">                list.Add(this.NewCloverObject(j, this.cloverList[j], list, true));</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">            this.cloverList[j].x = list[list.Count - 1].transform.localPosition.x;</span><br><span class="line">            this.cloverList[j].y = list[list.Count - 1].transform.localPosition.y;</span><br><span class="line">            Clover component = list[list.Count - 1].GetComponent&lt;Clover&gt;();</span><br><span class="line">            this.cloverList[j].element = component.element;</span><br><span class="line">            this.cloverList[j].spriteNum = component.spriteNum;</span><br><span class="line">            this.cloverList[j].point = component.point;</span><br><span class="line">            this.cloverList[j].newFlag = false;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    foreach (GameObject gameObject in list)</span><br><span class="line">    &#123;</span><br><span class="line">        int num2 = this.cloverOrderInLayer;</span><br><span class="line">        foreach (GameObject gameObject2 in list)</span><br><span class="line">        &#123;</span><br><span class="line">            if (gameObject.transform.position.y &lt; gameObject2.transform.position.y)</span><br><span class="line">            &#123;</span><br><span class="line">                num2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gameObject.GetComponent&lt;SpriteRenderer&gt;().sortingOrder = num2;</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(string.Concat(new object[]</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;[CloverFarm] クローバー生成完了：&quot;,</span><br><span class="line">        list.Count,</span><br><span class="line">        &quot;\u3000/ (新規：&quot;,</span><br><span class="line">        num,</span><br><span class="line">        &quot;)&quot;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看<code>this.NewCloverObject(j, this.cloverList[j], list)</code>这个内部调用就是四个参数的，只不过第四个参数是false:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public GameObject NewCloverObject(int index, CloverDataFormat cloverData, List&lt;GameObject&gt; cloversObj)</span><br><span class="line">&#123;</span><br><span class="line">    return this.NewCloverObject(index, cloverData, cloversObj, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是第四个参数为true就是四叶草，点进去看看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public GameObject NewCloverObject(int index, CloverDataFormat cloverData, List&lt;GameObject&gt; cloversObj, bool fourLeafFlag)</span><br><span class="line">&#123;</span><br><span class="line">    Vector2 size = base.GetComponent&lt;BoxCollider2D&gt;().size;</span><br><span class="line">    PolygonCollider2D component = base.GetComponent&lt;PolygonCollider2D&gt;();</span><br><span class="line">    Vector2 vector;</span><br><span class="line">    vector..ctor(base.GetComponent&lt;BoxCollider2D&gt;().offset.x - size.x / 2f, base.GetComponent&lt;BoxCollider2D&gt;().offset.y - size.y / 2f);</span><br><span class="line">    int num = 0;</span><br><span class="line">    bool flag;</span><br><span class="line">    Vector3 vector2;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        flag = false;</span><br><span class="line">        vector2 = new Vector2(vector.x + Random.Range(0f, size.x), vector.y + Random.Range(0f, size.y));</span><br><span class="line">        if (!component.OverlapPoint(vector2 + base.transform.position))</span><br><span class="line">        &#123;</span><br><span class="line">            flag = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; cloversObj.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector2 size2 = cloversObj[i].GetComponent&lt;BoxCollider2D&gt;().size;</span><br><span class="line">                if (Mathf.Abs(vector2.x - cloversObj[i].transform.localPosition.x) &lt; size2.x / 2f &amp;&amp; Mathf.Abs(vector2.y - cloversObj[i].transform.localPosition.y) &lt; size2.y / 4f)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            if (num &gt;= 100)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (flag);</span><br><span class="line">    GameObject gameObject = Object.Instantiate&lt;GameObject&gt;(this.basePrefab, Vector3.zero, Quaternion.identity);</span><br><span class="line">    CloverDataFormat cloverDataFormat = new CloverDataFormat();</span><br><span class="line">    cloverDataFormat.point = 1;</span><br><span class="line">    cloverDataFormat.element = 0;</span><br><span class="line">    //如果第四个参数是false，这里就是四叶草生成的概率，是fourLeaf_percent是1那这个概率就是1/100</span><br><span class="line">    if (Random.Range(0f, 10000f) &lt; this.fourLeaf_percent * 100f)</span><br><span class="line">    &#123;</span><br><span class="line">        cloverDataFormat.element = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果传了这个参数为true直接生成四叶草</span><br><span class="line">    if (fourLeafFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        cloverDataFormat.element = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int element = cloverDataFormat.element;</span><br><span class="line">    if (element != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (element == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            cloverDataFormat.spriteNum = Random.Range(0, this.fourCloverSprite.Length);</span><br><span class="line">            gameObject.GetComponent&lt;SpriteRenderer&gt;().sprite = this.fourCloverSprite[cloverDataFormat.spriteNum];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cloverDataFormat.spriteNum = Random.Range(0, this.cloverSprite.Length);</span><br><span class="line">        gameObject.GetComponent&lt;SpriteRenderer&gt;().sprite = this.cloverSprite[cloverDataFormat.spriteNum];</span><br><span class="line">    &#125;</span><br><span class="line">    gameObject.GetComponent&lt;Clover&gt;().SetCloverData(index, cloverDataFormat);</span><br><span class="line">    gameObject.transform.parent = base.transform;</span><br><span class="line">    gameObject.transform.localScale = Vector3.one;</span><br><span class="line">    gameObject.transform.localPosition = vector2;</span><br><span class="line">    return gameObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里既可以修改四叶草生成的概率也可以修改<code>fourLeafFlag</code>这个为true，第一种方式和上面一样，看看第二种。右键<code>fourLeafFlag</code>编辑IL指令:</p><p><img src="http://img.cdn.blogfshare.com/hexo/fourleaf_il_code.jpg" alt=""></p><p>这里首先取<code>fourLeafFlag</code>判断然后跳转，所以修改为true即可。修改<code>ldarg.s fourLeafFlag</code>为<code>ldc.i4 1</code>，修改后的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true)</span><br><span class="line">&#123;</span><br><span class="line">    cloverDataFormat.element = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天修改的部分就到这里了，其它的大家可以自己去尝试，总结下分析Unity3D游戏过程，当然这篇文章讲的是最简单的情况，还有使用保护将dll脚本加密的，就需要hook函数或者从内存查找dump，还有通过C#脚本调用lua脚本来实现的，逻辑在lua脚本里面，lua脚本又加密了的情况等等。那么没保护的情况的话，一般可以从界面显示搜索来分析，然后根据一些特定单词去搜索查找关键代码部分。这篇主要是Android上面使用mono模式的情况，如果是使用IL2CPP的话比如iOS上面，C#脚本都转成了cpp文件c代码的形式的话分析起来就会麻烦很多，后面会有在iOS上面修改代码以及在非越狱平台也能修改运行的文章。</p>]]></content>
    
    <summary type="html">
    
      尝试Android Unity3D游戏逆向，C#脚本分析与修改，以当前流行的旅行的青蛙为例。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>一条命令完成砸壳</title>
    <link href="http://www.alonemonkey.com/2018/01/30/frida-ios-dump/"/>
    <id>http://www.alonemonkey.com/2018/01/30/frida-ios-dump/</id>
    <published>2018-01-29T16:00:00.000Z</published>
    <updated>2018-01-30T16:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最早的砸壳工具是stefanesser写的<a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="external">dumpdecrypted</a>，通过手动注入然后启动应用程序在内存进行dump解密后的内存实现砸壳，这种砸壳只能砸主App可执行文件。</p><p>对于应用程序里面存在framework的情况可以使用conradev的<a href="https://github.com/conradev/dumpdecrypted" target="_blank" rel="external">dumpdecrypted</a>，通过_dyld_register_func_for_add_image注册回调对每个模块进行dump解密。</p><p>但是这种还是需要拷贝dumpdecrypted.dylib，然后找路径什么的，还是挺麻烦的。所以笔者干脆放到<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="external">MonkeyDev</a>模板变成一个tweak的形式<a href="https://github.com/AloneMonkey/dumpdecrypted" target="_blank" rel="external">dumpdecrypted</a>，这样填写目标bundle id然后看日志把文件拷贝出来就可以了。</p><p>但是还是很麻烦，需要拷贝文件自己还原ipa，然后有了KJCracks的<a href="https://github.com/KJCracks/Clutch" target="_blank" rel="external">Clutch</a>通过posix_spawnp创建进程然后dump直接生成ipa包在设备，可以说是很方便了。这个是工具在使用的时候大部分应用会出报错，此外生成的包还需要自己拷贝。</p><h3 id="一键dump"><a href="#一键dump" class="headerlink" title="一键dump"></a>一键dump</h3><p>人都是想偷懒的，于是便有了本文将要介绍的<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="external">frida-ios-dump</a>，该工具基于frida提供的强大功能通过注入js实现内存dump然后通过python自动拷贝到电脑生成ipa文件，通过以下方式配置完成之后真的就是一条命令砸壳。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>首先上面也说了该工具基于frida，所以首先要在手机和mac电脑上面安装frida，安装方式参数官网的文档:<a href="https://www.frida.re/docs/home/" target="_blank" rel="external">https://www.frida.re/docs/home/</a></p><p>如果mac端报如下错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Uninstalling a distutils installed project (six) has been deprecated and will be removed in a future version. This is due to the fact that uninstalling a distutils project will only partially uninstall the project.</div></pre></td></tr></table></figure><p>使用如下命令安装即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install frida –upgrade –ignore-installed six</div></pre></td></tr></table></figure><p>然后将越狱设备通过USB连上电脑进行端口映射:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iproxy 2222 22</div></pre></td></tr></table></figure><p>到此环境就配置好了，接下来就可以一键砸壳了！ (另当前python基于2.x的语法，先切换到python 2.x的环境</p><h3 id="一键砸壳"><a href="#一键砸壳" class="headerlink" title="一键砸壳"></a>一键砸壳</h3><p>最简单的方式直接使用./dump + 应用显示的名字即可，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">➜  frida-ios-dump ./dump.py 微信</div><div class="line">open target app......</div><div class="line">Waiting for the application to open......</div><div class="line">start dump target app......</div><div class="line">start dump /var/containers/Bundle/Application/6665AA28-68CC-4845-8610-7010E96061C6/WeChat.app/WeChat</div><div class="line">WeChat                                        100%   68MB  11.4MB/s   00:05</div><div class="line">start dump /private/var/containers/Bundle/Application/6665AA28-68CC-4845-8610-7010E96061C6/WeChat.app/Frameworks/WCDB.framework/WCDB</div><div class="line">WCDB                                          100% 2555KB  11.0MB/s   00:00</div><div class="line">start dump /private/var/containers/Bundle/Application/6665AA28-68CC-4845-8610-7010E96061C6/WeChat.app/Frameworks/MMCommon.framework/MMCommon</div><div class="line">MMCommon                                      100%  979KB  10.6MB/s   00:00</div><div class="line">start dump /private/var/containers/Bundle/Application/6665AA28-68CC-4845-8610-7010E96061C6/WeChat.app/Frameworks/MultiMedia.framework/MultiMedia</div><div class="line">MultiMedia                                    100% 6801KB  11.1MB/s   00:00</div><div class="line">start dump /private/var/containers/Bundle/Application/6665AA28-68CC-4845-8610-7010E96061C6/WeChat.app/Frameworks/mars.framework/mars</div><div class="line">mars                                          100% 7462KB  11.1MB/s   00:00</div><div class="line">AppIcon60x60@2x.png                           100% 2253   230.9KB/s   00:00</div><div class="line">AppIcon60x60@3x.png                           100% 4334   834.8KB/s   00:00</div><div class="line">AppIcon76x76@2x~ipad.png                      100% 2659   620.6KB/s   00:00</div><div class="line">AppIcon76x76~ipad.png                         100% 1523   358.0KB/s   00:00</div><div class="line">AppIcon83.5x83.5@2x~ipad.png                  100% 2725   568.9KB/s   00:00</div><div class="line">Assets.car                                    100%   10MB  11.1MB/s   00:00</div><div class="line">.......</div><div class="line">AppIntentVocabulary.plist                     100%  197    52.9KB/s   00:00</div><div class="line">AppIntentVocabulary.plist                     100%  167    43.9KB/s   00:00</div><div class="line">AppIntentVocabulary.plist                     100%  187    50.2KB/s   00:00</div><div class="line">InfoPlist.strings                             100% 1720   416.4KB/s   00:00</div><div class="line">TipsPressTalk@2x.png                          100%   14KB   2.2MB/s   00:00</div><div class="line">mm.strings                                    100%  404KB  10.2MB/s   00:00</div><div class="line">network_setting.html                          100% 1695   450.4KB/s   00:00</div><div class="line">InfoPlist.strings                             100% 1822   454.1KB/s   00:00</div><div class="line">mm.strings                                    100%  409KB  10.2MB/s   00:00</div><div class="line">network_setting.html                          100% 1819   477.5KB/s   00:00</div><div class="line">InfoPlist.strings                             100% 1814   466.8KB/s   00:00</div><div class="line">mm.strings                                    100%  409KB  10.3MB/s   00:00</div><div class="line">network_setting.html                          100% 1819   404.9KB/s   00:00</div></pre></td></tr></table></figure><p>如果存在应用名称重复了怎么办呢？没关系首先使用如下命令查看安装的应用的名字和bundle id:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">➜  frida-ios-dump git:(master) ✗ ./dump.py -l</div><div class="line">  PID  Name                       Identifier</div><div class="line">-----  -------------------------  ----------------------------------------</div><div class="line"> 9661  App Store                  com.apple.AppStore</div><div class="line">16977  Moment                     com.kevinholesh.Moment</div><div class="line"> 1311  Safari                     com.apple.mobilesafari</div><div class="line">16586  信息                         com.apple.MobileSMS</div><div class="line"> 4147  微信                         com.tencent.xin</div><div class="line">10048  相机                         com.apple.camera</div><div class="line"> 7567  设置                         com.apple.Preferences</div><div class="line">    -  CrashReporter              crash-reporter</div><div class="line">    -  Cydia                      com.saurik.Cydia</div><div class="line">    -  通讯录                        com.apple.MobileAddressBook</div><div class="line">    -  邮件                         com.apple.mobilemail</div><div class="line">    -  音乐                         com.apple.Music</div><div class="line">    ......</div></pre></td></tr></table></figure><p>然后使用如下命令对指定的bundle id应用进行砸壳即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  frida-ios-dump git:(master) ✗ ./dump.py -b com.tencent.xin</div></pre></td></tr></table></figure><p>等待自动砸壳传输完成之后便会到当前目录生成一个解密后的ipa文件，这个时候赶紧拖到<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="external">MonkeyDev</a>开始逆向之旅吧！</p>]]></content>
    
    <summary type="html">
    
      由于现有砸壳工具太繁琐，笔者基于frida写了一个一条命令就能搞定砸壳的工具。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>动手写一个简单的Mac内核反反调试扩展</title>
    <link href="http://www.alonemonkey.com/2017/11/20/get-start-antidebug-kext/"/>
    <id>http://www.alonemonkey.com/2017/11/20/get-start-antidebug-kext/</id>
    <published>2017-11-19T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Windows上面用户直接操作的东西都是在应用层在权限方面有很多限制，所以大部分的安全厂商和外挂、木马的对抗都是在内核层，看谁在内核层接管的时机最早，隐蔽性最高。使用到的技术有SSDT、Shadow SSDT Hook、DKOM、Inline Hook等等来达到隐藏进程、隐藏端口、隐藏恶意文件、篡改用户行为、键盘网络监控等等、之前的博客也有写过一些相关的技术文章<a href="http://www.blogfshare.com/category/kernel" target="_blank" rel="noopener">Windows内核</a>，感兴趣的可以看看。而在Mac平台虽然这种对抗现在很少，但是我们也可以开发自己的内核扩展模块来达到隐藏进程、隐藏文件、监控网络等操作。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>安装虚拟机和系统: 在编写Windows内核驱动的时候要需要准备环境，当时是通过Windows安装VM虚拟机加上Windbg来调试内核以及内核驱动的。所以Mac内核的调试也可以按照这个套路，笔者的环境是VMware Fusion加macos 10.12。首先安装VMware Fusion这个没什么好说的，然后下载macos 10.12的系统镜像文件<a href="https://plus.google.com/+SysAdminsHowtos/posts/6e98eRghsw1" target="_blank" rel="noopener">下载地址</a>，下完安装并设置网络为桥接模式。</p></li><li><p>安装KDK: 为了调试dev的内核首先要在mac电脑和虚拟机里面的系统安装苹果提供的Kernel Debug Kit，首先要找到调试系统的版本号，点击左上角的苹果-&gt;关于本机-&gt;系统报告-&gt;软件-&gt;系统版本，笔者的是macOS 10.12(16A323)。直接在<a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">这里</a>找到对应的版本下载然后分别在自己的系统和调试系统安装KDK。</p></li><li><p>关闭SIP: 由于后面需要运行未签名的内核扩展所以需要先关闭SIP，在虚拟机开机的时候按Command+R进入恢复模式(要多试几次)，然后在终端输入<code>csrutil disable</code>。顺便把KDK里面的开发内核拷贝命令如下:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /Library/Developer/KDKs/KDKs/KDK_10.12_16A323.kdk/System/Library/Kernels/kernel.development /Systems/Library/Kernels</span><br></pre></td></tr></table></figure><ul><li>设置boot-args: 为了将虚拟机设置成调试模式，需要使用<code>nvram</code>设置<code>boot-args</code>，命令如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nvram boot-args=&quot;debug=0x141 kext-dev-mode=1 kcsuffix=development pmuflags=1 -v&quot;</span><br></pre></td></tr></table></figure><p>debug=0x141: 含义可以在<a href="https://developer.apple.com/library/content/documentation/Darwin/Conceptual/KernelProgramming/build/build.html#//apple_ref/doc/uid/TP30000905-CH221-BABDGEGF" target="_blank" rel="noopener">Kernel Programming Guide</a>找到，这里使用的是(DB_HALT | DB_ARP | DB_LOG_PI_SCRN)</p><p>kext-dev-mode=1: 允许加载未签名kext</p><p>kcsuffix=development: 指定加载上面拷贝的kernel.development</p><p>pmuflags=1: 关闭定时器</p><p>-v: 显示内核加载信息</p><ul><li>清除kext缓存: 先运行<code>uanme -v</code>查看xnu源码版本，然后运行<code>sudo kextcache -invalidate /</code>和<code>sudo reboot</code>清除内核缓存使用新的内核加载然后重启，重启之后被调试的系统会显示IP等待被调试器附加如下图:</li></ul><p><img src="http://img.cdn.blogfshare.com/WX20171120-184118.png" alt=""></p><ul><li>配置源码进行调试: 为了能够在调试的时候能对应到源码，从<a href="https://opensource.apple.com/tarballs/xnu/" target="_blank" rel="noopener">苹果开源代码</a>下载上一步看到的xnu版本的代码放到<code>/Library/Caches/com.apple.xbs/Sources/xnu/</code>下面。并将如下设置加到<code>~/.lldbinit</code>文件:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settings set target.load-script-from-symbol-file true</span><br></pre></td></tr></table></figure><p>然后运行如下命令就可以开始内核调试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lldb /Library/Developer/KDKs/KDK_10.12_16A323.kdk/System/Library/Kernels/kernel.development</span><br><span class="line">(lldb) kdp-remote 虚拟机IP地址</span><br><span class="line">.........</span><br><span class="line">Process 1 stopped</span><br><span class="line">* thread #2, name = &apos;0xffffff800b777b00&apos;, queue = &apos;0x0&apos;, stop reason = signal SIGSTOP</span><br><span class="line">    frame #0: 0xffffff800520ea14 kernel.development`kdp_register_send_receive(send=(IONetworkingFamily`IOKernelDebugger::kdpTransmitDispatcher(void*, unsigned int) at IOKernelDebugger.cpp:369), receive=(IONetworkingFamily`IOKernelDebugger::kdpReceiveDispatcher(void*, unsigned int*, unsigned int) at IOKernelDebugger.cpp:353)) at kdp_udp.c:478 [opt]</span><br><span class="line">   475 kdp_unregister_send_receive(</span><br><span class="line">   476 __unused kdp_send_tsend,</span><br><span class="line">   477 __unused kdp_receive_treceive)</span><br><span class="line">-&gt; 478 &#123;</span><br><span class="line">   479 if (current_debugger == KDP_CUR_DB)</span><br><span class="line">   480 current_debugger = NO_CUR_DB;</span><br><span class="line">   481 kdp_flag &amp;= ~KDP_READY;</span><br><span class="line">Target 0: (kernel.development) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><h3 id="编写内核扩展"><a href="#编写内核扩展" class="headerlink" title="编写内核扩展"></a>编写内核扩展</h3><p>环境准备好之后就可以开始编写和调试内核扩展了，编写的过程还是在自己的系统完成然后在拷贝到虚拟机里面所以最好保证主系统和虚拟机系统大版本一致，首先使用Xcode就可以通过如下方式直接创建内核扩展模块。</p><p><img src="http://img.cdn.blogfshare.com/WX20171120-112922.png" alt=""></p><p>创建出来的工程中会有如下两个函数，分别是驱动加载和卸载时调用的函数，一般用于加载的时候初始化设备驱动、hook函数，卸载的时候还原hook、删除设备驱动等等:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mach/mach_types.h&gt;</span><br><span class="line">#include &lt;libkern/libkern.h&gt;   //printf所在头文件</span><br><span class="line"></span><br><span class="line">kern_return_t HelloWorld_start(kmod_info_t * ki, void *d);</span><br><span class="line">kern_return_t HelloWorld_stop(kmod_info_t *ki, void *d);</span><br><span class="line"></span><br><span class="line">kern_return_t HelloWorld_start(kmod_info_t * ki, void *d)</span><br><span class="line">&#123;</span><br><span class="line">    asm(&quot;int $3&quot;);</span><br><span class="line">    printf(&quot;HelloWorld_start...\n&quot;);</span><br><span class="line">    return KERN_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kern_return_t HelloWorld_stop(kmod_info_t *ki, void *d)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;HelloWorld_stop...\n&quot;);</span><br><span class="line">    return KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别在上面两个函数中使用printf打印输出，在kext中printf函数是在libkern中的，所以要include该头文件。另外为了在加载的时候能找到符号还要在<code>Info.plist</code>中的<code>OSBundleLibraries</code>加上<code>com.apple.kpi.libkern    16.0.0</code>，后面这个版本号可以在被调试的机器上面运行<code>kextstat</code>看到， 在<code>Build Setting</code>设置<code>Debug Information Format</code>为<code>DWARF with DSYM File</code> 即在Debug也生成符号文件方便源码调试， 为了让调试器主动断下来便在模块加载的时候使用<code>int 3</code>主要触发断点。</p><p>使用<code>scp ./HelloWorld.kext xxx@10.xx.xx.xx:/Users/xxxx/Desktop/</code>将生成的<code>HelloWorld.kext</code>文件拷贝到被调试的机器，在这之前需要在被调试机器上的系统偏好设置-共享开启远程登录。最后使用如下命令修改用户组并加载以及卸载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R root:wheel ./HelloWorld.kext</span><br><span class="line">sudo kextload ./HelloWorld.kext</span><br><span class="line">sudo kextutil ./HelloWorld.kext   //可以查看加载出错的原因</span><br><span class="line">sudo kextunload ./HelloWorld.kext</span><br></pre></td></tr></table></figure><p>使用如下命令可以查看在模块中的输出日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg | tail -n 10</span><br></pre></td></tr></table></figure><p>并且在加载的时候会主动触发断点并关联到本地的符号文件对应的源码的对应行如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Loading 1 kext modules . done.</span><br><span class="line">Process 1 stopped</span><br><span class="line">* thread #17, name = &apos;0xffffff801a9be1a0&apos;, queue = &apos;0x0&apos;, stop reason = EXC_BREAKPOINT (code=3, subcode=0x0)</span><br><span class="line">    frame #0: 0xffffff7f95c61f21 HelloWorld`HelloWorld_start(ki=0xffffff7f95c62000, d=0x0000000000000000) at HelloWorld.c:17</span><br><span class="line">   14</span><br><span class="line">   15  kern_return_t HelloWorld_start(kmod_info_t * ki, void *d)</span><br><span class="line">   16  &#123;</span><br><span class="line">-&gt; 17      asm(&quot;int $3&quot;);</span><br><span class="line">   18      printf(&quot;HelloWorld_start...\n&quot;);</span><br><span class="line">   19      return KERN_SUCCESS;</span><br><span class="line">   20  &#125;</span><br><span class="line">Target 0: (kernel.development) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><h3 id="内核反调试"><a href="#内核反调试" class="headerlink" title="内核反调试"></a>内核反调试</h3><p>之前在<a href="http://www.alonemonkey.com/2017/05/25/antiantidebug/">关于反调试&amp;反反调试那些事</a>中讲到一些反调试的方法和过反调试的方法，但是在应用层的话需要对每个应用都进行patch hook，而通过内核扩展模块可以直接从内核模块来接管系统调用针对调试检测和禁止附加的系统调用进行修改就行了。</p><p>我们知道在Windows平台有一个叫SSDT的东西，SSDT 的全称是 System Services Descriptor Table，系统服务描述符表，里面保存 Windows 系统服务地址的数组，通过修改该数组的函数地址就可以达到hook的效果，而在XNU中也有一个系统调用的表叫sysent，在<code>bsd/sys/sysent.h</code>可以找到其定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sysent &#123;/* system call table */</span><br><span class="line">sy_call_t*sy_call;/* implementing function */</span><br><span class="line">#if CONFIG_REQUIRES_U32_MUNGING || (__arm__ &amp;&amp; (__BIGGEST_ALIGNMENT__ &gt; 4))</span><br><span class="line">sy_munge_t*sy_arg_munge32; /* system call arguments munger for 32-bit process */</span><br><span class="line">#endif</span><br><span class="line">int32_tsy_return_type; /* system call return types */</span><br><span class="line">int16_tsy_narg;/* number of args */</span><br><span class="line">uint16_tsy_arg_bytes;/* Total size of arguments in bytes for</span><br><span class="line"> * 32-bit system calls</span><br><span class="line"> */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以如果能够找到这个表在内存中的位置然后修改其中ptrace和sysctl在表中对应的sy_call就可以接管ptrace和sysctl的调用了，但是因为这个符号不导出只能从内核文件分析找到在内存在模块加载的基地址然后加上文件中对应的位置确定sysent。首先使用IDA打开文件<code>/Library/Developer/KDKs/KDK_10.12_16A323.kdk/System/Library/Kernels/kernel.development</code>搜索找到符号<code>sysent</code>位于<code>__constdata</code>处，根据上面的结构体将IDA显示结果手动解析如下图所示:</p><p><img src="http://img.cdn.blogfshare.com/WX20171120-172025.png" alt=""></p><p>可以通过搜索sysent表中前面几个符号的地址来确定sysent在<code>__constdata</code>的位置，由于KASLR所以首先要找到内核模块加载后在内存中的基地址，在10.11之后可以通过<code>vm_kernel_unslide_or_perm_external</code>来计算偏移，之前的话可以在内存中搜索文件头:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_offset_t func_address = (vm_offset_t) vm_kernel_unslide_or_perm_external;</span><br><span class="line">vm_offset_t func_address_unslid = 0;</span><br><span class="line">vm_kernel_unslide_or_perm_external(func_address, &amp;func_address_unslid);</span><br><span class="line">g_kernel_slide = func_address - func_address_unslid;</span><br></pre></td></tr></table></figure><p>得到内核加载在内存中的偏移之后剩下就是macho文件格式的解析与处理，首先获取<code>__CONST,__constdata</code>并该section中找<code>sysent</code>所在的位置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">struct sysent * find_sysent_table()&#123;</span><br><span class="line">    if (g_sysent_table) &#123;</span><br><span class="line">        return g_sysent_table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mach_header_t* kernel_header = find_kernel_header();</span><br><span class="line"></span><br><span class="line">    if (!kernel_header) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The first three entries of the sysent table point to these functions.</span><br><span class="line">    sy_call_t *nosys = (sy_call_t *) kernel_find_symbol(&quot;_nosys&quot;);</span><br><span class="line">    sy_call_t *exit = (sy_call_t *) kernel_find_symbol(&quot;_exit&quot;);</span><br><span class="line">    sy_call_t *fork = (sy_call_t *) kernel_find_symbol(&quot;_fork&quot;);</span><br><span class="line">    if (!nosys || !exit || !fork) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char *data_segment_name;</span><br><span class="line">    const char *const_section_name;</span><br><span class="line">    if (macOS_Sierra()) &#123;</span><br><span class="line">        data_segment_name = &quot;__CONST&quot;;</span><br><span class="line">        const_section_name = &quot;__constdata&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        data_segment_name = &quot;__DATA&quot;;</span><br><span class="line">        const_section_name = &quot;__const&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    section_t* section = macho_find_section(kernel_header, data_segment_name, const_section_name);</span><br><span class="line"></span><br><span class="line">    if(!section)&#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vm_offset_t offset;</span><br><span class="line">    for (offset = 0; offset &lt; section-&gt;size; offset += 16) &#123;</span><br><span class="line">        struct sysent *table = (struct sysent *) (section-&gt;addr + offset);</span><br><span class="line">        if (table-&gt;sy_call != nosys) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_offset_t next_entry_offset = sizeof(struct sysent);</span><br><span class="line">        if (OSX_Mavericks()) &#123;</span><br><span class="line">            next_entry_offset = sizeof(struct sysent_mavericks);</span><br><span class="line">        &#125;</span><br><span class="line">        struct sysent *next_entry = (struct sysent *)</span><br><span class="line">        ((vm_offset_t)table + next_entry_offset);</span><br><span class="line">        if (next_entry-&gt;sy_call != exit) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        next_entry = (struct sysent *)</span><br><span class="line">        ((vm_offset_t)next_entry + next_entry_offset);</span><br><span class="line">        if (next_entry-&gt;sy_call != fork) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g_sysent_table = table;</span><br><span class="line">        return g_sysent_table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到<code>sysent</code>之后就可以直接保存原来的<code>sy_call</code>然后替换<code>sy_call</code>的地址为我们自己的实现就可以接管系统调用了，由于<code>__CONST,__constdata</code>默认是只读的所以写之前要先关闭写保护写完之后再还原:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t anti_ptrace(int cmd)&#123;</span><br><span class="line">    /* Mountain Lion (10.8+) moved sysent[] to read-only section */</span><br><span class="line">    kwrite_on();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * we check if the syscalls had been already assigned, because we get kernel panic if we overwrite the syscall with same function</span><br><span class="line">     */</span><br><span class="line">    if(cmd == DISABLE &amp;&amp; g_sysent_table[SYS_ptrace].sy_call != (sy_call_t *)sys_ptrace)&#123;</span><br><span class="line">        if(sys_ptrace != NULL)&#123;</span><br><span class="line">            /* restore pointer to the original function */</span><br><span class="line">            g_sysent_table[SYS_ptrace].sy_call = (sy_call_t *)sys_ptrace;</span><br><span class="line"></span><br><span class="line">            /* remove the flag that indicates the hooked status */</span><br><span class="line">            g_hooked_functions &amp;= ~HK_PTRACE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(cmd == ENABLE &amp;&amp; !(g_hooked_functions &amp; HK_PTRACE))&#123;</span><br><span class="line">        /* save address of the real function */</span><br><span class="line">        sys_ptrace = (void *)g_sysent_table[SYS_ptrace].sy_call;</span><br><span class="line"></span><br><span class="line">        /* hook the syscall by replacing the pointer in sysent */</span><br><span class="line">        g_sysent_table[SYS_ptrace].sy_call = (sy_call_t *)ar_ptrace;</span><br><span class="line"></span><br><span class="line">        /* we set our global variable g_hooked_functions to know this function has been hooked */</span><br><span class="line">        g_hooked_functions |= HK_PTRACE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kwrite_off();</span><br><span class="line"></span><br><span class="line">    return KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后编译加载kext然后使用如下代码测试效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line">#import &lt;sys/sysctl.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef PT_DENY_ATTACH</span><br><span class="line">#define PT_DENY_ATTACH 31</span><br><span class="line">#endif</span><br><span class="line">typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);</span><br><span class="line"></span><br><span class="line">BOOL isDebuggerPresent()&#123;</span><br><span class="line">    int name[4];                </span><br><span class="line"></span><br><span class="line">    struct kinfo_proc info;     </span><br><span class="line">    size_t info_size = sizeof(info);</span><br><span class="line"></span><br><span class="line">    info.kp_proc.p_flag = 0;</span><br><span class="line"></span><br><span class="line">    name[0] = CTL_KERN;</span><br><span class="line">    name[1] = KERN_PROC;</span><br><span class="line">    name[2] = KERN_PROC_PID;</span><br><span class="line">    name[3] = getpid();</span><br><span class="line"></span><br><span class="line">    if(sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0) == -1)&#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        void *handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);</span><br><span class="line">        ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, &quot;ptrace&quot;);</span><br><span class="line">        ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;pass ptrace&quot;);</span><br><span class="line"></span><br><span class="line">        if(isDebuggerPresent())&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;pass sysctl&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用lldb调试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lldb ./demo</span><br><span class="line">(lldb) target create &quot;./demo&quot;</span><br><span class="line">Current executable set to &apos;./demo&apos; (x86_64).</span><br><span class="line">2017-11-18 14:06:22.370273 demo[403:4277] pass ptrace</span><br><span class="line">2017-11-18 14:06:22.370346 demo[403:4277] pass sysctl</span><br><span class="line">Process 403 exited with status = 0 (0x00000000)</span><br></pre></td></tr></table></figure><p>相关代码: <a href="https://github.com/AloneMonkey/MacKext" target="_blank" rel="noopener">MacKext</a></p>]]></content>
    
    <summary type="html">
    
      本文主要是在现在有的一些文章和代码的基础上面笔者自己的一个尝试，了解Mac下kext开发的流程
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>使用 CocoaPods 给微信集成 SDK 打印收发消息</title>
    <link href="http://www.alonemonkey.com/2017/07/26/cocoapods-wechat-message/"/>
    <id>http://www.alonemonkey.com/2017/07/26/cocoapods-wechat-message/</id>
    <published>2017-07-25T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>笔者本身是一个iOS逆向的爱好者，曾在使用iOSOpenDev在Xcode开发越狱插件的时候，由于工具已经好几年没有更新，安装和使用起来都会诸多问题，所以最初笔者只是想改良iOSOpenDev的兼容问题，后面在开发中不断冒出新的idea，并在工具中实现了这些想法，所以就有了本文将要给大家强烈推荐的工具<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a>。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>在使用之前，大家关心的都是它的功能，可以做什么。那么MonkeyDev这个工具可以做什么呢？总结来说可以做如下这些事情:</p><ul><li>可以使用Xcode开发CaptainHook Tweak、Logos Tweak 和 Command-line Tool，在越狱机器开发插件，这是原来iOSOpenDev功能的迁移和改进。</li><li>只需拖入一个砸壳应用，自动集成Reveal、Cycript和注入的动态库并重签名安装到非越狱机器。</li><li>支持调试自己编写的动态库和第三方App</li><li>支持通过CocoaPods第三方应用集成SDK以及非越狱插件，简单来说就是通过CocoaPods搭建了一个非越狱插件商店。</li></ul><p>大概了解了之后下面就通过具体的实际应用来体会它的强大之处吧。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>在使用之前首先是环境的配置，如果配置不对的话，可能会出一些奇怪的问题，你也可以结合<a href="https://github.com/AloneMonkey/MonkeyDev/wiki" target="_blank" rel="noopener">Wiki</a>来操作。</p><ul><li>安装最新的theos</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/theos/theos.git /opt/theos</span><br></pre></td></tr></table></figure><ul><li>安装ldid</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ldid</span><br></pre></td></tr></table></figure><ul><li>如果是用于越狱开发，需要配置免密码登录越狱设备，如果没有越狱机器可以跳过这步。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &apos;&apos;</span><br><span class="line">ssh-copy-id -i /Users/username/.ssh/id_rsa root@ip</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>你可以通过如下命令选择指定的Xcode进行安装，也可以默认安装。</p><ul><li>指定Xcode安装:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xcode-select -s /Applications/Xcode-xxx.app</span><br></pre></td></tr></table></figure><ul><li>默认安装的Xcode:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select -p</span><br></pre></td></tr></table></figure><ul><li>执行安装命令:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AloneMonkey/MonkeyDev.git</span><br><span class="line">cd MonkeyDev/bin</span><br><span class="line">sudo ./md-install</span><br></pre></td></tr></table></figure><ul><li>如需卸载，执行卸载命令:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./md-uninstall</span><br></pre></td></tr></table></figure><ul><li>如需更新，执行更新命令:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./md-update</span><br></pre></td></tr></table></figure><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><p>安装完成之后，打开Xcode，点击<code>File - New - Project...</code>，选择iOS滑动到最下方可以看到MonkeyDev提供的模块:</p><p><img src="http://img.cdn.blogfshare.com/WX20170713-185817.png" alt="image"></p><p>介绍下这几个模块的用途:</p><h4 id="越狱模块"><a href="#越狱模块" class="headerlink" title="越狱模块"></a>越狱模块</h4><ul><li>CaptainHook Tweak</li></ul><p>使用<a href="https://github.com/rpetrich/CaptainHook/" target="_blank" rel="noopener">CaptainHook</a>提供的头文件进行OC函数的Hook，以及属性的获取。</p><ul><li>Logos Tweak</li></ul><p>使用<a href="https://github.com/theos/theos/wiki/Installation" target="_blank" rel="noopener">theos</a>提供的logify.pl工具将<em>.xm文件转成</em>.mm文件进行编译，默认集成CydiaSubstrate，可以使用<code>MSHookMessageEx</code>和<code>MSHookFunction</code>来Hook OC函数和指定地址。</p><ul><li>Command-line Tool</li></ul><p>可以直接创建运行于越狱设备的命令行工具</p><h4 id="非越狱模块"><a href="#非越狱模块" class="headerlink" title="非越狱模块"></a>非越狱模块</h4><ul><li>MonkeyApp</li></ul><p>这是自动给第三方应用集成Reveal、Cycript和注入dylib的模块，支持调试dylib和第三方应用，支持Pod给第三放应用集成SDK，只需要准备一个砸壳后的ipa或者app文件即可。</p><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>关于CaptainHook Tweak、Logos Tweak 和 Command-line Tool的使用这里不再介绍，有问题可以查看项目<a href="https://github.com/AloneMonkey/MonkeyDev/wiki/" target="_blank" rel="noopener">Wiki</a></p><p>下面主要介绍MonkeyApp的使用，开启你的非越狱插件开发之旅~ </p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>在开始使用前，需要准备一个砸壳后的应用，可以使用越狱手机砸壳，然后获取ipa或app，没有越狱手机直接从某助手下载越狱应用即可。</p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>点击<code>File - New - Project...</code>创建iOS项目，选择<code>MonkeyApp</code>。</p><p><img src="http://img.cdn.blogfshare.com/WX20170726-141833.png" alt="image"></p><p>创建完成之后，你会得到一个这样的工程:</p><p><img src="http://img.cdn.blogfshare.com/script_1499873471085.png" alt=""></p><p>这里我创建的项目名字就是<code>MonkeyApp</code>，所以下面对应的都是<code>MonkeyApp</code>，你自己创建的由你的项目名字而定! 另外Xcode 8需要另外在App里面增加动态库的依赖，如下:</p><p><img src="http://img.cdn.blogfshare.com/WX20170726-142910.png" alt=""></p><p><code>MonkeyAppDylib</code>这个是将被注入目标App的动态库，你自己要hook的代码可以在<code>MonkeyAppDylib.m</code>文件里面写，我在里面写了一些Demo代码，直接运行即可看到效果，支持OC runtime的HOOK，C函数的fishhook。</p><p><code>AntiAntiDebug</code>这个里面是反反调试的代码。</p><p><code>fishhook</code>这个是自动集成的fishhook模块。</p><p>下面Framewroks已经自动集成了<code>Reveal.framework</code>和<code>Cycript.framework</code>。</p><h4 id="拖入砸壳应用编译"><a href="#拖入砸壳应用编译" class="headerlink" title="拖入砸壳应用编译"></a>拖入砸壳应用编译</h4><p>打开某助手选择应用游戏里面的越狱应用，下载一个应用就是已经砸壳了的。</p><p>然后打开TargetApp目录，拷贝ipa文件到当前目录下面，如下图所示:</p><p><img src="http://img.cdn.blogfshare.com/WX20170726-143653.png" alt=""></p><p><img src="http://img.cdn.blogfshare.com/WX20170726-143738.png" alt=""></p><p>然后点击运行即可，运行后可以从控制台看到动态库已经注入成功，Reveal已经成功加载！当然手机上面也运行起来了！</p><p><img src="http://img.cdn.blogfshare.com/WX20170726-144848.png" alt=""></p><p>打开Mac上的Reveal即可查看应用的界面结构啦！如下图所示:</p><p><img src="http://img.cdn.blogfshare.com/6911501055198_.pic_hd.jpg" alt=""></p><p>默认还集成了Cycript，从<a href="http://www.cycript.org/" target="_blank" rel="noopener">Cycript</a>下载SDK，然后进去SDK目录运行如下命令即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cycript -r iphoneip:6666</span><br></pre></td></tr></table></figure><p><img src="http://img.cdn.blogfshare.com/WX20170726-155633.png" alt=""></p><h3 id="获取微信消息"><a href="#获取微信消息" class="headerlink" title="获取微信消息"></a>获取微信消息</h3><p>下面以一个简单获取微信收到的消息为例，来进一步介绍它的使用，首先打开<code>MonkeyAppDylib.m</code>文件，在最下面写入如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@interface CMessageWrap</span><br><span class="line">@property (nonatomic, strong) NSString* m_nsContent;</span><br><span class="line">@property (nonatomic, assign) NSInteger m_uiMessageType;</span><br><span class="line">@end</span><br><span class="line">CHDeclareClass(CMessageMgr)</span><br><span class="line"></span><br><span class="line">CHMethod2(void, CMessageMgr, AsyncOnAddMsg, NSString*, msg, MsgWrap, CMessageWrap*, msgWrap)&#123;</span><br><span class="line">    NSString* content = [msgWrap m_nsContent];</span><br><span class="line">    if([msgWrap m_uiMessageType] == 1)&#123;</span><br><span class="line">        NSLog(@&quot;收到消息: %@&quot;, content);</span><br><span class="line">    &#125;</span><br><span class="line">    CHSuper2(CMessageMgr, AsyncOnAddMsg, msg, MsgWrap, msgWrap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHConstructor&#123;</span><br><span class="line">    CHLoadLateClass(CMessageMgr);</span><br><span class="line">    CHClassHook2(CMessageMgr, AsyncOnAddMsg, MsgWrap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重新运行就能看到效果了:</p><p><img src="http://img.cdn.blogfshare.com/WX20170726-163128.png" alt=""></p><p>然后就可以愉快的开发非越狱插件了，还可以直接调试!</p><p><img src="http://img.cdn.blogfshare.com/WX20170726-163443.png" alt=""></p><h3 id="使用CocoaPods集成SDK"><a href="#使用CocoaPods集成SDK" class="headerlink" title="使用CocoaPods集成SDK"></a>使用CocoaPods集成SDK</h3><p>MonkeyDev还支持CocoaPods给第三方应用集成SDK，新建Podfile，写入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target &apos;MonkeyAppDylib&apos; do</span><br><span class="line">     pod &apos;FLEX&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里的Target要设置为动态库而不是App，然后执行Pod install。然后将如下选项改回Yes。</p><p><img src="http://img.cdn.blogfshare.com/WX20170726-164324.png" alt=""></p><p>在<code>MonkeyAppDylib.m</code>文件中加入SDK初始化代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;FLEX/FLEXManager.h&gt;</span><br><span class="line"></span><br><span class="line">void initCycriptServer()&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidFinishLaunchingNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;</span><br><span class="line">        [[FLEXManager sharedManager] showExplorer];</span><br><span class="line">        CYListenServer(6666);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如下:</p><p><img src="http://img.cdn.blogfshare.com/201501058944_.jpg" alt=""></p><h3 id="非越狱插件商店"><a href="#非越狱插件商店" class="headerlink" title="非越狱插件商店"></a>非越狱插件商店</h3><p>既然可以支持CocoaPods了，那么完全可以将自己写的非越狱插件传到CocoaPods，然后通过pod一键安装！</p><p>下面就将上面写的获取微信消息插件放到CocoaPods，新建<code>Cocoa Touch Framework</code>项目，然后增加头文件<code>CaptainHook.h</code>和自己的源文件<code>PrintWXMessage.m</code>，并将上面的代码拷贝过来，如下图所示:</p><p><img src="http://img.cdn.blogfshare.com/WX20170726-170518.png" alt=""></p><p>然后生成framework弄成zip包(zip包需要包含模拟器和真机的架构才能通过本地验证)，编辑<code>PrintWXMessage.podspec</code>文件内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |spec|</span><br><span class="line">  spec.name             = &quot;PrintWXMessage&quot;</span><br><span class="line">  spec.version          = &quot;1.0.0&quot;</span><br><span class="line">  spec.summary          = &quot;Print WX Message for MonkeyDev&quot;</span><br><span class="line">  spec.description      = &lt;&lt;-DESC</span><br><span class="line">                          - Print WX Message for MonkeyDev</span><br><span class="line">                        DESC</span><br><span class="line"></span><br><span class="line">  spec.homepage         = &quot;https://github.com/AloneMonkey/MonkeyDev&quot;</span><br><span class="line"></span><br><span class="line">  spec.license          = &#123; :type =&gt; &quot;BSD&quot;, :file =&gt; &quot;LICENSE&quot; &#125;</span><br><span class="line">  spec.author           = &#123; &quot;AloneMonkey&quot; =&gt; &quot;liupeiqing1993@163.com&quot; &#125;</span><br><span class="line">  spec.social_media_url = &quot;http://weibo.com/xiaoqing28&quot;</span><br><span class="line">  spec.platform         = :ios, &quot;8.0&quot;</span><br><span class="line">  spec.source           = &#123; :http =&gt; &quot;https://github.com/AloneMonkey/MonkeyDevPod/raw/master/PrintWXMessage/LatestBuild/PrintWXMessage.zip&quot;&#125;</span><br><span class="line">  spec.vendored_frameworks = &quot;PrintWXMessage.framework&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里source直接写的是zip包的地址，里面就是笔者生成的framework动态库。</p><p>增加私有CocosPods:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add MonkeyDevSpecs https://github.com/AloneMonkey/MonkeyDevSpecs.git</span><br></pre></td></tr></table></figure><p>将PrintWXMessage包发布到私有Pod:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push MonkeyDevSpecs PrintWXMessage.podspec</span><br></pre></td></tr></table></figure><p>修改Podfile文件内容如下，然后pod install安装，并且把原来写在<code>MonkeyAppDylib.m</code>的打印微信消息的代码删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://github.com/AloneMonkey/MonkeyDevSpecs.git&apos;</span><br><span class="line"></span><br><span class="line">target &apos;MonkeyAppDylib&apos; do</span><br><span class="line">     pod &apos;PrintWXMessage&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~ MonkeyApp pod install</span><br><span class="line">Cloning spec repo `alonemonkey` from `https://github.com/AloneMonkey/MonkeyDevSpecs.git`</span><br><span class="line">Analyzing dependencies</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing PrintWXMessage (1.0.0)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line"></span><br><span class="line">[!] Please close any current Xcode sessions and use `MonkeyPod.xcworkspace` for this project from now on.</span><br><span class="line">Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed.</span><br></pre></td></tr></table></figure><p>运行即可看到插件已经完美集成成功！！！</p><p><img src="http://img.cdn.blogfshare.com/WX20170726-184350.png" alt=""></p><p>MonkeyDev项目地址请点击阅读原文查看。</p>]]></content>
    
    <summary type="html">
    
      本文介绍的是一套逆向工具，可以在非越狱手机上给任意应用增加插件。在文末的示例中，作者拿微信举例，展示出在微信中打印收发消息的功能。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>MonkeyDev + CocoaPods 擦出的火花</title>
    <link href="http://www.alonemonkey.com/2017/07/24/monkeypod/"/>
    <id>http://www.alonemonkey.com/2017/07/24/monkeypod/</id>
    <published>2017-07-23T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>既然是Xcode工程，那是不是可以支持CocoaPods？ 在我开发MonkeyDev的时候就想到过这个问题，几天突然兴起测试了一下，然后发现……</p><h3 id="MonkeyDev-CocoaPods"><a href="#MonkeyDev-CocoaPods" class="headerlink" title="MonkeyDev + CocoaPods"></a>MonkeyDev + CocoaPods</h3><p><a href="https://github.com/AloneMonkey/MonkeyDev/wiki" target="_blank" rel="noopener">MonkeyDev</a>我就不说了，知道的人肯定会觉得这是神器，不知道的人先看Wiki吧，用上后你会喜欢上它的。</p><p>安装后之后，创建一个MonkeyApp类型的工程就叫MonkeyPod。</p><p>然后新建Podfile文件，内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target &apos;MonkeyPodDylib&apos; do</span><br><span class="line">pod &apos;FLEX&apos;, &apos;~&gt; 2.0&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后执行<code>pod install</code>。</p><p>完了之后打开<code>MonkeyPod.xcworkspace</code>。</p><p>然后打开文件<code>MonkeyPodDylib.m</code>导入头文件<code>#import &lt;FLEX/FLEXManager.h&gt;</code>，如下函数中加入初始化代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidFinishLaunchingNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123;</span><br><span class="line">    [[FLEXManager sharedManager] showExplorer];</span><br><span class="line">    CYListenServer(6666);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>直接编译，enmm…… 当然是会出错的。</p><p>点击Pods，将所有Target的<code>Build Active Architecture Only</code>改成<code>No</code>，如下图:</p><p><img src="http://img.cdn.blogfshare.com/script_1500909652281.png" alt="image"></p><p>然后编译，没有错误！直接运行！</p><p><img src="http://img.cdn.blogfshare.com/script_1500909967471.png" alt="image"></p><p>集成成功！</p><p>是不是感觉踏入了一个新的世界。。。</p><h3 id="待填的坑"><a href="#待填的坑" class="headerlink" title="待填的坑"></a>待填的坑</h3><ol><li>所有第三方库都必须设置<code>Build Active Architecture Only</code>改成<code>No</code></li><li>暂时只支持静态库</li></ol><p>不过嘛，，，，也只是突然试一下，说明这条道路还是挺光明的。</p><p>em，，，，有坑慢慢填，希望大家持续关注！！！</p>]]></content>
    
    <summary type="html">
    
      前段时间写了MonkeyDev支持非越狱自动集成，收到了广大网友的喜爱，今天试了试MonkeyDev能和CocoaPods擦除什么样的火花？ 我感觉开辟了一个新的世界。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>无须越狱、自动集成、只需要一个砸壳的应用---MonkeyDev</title>
    <link href="http://www.alonemonkey.com/2017/07/12/monkeydev-without-jailbreak/"/>
    <id>http://www.alonemonkey.com/2017/07/12/monkeydev-without-jailbreak/</id>
    <published>2017-07-11T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前基于iOSOpenDev重新弄了一个<a href="https://github.com/AloneMonkey/MonkeyDev" target="_blank" rel="noopener">MonkeyDev</a>，最初的版本支持Xcode 9和最新theos创建CaptainHook Tweak和Logos Tweak，后面又增加了一个Command-line Tool工具的支持。</p><p>然后想到如果是非越狱机器或者使用Xcode调试第三方应用的时候很多集成步骤，注入dylib，集成Reveal、Cycript等等，这些步骤其实都是重复性的工作，所以现带给大家MonkeyDev支持，一步到位!</p><p>那么需要怎么做呢？</p><h3 id="安装MonkeyDev"><a href="#安装MonkeyDev" class="headerlink" title="安装MonkeyDev"></a>安装MonkeyDev</h3><p>这个看<a href="http://www.alonemonkey.com/2017/06/28/monkeydev/">第一篇文章</a>，或者看<a href="https://github.com/AloneMonkey/MonkeyDev/blob/master/README-zh.md" target="_blank" rel="noopener">github文档</a> 就可以了。</p><p>很多人就是因为没有仔细看文档，然后出错了不知道怎么解决，所以先仔细看一遍文档把。</p><h3 id="使用-一步到位"><a href="#使用-一步到位" class="headerlink" title="使用:一步到位"></a>使用:一步到位</h3><p>CaptainHook Tweak、Logos Tweak and Command-line Tool的使用这里就不讲了，如果有不会的我到时再单独写一篇文章。</p><p>这里主要介绍的功能是MonkeyDev一步集成非越狱调试。</p><h4 id="准备好砸壳的ipa或者app"><a href="#准备好砸壳的ipa或者app" class="headerlink" title="准备好砸壳的ipa或者app"></a>准备好砸壳的ipa或者app</h4><p>第一步是准备好砸壳的ipa或者app，可以从第三方应用市场或者<a href="http://www.iphonecake.com" target="_blank" rel="noopener">http://www.iphonecake.com</a>去下一个。</p><h4 id="创建MonkeyApp项目"><a href="#创建MonkeyApp项目" class="headerlink" title="创建MonkeyApp项目"></a>创建MonkeyApp项目</h4><p>点击<code>File - New - Project...</code>创建iOS项目，选择<code>MonkeyApp</code>。</p><p><img src="http://img.cdn.blogfshare.com/script_1499873384414.png" alt="image"></p><p>创建完成之后，你会得到一个这样的工程:</p><p><img src="http://img.cdn.blogfshare.com/script_1499873471085.png" alt="image"></p><p>解析一下，这里我创建的项目名字就是<code>MonkeyApp</code>，所以下面对应的都是<code>MonkeyApp</code>，你自己创建的由你的项目名字而定!</p><p><code>MonkeyAppDylib</code>这个是将被注入目标App的动态库，你自己要hook的代码可以在<code>MonkeyAppDylib.m</code>文件里面写，我在里面写了一些Demo代码，支持OC runtime的HOOK，C函数的fishhook。</p><p><code>AntiAntiDebug</code>这个里面是反反调试的代码。</p><p><code>fishhook</code>这个是自动集成的fishhook模块。</p><p>下面<code>Framewroks</code>已经自动集成了<code>Reveal.framework</code>和<code>Cycript.framework</code>。</p><h4 id="拖入编译"><a href="#拖入编译" class="headerlink" title="拖入编译"></a>拖入编译</h4><p>我准备了一个砸壳了的ipa文件，然后我右键项目里面的<code>TargetApp</code>文件夹<code>Show in Finder</code>，把<code>ipa</code>文件拖入下面的位置(当然app文件夹也可以的):<br><img src="http://img.cdn.blogfshare.com/script_1499874017189.png" alt="image"><br><code>put ipa or app here</code>这个文件不要删除。</p><p>好了，还要做什么吗？ 不， 不用了。编译运行到非越狱手机。</p><p>打开电脑的<code>Reveal</code>，就可以看到界面了:</p><p><img src="http://img.cdn.blogfshare.com/script_1499874140165.png" alt="image"></p><p><code>Cycript</code>查看界面也没有问题:</p><p><img src="http://img.cdn.blogfshare.com/script_1499874354169.png" alt="image"></p><p>这里Cycript默认端口是<code>6666</code>。</p><h3 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h3><h4 id="动态库调试"><a href="#动态库调试" class="headerlink" title="动态库调试"></a>动态库调试</h4><p>在<code>MonkeyAppDylib.m</code>文件中写了自己的代码之后就可以直接下断点调试，效果如下:</p><p><img src="http://img.cdn.blogfshare.com/script_1499876622854.png" alt="image"></p><h4 id="Demo-App"><a href="#Demo-App" class="headerlink" title="Demo App"></a>Demo App</h4><p><code>MonkeyApp</code>不拖入App或者ipa的情况下，会有一个默认的App，以供读者自己测试，样子大概是这个样子····</p><p><img src="http://img.cdn.blogfshare.com/script_1499874626958.png" alt="image"></p><p>你可以自己修改<code>MonkeyAppDylib.m</code>里面的代码，这个是笔者针对Demo写的例子啦。。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CHDeclareClass(CustomViewController)</span><br><span class="line"></span><br><span class="line">CHOptimizedMethod(0, self, NSString*, CustomViewController,getMyName)&#123;</span><br><span class="line">    //get origin value</span><br><span class="line">    NSString* originName = CHSuper(0, CustomViewController, getMyName);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;origin name is:%@&quot;,originName);</span><br><span class="line">    </span><br><span class="line">    //get property</span><br><span class="line">    NSString* password = CHIvar(self,_password,__strong NSString*);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;password is %@&quot;,password);</span><br><span class="line">    </span><br><span class="line">    //change the value</span><br><span class="line">    return @&quot;AloneMonkey&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHConstructor&#123;</span><br><span class="line">    CHLoadLateClass(CustomViewController);</span><br><span class="line">    CHClassHook(0, CustomViewController, getMyName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认集成的库"><a href="#默认集成的库" class="headerlink" title="默认集成的库"></a>默认集成的库</h4><p>本工具会默认集成<code>Reveal.framework</code>和<code>Cycript.framework</code>,em…..</p><p>集成的<code>Reveal.framework</code>是最新版本的，所以你可能需要最新的Reveal，否则使用自己的<code>Reveal.framework</code>替换掉<code>/opt/MonkeyDev/frameworks</code>下面的<code>Reveal.framework</code>。</p><p><code>Cycript.framework</code>在<code>/opt/MonkeyDev/library</code>目录下面。</p><p>可以在如下位置删除掉默认集成的库:</p><p><img src="http://img.cdn.blogfshare.com/script_1499874870474.png" alt="image"></p><h4 id="增加自己的库"><a href="#增加自己的库" class="headerlink" title="增加自己的库"></a>增加自己的库</h4><p>emmm。。。。。</p><p>动态库的话，把你的<code>*.framework</code>文件拷贝到<code>/opt/MonkeyDev/frameworks</code>目录下面，然后在下图的位置add进去，emmm。。。。就可以了。</p><p><img src="http://img.cdn.blogfshare.com/script_1499874870474.png" alt="image"></p><p>静态库的话，直接增加到上面，指定search path就可以了，和正常开发没啥区别。。。</p><h3 id="增加自己的资源"><a href="#增加自己的资源" class="headerlink" title="增加自己的资源"></a>增加自己的资源</h3><p>如果想要加入storyboard或者bundle资源的话，将其拷贝到如下目录即可！</p><p><img src="http://img.cdn.blogfshare.com/WX20170717-163142.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      MonkeyDev现已实现CaptainHook Tweak、Logos Tweak and Command-line Tool工具创建，无须越狱一步集成Reveal和Cycript。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOSOpenDev修改版MonkeyDev</title>
    <link href="http://www.alonemonkey.com/2017/06/28/monkeydev/"/>
    <id>http://www.alonemonkey.com/2017/06/28/monkeydev/</id>
    <published>2017-06-27T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOSOpenDev"><a href="#iOSOpenDev" class="headerlink" title="iOSOpenDev"></a>iOSOpenDev</h3><p>首先<code>iOSOpenDev</code>是啥？他是个直接通过<code>Xcode</code>新建<code>Hook</code>的工程模板，然后编译生成安装deb。</p><p>网站:<a href="http://www.iosopendev.com/" target="_blank" rel="noopener">http://www.iosopendev.com/</a></p><p>可惜作者13年就不更新了，最新的还是<code>1.6-2</code>的版本。</p><p>这个版本在新版<code>Xcode</code>和<code>theos</code>都存在很多问题。</p><p>比如因为新版<code>Xcode</code>找不到某些文件导致安装出错，新版<code>theos</code>的修改导致新建出来的工程编译报错找不到<code>HBLogDebug</code>，以及很多问题。</p><p>对于习惯用<code>Xcode</code>来写代码的人，还是有点不能忍的。</p><p>所以就把<code>iOSOpenDev</code>的脚本和项目模板拿过来改了改。</p><p>已支持<code>CaptainHook Tweak</code>、<code>Logos Tweak</code>和<code>Command-line Tool</code>，使用起来方面很多。</p><p>目前已在最新thoes和Xcode 9测试通过。</p><h3 id="MonkeyDev"><a href="#MonkeyDev" class="headerlink" title="MonkeyDev"></a>MonkeyDev</h3><p>这是我的修改版本。</p><p>安装很简单，可以选择指定的Xcode安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xcode-select -s /Applications/Xcode-beta.app</span><br></pre></td></tr></table></figure><p>如果不指定的话，默认就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select -p</span><br></pre></td></tr></table></figure><p>然后安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AloneMonkey/MonkeyDev.git</span><br><span class="line">cd MonkeyDev/bin</span><br><span class="line">sudo ./md-install</span><br></pre></td></tr></table></figure><p>如果不用，运行下面的命令卸载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./md-uninstall</span><br></pre></td></tr></table></figure><p>然后新建项目就会出现了:</p><p><img src="http://img.cdn.blogfshare.com/script_1499260426855.png" alt="image"></p><p>该工具和<code>iOSOpenDev</code>共存。</p><p>当然使用前，你要安装最新版本的<code>theos</code>:</p><p><a href="https://github.com/theos/theos/" target="_blank" rel="noopener">https://github.com/theos/theos/</a></p><p>包括</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ldid</span><br></pre></td></tr></table></figure><p>然后设备免密码登录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &apos;&apos;</span><br><span class="line">ssh-copy-id -i /Users/用户名/.ssh/id_rsa root@IP</span><br></pre></td></tr></table></figure><p><code>Commonand + B</code> 编译，不安装，设置<code>MonkeyDevInstallOnAnyBuild</code>为<code>YES</code>，会自动打包安装到设备。</p><p><code>Command + Shift + i</code> 编译安装，但是这种方式是<code>Release</code>模式。看不到log输出。</p><p>在编译设置中可以自定义设备ip和ssh的端口:</p><p><img src="http://img.cdn.blogfshare.com/script_1499260498922.png" alt="image"></p><p>不设置的话，ip默认为<code>localhost</code>，port默认为<code>2222</code></p><p>当然你也可以在<code>~/.zshrc</code>或其它profile里面设置<code>MonkeyDevDevice</code>和<code>MonkeyDevPort</code>。</p><p>查看log的会可以使用<code>idevicesyslog</code>查看，毕竟带颜色。。。。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>后续会慢慢去完善这个工具，在使用中有什么问题也可以提出来，还是有很多东西需要去改进的。</p><p>恩，就这样。。。</p>]]></content>
    
    <summary type="html">
    
      由于iOSOpenDev的作者已经好久不更新了，安装会报错，新版的theos也会报错，使用起来很不爽，便拿它自己改了改，使用起来更加方便。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>0x01 Xcode调试一个LLVM Pass</title>
    <link href="http://www.alonemonkey.com/2017/06/02/writing-an-llvm-pass/"/>
    <id>http://www.alonemonkey.com/2017/06/02/writing-an-llvm-pass/</id>
    <published>2017-06-01T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前写过一篇《关于LLVM，这些东西你必须知道！》，先已收录在《iOS成长之路》。<br>其中讲解了编译器的编译过程，以及通过LLVM可以做哪些有意思的事情，今天继续来跟着官方的文档继续了解Pass。</p><p>获取代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone http://llvm.org/git/llvm.git</span><br><span class="line">git clone http://llvm.org/git/clang.git llvm/tools/clang</span><br><span class="line">git clone http://llvm.org/git/clang-tools-extra.git llvm/tools/clang/tools/extra</span><br><span class="line">git clone http://llvm.org/git/compiler-rt.git llvm/projects/compiler-rt</span><br></pre></td></tr></table></figure><p>编译成<code>Xcode项目</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G Xcode CMAKE_BUILD_TYPE=&quot;Debug&quot; ../llvm</span><br><span class="line"></span><br><span class="line">open LLVM.xcodeproj</span><br></pre></td></tr></table></figure><p>然后运行<code>clang</code>，准备工作做好后，继续Pass的学习。</p><h3 id="什么是Pass？"><a href="#什么是Pass？" class="headerlink" title="什么是Pass？"></a>什么是Pass？</h3><p>LLVM Pass是LLVM系统中非常重要和有趣的一个模块，Pass处理编译过程中代码的转换以及优化工作。</p><p>所有的Pass都是<a href="http://llvm.org/doxygen/classllvm_1_1Pass.html" target="_blank" rel="noopener">Pass</a>的子类，不同的Pass实现不同的作用可以继承<a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-modulepass" target="_blank" rel="noopener">ModulePass</a>,<a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-callgraphsccpass" target="_blank" rel="noopener">CallGraphSCCPass</a>,<a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-functionpass" target="_blank" rel="noopener">FunctionPass</a>,<a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-looppass" target="_blank" rel="noopener">LoopPass</a>,<a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-regionpass" target="_blank" rel="noopener">RegionPass</a>,<a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-basicblockpass" target="_blank" rel="noopener">BasicBlockPass</a>等类。</p><p>接下来开始介绍如何编写一个Pass，编译，加载以及运行的过程。</p><h3 id="编写hello-world"><a href="#编写hello-world" class="headerlink" title="编写hello world"></a>编写hello world</h3><p>先编写一个“Hello” Pass，只是简单的输出程序中每个非外部方法的方法名，不会修改程序本身的功能。官方Demo的源代码存在<code>lib/Transforms/Hello</code>文件夹。</p><h4 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h4><p>首先来看看环境的配置，如果你想编译一个新的Pass，你可以在<code>lib/Transforms/</code>下新建一个文件夹，这里我自己创建的是<code>PassDemo</code>，然后配置编译脚本去编译你的源代码。 在新建的目录下创建文件<code>CMakeLists.txt</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_llvm_loadable_module(LLVMPassDemo</span><br><span class="line">    Hello.cpp</span><br><span class="line"></span><br><span class="line">    PLUGIN_TOOL</span><br><span class="line">    opt</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后增加下面一行代码到<code>lib/Transforms/CMakeLists.txt</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(PassDemo)</span><br></pre></td></tr></table></figure><p>编译脚本指定了编译源文件<code>Hello.cpp</code>去编译生成动态库<code>$(LEVEL)/lib/LLVMPassDemo.dylib</code>。该文件可以被<code>opt</code>通过<code>-load</code>参数动态加载。如果不是Mac平台生成的后缀会不一样，比如<code>Linux</code>下是<code>so</code>。</p><p>配置好编译脚本后，打开<code>Xcode</code>项目，按<code>command + B</code>编译，然后在项目里面就可以看到刚刚增加的<code>Target</code>，打开<code>Hello.cpp</code>文件就可以编写代码了。</p><p><img src="http://img.cdn.blogfshare.com/script_1496846680486.png" alt="image"></p><h4 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h4><p>首先编辑<code>Hello.cpp</code>文件，导入头文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;llvm/Pass.h&quot;</span><br><span class="line">#include &quot;llvm/IR/Function.h&quot;</span><br><span class="line">#include &quot;llvm/Support/raw_ostream.h&quot;</span><br></pre></td></tr></table></figure><p>因为需要编一个<code>Pass</code>然后操作<code>Function</code>, 还可能输出一些东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace llvm;</span><br></pre></td></tr></table></figure><p>由于导入文件里面的方法是属于<code>llvm</code>命名空间的，所以先指定使用的命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace &#123;</span><br></pre></td></tr></table></figure><p>编写一个匿名的命名空间，<code>C++</code>中的匿名命名空间和<code>C</code>语言里面的<code>static</code>关键词一样，定义在匿名空间中的变量仅仅对当前文件可见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Hello : public FunctionPass&#123;</span><br></pre></td></tr></table></figure><p>定义<code>Hello</code>类继承<a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-functionpass" target="_blank" rel="noopener">FunctionPass</a>，后面会讲到不同用处的Pass会继承不同的父类，现在只需要知道，继承自<code>FunctionPass</code>可以操作程序中的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static char ID;</span><br><span class="line">Hello() : FunctionPass(ID)&#123;&#125;</span><br></pre></td></tr></table></figure><p>定义可供LLVM标示的Pass ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        bool runOnFunction(Function &amp;F) override&#123;</span><br><span class="line">            errs() &lt;&lt; &quot;Hello: &quot;;</span><br><span class="line">            errs().write_escaped(F.getName()) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个<a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-runonfunction" target="_blank" rel="noopener">runOnFunction</a>，重载继承自父类的抽象虚函数。在这个函数里面可以做针对于函数的特殊处理，这里只是打印出每个方法的名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char Hello::ID = 0;</span><br></pre></td></tr></table></figure><p>初始化Pass ID，LLVM使用ID的地址去识别一个Pass，所以初始化的值不重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;, false/* Only looks at CFG */, false/* Analysis Pass */);</span><br></pre></td></tr></table></figure><p>最后，<a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-registration" target="_blank" rel="noopener">注册我们的class</a> Hello， 指定命令行参数为<code>hello</code>，名字说明<code>Hello World Pass</code>。</p><p>整个<code>Hello.cpp</code>文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;llvm/Pass.h&quot;</span><br><span class="line">#include &quot;llvm/IR/Function.h&quot;</span><br><span class="line">#include &quot;llvm/Support/raw_ostream.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace llvm;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">    struct Hello : public FunctionPass&#123;</span><br><span class="line">        static char ID;</span><br><span class="line">        </span><br><span class="line">        Hello() : FunctionPass(ID)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        bool runOnFunction(Function &amp;F) override&#123;</span><br><span class="line">            errs() &lt;&lt; &quot;Hello: &quot;;</span><br><span class="line">            errs().write_escaped(F.getName()) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char Hello::ID = 0;</span><br><span class="line">static RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;, false/* Only looks at CFG */, false/* Analysis Pass */);</span><br></pre></td></tr></table></figure><p>选中<code>Target</code> <code>LLVMPassDemo</code> 按 <code>command + B</code>编译，编译完后会生成文件<code>build/Debug/lib/LLVMPassDemo.dylib</code>。</p><h4 id="使用opt加载"><a href="#使用opt加载" class="headerlink" title="使用opt加载"></a>使用<code>opt</code>加载</h4><p>上面在代码中通过<code>RegisterPass</code>注册了Pass，所以可以通过<code>opt -load</code>去加载动态库并指定参数<code>hello</code>。</p><p>准备源文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int add(int x, int y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;%d&quot;,add(3,4));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译源文件生成<code>bitcode</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path/to/build/Debug/bin/clang -emit-llvm -c test.mm -o test.bc</span><br></pre></td></tr></table></figure><p>然后编译启动参数, 选择<code>opt</code>target， 点击<code>Edit Scheme</code>。</p><p><img src="http://img.cdn.blogfshare.com/script_1496847664836.png" alt="image"></p><p>填入启动参数:</p><p><img src="http://img.cdn.blogfshare.com/script_1496847745200.png" alt="image"></p><p><code>command + R</code>运行。</p><p>输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello: _Z3addii</span><br><span class="line">Hello: main</span><br></pre></td></tr></table></figure><p>当然还可以断点调试啦~ </p><p><img src="http://img.cdn.blogfshare.com/script_1496847849551.png" alt="image"></p><p>通过<code>-help</code>可以看到注册的pass参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -load lib/LLVMPassDemo.dylib -help</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  Optimizations available:</span><br><span class="line">    -hello                                          - Hello World Pass</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#writing-an-llvm-pass-passmanager" target="_blank" rel="noopener">PassManager</a>还提供<code>--time-passes</code>参数输出你的Pass和其它Pass执行时间的对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -load lib/LLVMPassDemo.dylib -hello -time-passes -disable-output test.bc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Hello: _Z3addii</span><br><span class="line">Hello: main</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">                      ... Pass execution timing report ...</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">  Total Execution Time: 0.0003 seconds (0.0003 wall clock)</span><br><span class="line"></span><br><span class="line">   ---User Time---   --System Time--   --User+System--   ---Wall Time---  --- Name ---</span><br><span class="line">   0.0002 ( 75.3%)   0.0000 ( 27.9%)   0.0002 ( 62.1%)   0.0002 ( 62.7%)  Module Verifier</span><br><span class="line">   0.0001 ( 24.7%)   0.0001 ( 72.1%)   0.0001 ( 37.9%)   0.0001 ( 37.3%)  Hello World Pass</span><br><span class="line">   0.0002 (100.0%)   0.0001 (100.0%)   0.0003 (100.0%)   0.0003 (100.0%)  Total</span><br><span class="line"></span><br><span class="line">===-------------------------------------------------------------------------===</span><br></pre></td></tr></table></figure><p>tips:<br>为了在执行<code>opt</code>时能自动检测<code>LLVMPassDemo</code>模块有没有被修改，如果修改了，重新编译<code>LLVMPassDemo</code>模块，我们把<code>LLVMPassDemo</code>模块加到<code>opt</code>的依赖里面。</p><p>编辑<code>tools/opt/CMakeLists.txt</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add_llvm_tool(opt</span><br><span class="line">  AnalysisWrappers.cpp</span><br><span class="line">  BreakpointPrinter.cpp</span><br><span class="line">  GraphPrinters.cpp</span><br><span class="line">  NewPMDriver.cpp</span><br><span class="line">  PassPrinters.cpp</span><br><span class="line">  PrintSCC.cpp</span><br><span class="line">  opt.cpp</span><br><span class="line"></span><br><span class="line">  DEPENDS</span><br><span class="line">  intrinsics_gen</span><br><span class="line">  LLVMPassDemo</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h3 id="更多Pass类"><a href="#更多Pass类" class="headerlink" title="更多Pass类"></a>更多Pass类</h3><p>当你写一个新的Pass的时候，你需要根据需要去选择需要继承的父类，根据不同的作用有 <code>ImmutablePass</code>、<code>ModulePass</code>、<code>CallGraphSCCPass</code>、<code>FunctionPass</code>、<code>LoopPass</code>、<code>RegionPass</code>、<code>BasicBlockPass</code>、<code>MachineFunctionPass</code>。具体可以参考<a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="调用其它Pass"><a href="#调用其它Pass" class="headerlink" title="调用其它Pass"></a>调用其它Pass</h3><p>如果在编写的Pass中需要使用到其它Pass提供的函数功能，需要在:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void getAnalysisUsage(AnalysisUsage &amp;AU) const;</span><br></pre></td></tr></table></figure><p>说明，比如像要获取程序中存在循环的信息，可以在该函数里面申请需要依赖的Pass。</p><p>以上面的Pass为例，导入头文件<code>#include &quot;llvm/Analysis/LoopInfo.h&quot;</code>，在<code>getAnalysisUsage</code>中调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AU.addRequired&lt;LoopInfoWrapperPass&gt;();</span><br><span class="line">AU.setPreservesAll();</span><br></pre></td></tr></table></figure><p>然后就可以通过它提供接口获取存在循环的个数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LoopInfo &amp;LI = getAnalysis&lt;LoopInfoWrapperPass&gt;().getLoopInfo();</span><br><span class="line">int loopCounter = 0;</span><br><span class="line">for (LoopInfo::iterator i = LI.begin(), e = LI.end(); i != e; ++i) &#123;</span><br><span class="line">    loopCounter++;</span><br><span class="line">&#125;</span><br><span class="line">errs() &lt;&lt; &quot;loop num:&quot; &lt;&lt; loopCounter &lt;&lt; &quot;\n&quot;;</span><br></pre></td></tr></table></figure><p>测试程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int add(int x, int y) &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;%d&quot;,add(3,4));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello: _Z3addii</span><br><span class="line">loop num:1</span><br><span class="line">Hello: main</span><br><span class="line">loop num:0</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      基于官方文档Hello Pass通过Xcode编译和调试。
    
    </summary>
    
      <category term="llvm" scheme="http://www.alonemonkey.com/categories/llvm/"/>
    
    
      <category term="llvm" scheme="http://www.alonemonkey.com/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>iOS成长之路开售！</title>
    <link href="http://www.alonemonkey.com/2017/06/02/ios-book-pr/"/>
    <id>http://www.alonemonkey.com/2017/06/02/ios-book-pr/</id>
    <published>2017-06-01T16:00:00.000Z</published>
    <updated>2017-06-02T06:17:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过 3 个月的筹备 iOS 成长之路第二期和大家见面啦。经历了第一期的蹒跚发布后，终于在盛夏迎来了更好的第二期。这一期相比第一期更有料了，从第一期的 8 篇文章增加到 12 篇文章。</p><p>这一期的内容也提供了更多的广度和深度，从基于 Rx 的网络层设计到 AFN 源码解析，从 Swift 性能分析到 LLVM 体验，从 SpriteKit 到 APM 监控 SDK 的架构设计。希望大家会喜欢这一期。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><p>Chris Lattner 访谈录(下)</p><p>译者：@故胤道长，亚马逊 iOS 工程师，曾就职于 Uber。</p><p>博客：<a href="http://www.jianshu.com/u/8d5b91490ca5" target="_blank" rel="external">http://www.jianshu.com/u/8d5b91490ca5</a></p></li><li><p>动手玩 LLVM</p><p>作者：戴铭，滴滴出行技术专家。最近正在研究 iOS 编译相关底层技术，用来解决工程优化问题。</p><p>博客：<a href="https://ming1016.github.io/" target="_blank" rel="external">https://ming1016.github.io/</a></p></li><li><p>Swift 性能分析</p><p>作者：唐巧，小猿搜题产品技术负责人，6 年 iOS 开发经验，《iOS开发进阶》作者。</p><p>博客：<a href="http://blog.devtang.com/about/" target="_blank" rel="external">http://blog.devtang.com/about/</a></p></li><li><p>监控SDK的架构设计实践(<strong>6月5号上线</strong>)</p><p>作者：王朝成， @圣迪 , 饿了么移动架构师。耕耘移动基础设施的建设，致力于移动大数据与人工智能的结合</p><p>博客：<a href="http://www.jianshu.com/u/a774b58c9b89" target="_blank" rel="external">http://www.jianshu.com/u/a774b58c9b89</a></p></li><li><p>初识 LLVM</p><p>作者：@Alone_Monkey， 网易 iOS 工程师</p><p>博客：<a href="http://www.blogfshare.com" target="_blank" rel="external">www.blogfshare.com</a></p></li><li><p>TCP / IP 漫游</p><p>作者：@mrriddler，蚂蚁金服 iOS 工程师。</p><p>博客：<a href="http://blog.mrriddler.com" target="_blank" rel="external">blog.mrriddler.com</a></p></li><li><p>复用的精妙 - UITableView 复用技术原理分析</p><p>作者：冬瓜，微博：@冬瓜争做全栈瓜，爱奇艺 iOS 工程师。</p><p>博客：<a href="http://www.desgard.com" target="_blank" rel="external">http://www.desgard.com</a></p></li><li><p>试图取代 TCP 的 QUIC 协议到底是什么</p><p>作者：张星宇，@bestswifter，百度 iOS 工程师，喜欢探索问题的本质，讨厌一切不说人话的描述。正在学习前端，励志成为一名大前端全栈工程师。</p><p>博客：<a href="https://bestswifter.com/" target="_blank" rel="external">https://bestswifter.com/</a></p></li><li><p>AFNetworking 源码分析</p><p>作者： @涂耀辉 ，今日头条 iOS 工程师</p><p>博客：<a href="http://www.jianshu.com/u/14431e509ae8" target="_blank" rel="external">http://www.jianshu.com/u/14431e509ae8</a></p></li><li><p>SpriteKit 入门与实践</p><p>作者：郭鹏，丁香园资深 iOS 工程师</p></li><li><p>基于 Rx 的网络层实践</p><p>作者：李富强，@李富强Jason，美团外卖 iOS 架构师<br>博客：<a href="http://blog.csdn.net/colorapp" target="_blank" rel="external">http://blog.csdn.net/colorapp</a></p></li><li><p>iOS 组件化 —— 路由设计思路分析</p><p>作者： @一缕殇流化隐半边冰霜，饿了么 iOS 工程师，微博 @halfrost</p><p>博客：<a href="http://www.jianshu.com/u/12201cdd5d7a" target="_blank" rel="external">http://www.jianshu.com/u/12201cdd5d7a</a></p></li></ul><h2 id="淘宝购买地址"><a href="#淘宝购买地址" class="headerlink" title="淘宝购买地址"></a>淘宝购买地址</h2><p><a href="https://item.taobao.com/item.htm?id=552290531953" target="_blank" rel="external">https://item.taobao.com/item.htm?id=552290531953</a></p><p><img src="http://upload-images.jianshu.io/upload_images/225849-9d5cec83919493f9.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p>]]></content>
    
    <summary type="html">
    
      这一期的内容也提供了更多的广度和深度，从基于 Rx 的网络层设计到 AFN 源码解析，从 Swift 性能分析到 LLVM 体验，从 SpriteKit 到 APM 监控 SDK 的架构设计。希望大家会喜欢这一期。
    
    </summary>
    
      <category term="iOS" scheme="http://www.alonemonkey.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://www.alonemonkey.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章走进Mac逆向的世界</title>
    <link href="http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/"/>
    <id>http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/</id>
    <published>2017-05-30T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在玩了iOS逆向之后，看到Mac上面的应用莫名有了一种想要搞事情的冲动。其实在思想上iOS逆向和Mac逆向是差不多的，原理都差不多，走的流程可能不太一样，这篇文章的目的主要是让大家了解一下Mac上面玩逆向的大致流程和分析方法，所以在本文中去实现什么样的功能并不是重点，重点是让大家懂得怎么去分析找到实现。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>既然是逆向分析，总的有个目的，有目的才有动力，那么就以QQ撤回这个功能为例吧，网上也有很多文章讲解应该hook哪个函数，具体的分析过程却不是那么清晰，所以这里还是着重分析的过程，最终的实现大家自由发挥。</p><h3 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h3><p>在iOS逆向分析中，大致的思想是这样的(不同情况略有差异)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">界面分析  -&gt;  动态分析  -&gt;  静态分析  -&gt;  动态库注入  -&gt;  ...</span><br></pre></td></tr></table></figure><p>那么在Mac逆向过程中，也可以按照这个套路来搞一波。</p><h3 id="界面分析"><a href="#界面分析" class="headerlink" title="界面分析"></a>界面分析</h3><p>要分析QQ撤回的动作，这个动作是有在界面上面体现的，别人撤回一条消息后，那条消息会变成被撤回的通知。所以先分析界面上负责处理该状态的类，然后再去看类的调用。</p><p>在Mac上面也有类似iOS <code>Reveal</code>的工具叫做<a href="https://www.interface-inspector.com/" target="_blank" rel="noopener">Interface Inspector</a>。</p><p>下载下来后打开，发现是一个需要<code>License</code>的货，既然遇到了那就搞一搞吧。</p><p><img src="http://img.cdn.blogfshare.com/script_1496202790459.png" alt="image"></p><p>首先从界面关键词<code>Register</code>入手吧，拖到<code>hopper</code>,在<code>Strings</code>里面搜索<code>Register</code>。</p><p><img src="http://img.cdn.blogfshare.com/script_1496202987912.png" alt="image"></p><p>找到之后按<code>x</code>查找引用关系，发现是在<code>-[SMEnterLicenseViewController loadView]</code>这个函数里面存在这个字符串。</p><p><img src="http://img.cdn.blogfshare.com/script_1496203071610.png" alt="image"></p><p>继续找到<code>action</code>为<code>-[SMEnterLicenseViewController register:]</code>。</p><p>里面会调用<code>[r14 enterLicenseViewControllerDidSelectRegister:r15 withLicenseName:r12 code:rbx];</code></p><p><img src="http://img.cdn.blogfshare.com/script_1496203184764.png" alt="image"></p><p>这里<code>registerLicenseWithName:code:</code>里面是通过<code>[SMLicenseManager verifyLicenseWithName:code:]</code>验证的。</p><p>那直接修改代码返回<code>YES</code>。</p><p><code>Modify -&gt; Assemble Instruction...</code></p><p>输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov        eax, 0x1    //eax用来保存返回值</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>生成一个新的可执行文件，<code>File -&gt; Produce New Executable...</code>。</p><p>选择<code>Remove Signature</code>。</p><p>替换原可执行文件，然后打开，弹出了:</p><p><img src="http://img.cdn.blogfshare.com/script_1496203632361.png" alt="image"></p><p>看来它还验证签名了。</p><p>那么找到启动时的回调:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[SMAppDelegate applicationWillFinishLaunching:]</span><br></pre></td></tr></table></figure><p>可以找到对应的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ([rax codeSignState] != 0x2) goto loc_100024851;</span><br></pre></td></tr></table></figure><p>如果<code>codeSignState</code>返回不为2就会弹出刚刚那个。</p><p>所以这里把:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jne        loc_100024851</span><br></pre></td></tr></table></figure><p>对应的二进制<code>0F 85 CD 03 00 00</code>改成<code>0F 84 CD 03 00 00</code>。</p><p>重新打开不显示那个签名问题，但是直接闪退了。</p><p>猜测某些地方还有检测，然后<code>exit</code>或者<code>terminate</code>了。</p><p>在<code>Strings</code>中查找字符串找到<code>terminate:</code>的引用。</p><p><img src="http://img.cdn.blogfshare.com/script_1496214065433.png" alt="image"></p><p>查看每一处调用，发现这么一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void ___24+[SMLicenseManager load]_block_invoke(void * _block) &#123;</span><br><span class="line">    if ([SMLicenseManager verifyLicenseWithName:@&quot;Test User&quot; code:@&quot;GAWAE-8C69D-7LZ5H-9D8M3-HVEG7-KHNQC-CQ7RF-SEPQC-CRF82-G47U5-H6DKAB-8SKA7-EWSCM-7Q7SV-MYF4&quot;] != 0x0) &#123;</span><br><span class="line">            [*_NSApp terminate:0x0];</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者自己拿了假的<code>License</code>测试，如果通过就直接退出了。</p><p>所以这里<code>je         loc_10010ec26</code>对应二进制<code>74 1A</code>改成<code>75 1A</code>。</p><p>然后重新生成可执行文件，打开随便填入<code>License</code>注册即可。</p><p>额，好像有点扯远了，不过本文的目的就是为了学习Mac逆向的分析过程，所以这一部分并不是多余的。</p><p>当然这里还有坑，如何你发现<code>attach process</code>的时候报错的话，请参考<a href="http://bbs.iosre.com/t/fix-bug-for-interface-inspector-on-macos-serria/5665" target="_blank" rel="noopener">Fix Bug for Interface Inspector on macOS Serria</a>这篇文章重新编译<code>mach_inject_bundle_stub.bundle</code>。</p><p>终于准备好了，附加到QQ，选中聊天界面。可以找到<code>MQAIOChatViewController</code>这样的一个<code>ViewController</code>。</p><p><img src="http://img.cdn.blogfshare.com/script_1496216671572.png" alt="image"></p><p>下面通过动态跟踪函数调用来看看这个类的调用流程。</p><h3 id="动态跟踪"><a href="#动态跟踪" class="headerlink" title="动态跟踪"></a>动态跟踪</h3><p>动态跟踪的方法有多种，除了iOS逆向中使用的<a href="https://www.frida.re/" target="_blank" rel="noopener">Frida</a>, lldb , Mac上面还可以使用Dtrace。</p><h4 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h4><p><code>Frida</code>是一个通过<code>js</code>和<code>Native</code>交互的跨平台工具，可以通过<code>frida QQ</code>的方式附加，查看当前加载的类，类的方法等等。除此外还可以加载自己的<code>js</code>脚本<code>frida QQ -l trace.js</code>。</p><p>在<code>python</code>中，有可以<code>import frida</code>来获取设置以及目标等相关信息，同时也能调用<code>js</code>并获取返回结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjC.classes.MQAIOChatViewController.$methods</span><br></pre></td></tr></table></figure><p><code>frida</code>还提供了一个非常有用的功能，可以用于此处，也就是<code>frida-trace</code>。</p><p>可以通过这个工具来跟踪指定方法或者指定类的调用过程，这里感兴趣的是<code>MQAIOChatViewController</code>这个类的调用过程，所以可以通过如下命令来跟踪：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -m &quot;-[MQAIOChatViewController *]&quot; QQ</span><br></pre></td></tr></table></figure><p>然后撤回一条消息可以看到如下调用过程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">25623 ms  -[MQAIOChatViewController revokeMessages:0x618000206220 ]</span><br><span class="line">25623 ms     | -[MQAIOChatViewController topMsgListViewController]</span><br><span class="line">25623 ms     | -[MQAIOChatViewController topMsgListViewController]</span><br><span class="line">25625 ms     | -[MQAIOChatViewController scrollViewDidScrollToBottom:0x7fc28b0dffb0 ]</span><br><span class="line">25632 ms     | -[MQAIOChatViewController scheduleRecognitionLogic]</span><br><span class="line">25633 ms     | -[MQAIOChatViewController topMsgListViewController]</span><br><span class="line">25639 ms  -[MQAIOChatViewController isSimplestModel]</span><br><span class="line">25639 ms  -[MQAIOChatViewController isSimplestModel]</span><br><span class="line">25639 ms  -[MQAIOChatViewController isSimplestModel]</span><br></pre></td></tr></table></figure><p>这便找到了一个上层撤回的调用，后面还会继续深入。</p><h4 id="Dtrace"><a href="#Dtrace" class="headerlink" title="Dtrace"></a>Dtrace</h4><p>讲<code>lldb</code>前，先讲下<code>Dtrace</code>这个Linux上的动态追踪神器，可以通过它来监控应用程序或者内核的调用，所以这里可以用于监控OC函数的调用。</p><p>新建文件<code>trace.d</code>，写入内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/sbin/dtrace -s</span><br><span class="line"></span><br><span class="line">objc$target:MQAIOChatViewController::entry&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后找到<code>QQ</code>的进程id <code>ps -e | grep QQ</code>。再运行<code>dtrace</code>脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./trace.d -p 24105</span><br></pre></td></tr></table></figure><p>撤回消息可得到如下输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2  30436           -revokeMessages::entry</span><br><span class="line">2  44561  -topMsgListViewController:entry</span><br><span class="line">2  44561  -topMsgListViewController:entry</span><br><span class="line">2  30382 -scrollViewDidScrollToBottom::entry</span><br><span class="line">2  44569  -scheduleRecognitionLogic:entry</span><br><span class="line">2  44561  -topMsgListViewController:entry</span><br><span class="line">6  44608           -isSimplestModel:entry</span><br><span class="line">6  44608           -isSimplestModel:entry</span><br><span class="line">0  44608           -isSimplestModel:entry</span><br></pre></td></tr></table></figure><p>也可以直接运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dtrace -n &apos;objc$target:MQAIOChatViewController::entry&#123;&#125;&apos; -p 24105</span><br></pre></td></tr></table></figure><p>只是在文件里面可以进行更多的操作。</p><h4 id="lldb"><a href="#lldb" class="headerlink" title="lldb"></a>lldb</h4><p><code>lldb</code>这部分的动态跟踪在后面<code>Xcode</code>调试会有讲到。</p><h3 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h3><p>找到了函数之后，可以写个动态库注入为了方便调试以及动态库注入这里创建一个<code>dylib</code>的Xcode项目，选择<code>macOS Library</code>，点击创建，Type选择<code>Dynamic</code>。</p><p>为了<code>Hook</code>函数，先选择一个现成的库来做，可以选择:</p><ul><li><a href="https://github.com/alexzielenski/ZKSwizzle" target="_blank" rel="noopener">ZKSwizzle</a></li><li><a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a></li><li><a href="https://github.com/comex/substitute" target="_blank" rel="noopener">substitute</a></li><li>……</li></ul><p>这里你可能会想一个撤回一条命令一个文件哪有这么麻烦，而这些都是一般逆向中可能用到的，不针对功能。</p><p>我个人倾向于使用<code>substitute</code>，它有着和<code>substrate</code>一样的api接口。</p><p>那么首先要编译一个<code>Mac</code>平台的<code>substitute</code>动态库。</p><p>直接编译会报错<code>syscall</code>被弃用，到<a href="https://github.com/phracker/MacOSX-SDKs" target="_blank" rel="noopener">这里</a>下载一个早一点的比如<code>MacOSX10.11.sdk</code>，然后放到<code>/Applications/XCode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</code>下。</p><p>然后通过如下命令行编译:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --xcode-sdk macosx10.11 &amp;&amp; make -j8</span><br></pre></td></tr></table></figure><p>在<code>out</code>目录就可以看到生成的动态库。</p><p>查看动态库的加载地址，把其重命名为<code>libsubstitute.0.dylib</code>并拷贝到<code>/usr/local/lib/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  out git:(master) ✗ otool -L libsubstitute.dylib</span><br><span class="line">libsubstitute.dylib:</span><br><span class="line">/usr/local/lib/libsubstitute.0.dylib (compatibility version 0.0.0, current version 0.0.0)</span><br></pre></td></tr></table></figure><p>然后把头文件和动态库引入Xcode项目， 然后在构造函数里面hook<code>-[MQAIOChatViewController revokeMessages:]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;substrate.h&quot;</span><br><span class="line"></span><br><span class="line">@class MQAIOChatViewController;</span><br><span class="line"></span><br><span class="line">static void (*origin_MQAIOChatViewController_revokeMessages)(MQAIOChatViewController*,SEL,id);</span><br><span class="line">static void new_MQAIOChatViewController_revokeMessages(MQAIOChatViewController* self,SEL _cmd,id arrays)&#123;</span><br><span class="line">    NSLog(@&quot;revokeMessages:%@&quot;,arrays);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __attribute__((constructor)) initialize(void) &#123;</span><br><span class="line">    MSHookMessageEx(objc_getClass(&quot;MQAIOChatViewController&quot;),  @selector(revokeMessages:), (IMP)&amp;new_MQAIOChatViewController_revokeMessages, (IMP*)&amp;origin_MQAIOChatViewController_revokeMessages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成动态库<code>libMacQQRevoke.dylib</code>。</p><h3 id="动态库注入"><a href="#动态库注入" class="headerlink" title="动态库注入"></a>动态库注入</h3><p>动态库注入可以通过<code>DYLD_INSERT_LIBRARIES</code>注入，也可以直接注入到可执行文件的<code>Load Command</code>。</p><p>这里为了方便就直接通过环境变量注入了。</p><p>点击<code>Build Phases</code>左上角的<code>+</code>，然后点击<code>New Run Script Phase</code>。</p><p><img src="http://img.cdn.blogfshare.com/script_1496284722475.png" alt="image"></p><p>写入脚本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $&#123;TARGET_BUILD_DIR&#125;</span><br><span class="line">export DYLD_INSERT_LIBRARIES=./libMacQQRevoke.dylib &amp;&amp; /Applications/QQ.app/Contents/MacOS/QQ</span><br></pre></td></tr></table></figure><p><code>Command + B</code>， 注入动态库，运行QQ。</p><p>然后撤回消息，发现消息还在，并且控制台有如下输出。</p><p><img src="http://img.cdn.blogfshare.com/script_1496285419802.png" alt="image"></p><p>也就是Hook生效了，但是重启QQ后，那条消息还是变成了撤回状态。</p><p>这个时候需要继续往上层调用去探索。</p><h3 id="符号还原-Xcode调试"><a href="#符号还原-Xcode调试" class="headerlink" title="符号还原+Xcode调试"></a>符号还原+Xcode调试</h3><p>为了能看到<code>revokeMessages:</code>被调用的堆栈，先使用<a href="https://github.com/tobefuturer/restore-symbol" target="_blank" rel="noopener">restore-symbol</a>还原符号，然后再使用<a href="https://github.com/steakknife/unsign" target="_blank" rel="noopener">unsign</a>去掉签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./restore-symbol QQ -o QQ_symbol</span><br><span class="line">mv QQ_symbol QQ</span><br><span class="line">./unsign QQ</span><br><span class="line">mv QQ.unsigned QQ</span><br></pre></td></tr></table></figure><p>替换原可执行文件之后，在<code>new_MQAIOChatViewController_revokeMessages</code>断点，<code>Command + B</code>重新运行。</p><p>然后选择<code>Debug -&gt; Attach to Process</code>。</p><p><img src="http://img.cdn.blogfshare.com/script_1496287517422.png" alt="image"></p><p>附加到QQ进程。</p><p>撤回消息，Xcode便断在了<code>new_MQAIOChatViewController_revokeMessages</code>。</p><p>查看堆栈如下:</p><p><img src="http://img.cdn.blogfshare.com/script_1496287617990.png" alt="image"></p><p>因为block的符号没恢复，所以看来是block里面调用过来的。</p><p>找到block内存地址<code>0x103a69663</code>减去加载基地址<code>0x0000000003757000</code>,对应到文件偏移<code>0x0000000100312663</code>。</p><p><code>Hopper</code>加载文件按<code>g</code>跳转到指定地址:</p><p><img src="http://img.cdn.blogfshare.com/script_1496288222865.png" alt="image"></p><p><img src="http://img.cdn.blogfshare.com/script_1496288264564.png" alt="image"></p><p>所以可以找到是从:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[BHMessageChatModel revokeMessageModel:]</span><br><span class="line">-[MQAIOChatViewController chatMessageModel]</span><br></pre></td></tr></table></figure><p>调过来的。<br>在<code>revokeMessageModel</code>下断点<code>b -[BHMessageChatModel revokeMessageModel:]</code>，再撤回，可以看到调用堆栈。</p><p><img src="http://img.cdn.blogfshare.com/script_1496288458933.png" alt="image"></p><p>这下应该就比较清楚了。</p><p>那么就在比较上层的调用中去处理，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[RecallProcessor solveRecallNotify:isOnline:]</span><br><span class="line">-[QQMessageRevokeEngine handleRecallNotify:isOnline:]</span><br></pre></td></tr></table></figure><p>测试直接hook<code>-[QQMessageRevokeEngine handleRecallNotify:isOnline:]</code>是不会再本地删除的。</p><p>关于hook中的参数类型可以使用<a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">class-dump</a> dump出头文件，从头文件可以看到第一个参数是<code>struct RecallModel</code>类型。</p><h3 id="lldb-1"><a href="#lldb-1" class="headerlink" title="lldb"></a>lldb</h3><p>补充一下上面说的lldb跟踪程序，有了符号直接可以直接通过符号断点来跟踪程序。比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rb \[MQAIOChatViewController *\]</span><br><span class="line">br com add 1</span><br><span class="line">po $rdi</span><br><span class="line">x/s $rsi</span><br><span class="line">c</span><br><span class="line">DONE</span><br></pre></td></tr></table></figure><p>撤回消息即可看到打印结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">po $rdi</span><br><span class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</span><br><span class="line"></span><br><span class="line"> x/s $rsi</span><br><span class="line">0x10fa1f89e: &quot;revokeMessages:&quot;</span><br><span class="line"> c</span><br><span class="line">Process 35302 resuming</span><br><span class="line">Command #3 &apos;c&apos; continued the target.</span><br><span class="line"> po $rdi</span><br><span class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</span><br><span class="line"></span><br><span class="line"> x/s $rsi</span><br><span class="line">0x10fa07e45: &quot;topMsgListViewController&quot;</span><br><span class="line"> c</span><br><span class="line">Process 35302 resuming</span><br><span class="line">Command #3 &apos;c&apos; continued the target.</span><br><span class="line"> po $rdi</span><br><span class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</span><br><span class="line"></span><br><span class="line"> x/s $rsi</span><br><span class="line">0x10fa07e45: &quot;topMsgListViewController&quot;</span><br><span class="line"> c</span><br><span class="line">Process 35302 resuming</span><br><span class="line">Command #3 &apos;c&apos; continued the target.</span><br><span class="line"> po $rdi</span><br><span class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</span><br><span class="line"></span><br><span class="line"> x/s $rsi</span><br><span class="line">0x10fa1f973: &quot;scheduleRecognitionLogic&quot;</span><br><span class="line"> c</span><br><span class="line">Process 35302 resuming</span><br><span class="line">Command #3 &apos;c&apos; continued the target.</span><br><span class="line"> po $rdi</span><br><span class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</span><br><span class="line"></span><br><span class="line"> x/s $rsi</span><br><span class="line">0x10fa07e45: &quot;topMsgListViewController&quot;</span><br><span class="line"> c</span><br><span class="line">Process 35302 resuming</span><br><span class="line">Command #3 &apos;c&apos; continued the target.</span><br><span class="line"> po $rdi</span><br><span class="line">&lt;MQAIOChatViewController: 0x7fca3a8def10&gt;</span><br><span class="line"></span><br><span class="line"> x/s $rsi</span><br><span class="line">0x10f9e881c: &quot;isSimplestModel&quot;</span><br><span class="line"> c</span><br><span class="line">Process 35302 resuming</span><br><span class="line">Command #3 &apos;c&apos; continued the target.</span><br></pre></td></tr></table></figure><p>在x64汇编中，传递参数依次通过以下寄存器传递。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdi, rsi, rdx, rcx, r8, r9</span><br></pre></td></tr></table></figure><p>在很多动态分析的过程中可以借助lldb调试来帮助分析解决问题。</p><h3 id="MachO注入"><a href="#MachO注入" class="headerlink" title="MachO注入"></a>MachO注入</h3><p>为了避免每次从环境变量注入，还可以直接使用<a href="https://github.com/Tyilo/insert_dylib" target="_blank" rel="noopener">insert_dylib</a>注入可执行文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./insert_dylib --weak /path/to/dylib QQ QQ_patch</span><br><span class="line">mv QQ_patch QQ</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，Mac上的逆向和iOS逆向差不太多，反而Mac上面操作更方便一些，不用连着手机，还有像<code>Dtrace</code>这样的神器。</p><p>这篇文章主要还是领大家走进Mac逆向的世界，其它靠自己慢慢去探索~</p><p>相关工具和代码尽在github</p><p><a href="https://github.com/AloneMonkey/MacReverse" target="_blank" rel="noopener">https://github.com/AloneMonkey/MacReverse</a></p>]]></content>
    
    <summary type="html">
    
      除了iOS上面的逆向，其实Mac上面的逆向原理都差不多，这篇文章就带大家来试一把Mac上面的逆向。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>关于反调试&amp;反反调试那些事</title>
    <link href="http://www.alonemonkey.com/2017/05/25/antiantidebug/"/>
    <id>http://www.alonemonkey.com/2017/05/25/antiantidebug/</id>
    <published>2017-05-24T16:00:00.000Z</published>
    <updated>2017-05-25T11:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在逆向和保护的过程中，总会涉及到反调试和反反调试的问题，这篇文章主要是总结一下几种常见的反调试手段以及反反调试的方法。</p><h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><h4 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h4><p>为了方便应用软件的开发和调试，从Unix的早期版本开始就提供了一种对运行中的进程进行跟踪和控制的手段，那就是系统调用<code>ptrace()</code>。<br>通过<code>ptrace</code>可以对另一个进程实现调试跟踪，同时<code>ptrace</code>还提供了一个非常有用的参数那就是<code>PT_DENY_ATTACH</code>，这个参数用来告诉系统，阻止调试器依附。</p><p>所以最常用的反调试方案就是通过调用<code>ptrace</code>来实现反调试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#ifndef PT_DENY_ATTACH</div><div class="line">    #define PT_DENY_ATTACH 31</div><div class="line">#endif</div><div class="line"></div><div class="line">typedef int (*ptrace_ptr_t)(int _request, pid_t _pid, caddr_t _addr, int _data);</div><div class="line"></div><div class="line">ptrace(PT_DENY_ATTACH, 0, 0, 0);</div><div class="line"></div><div class="line">void *handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);</div><div class="line">ptrace_ptr_t ptrace_ptr = (ptrace_ptr_t)dlsym(handle, &quot;ptrace&quot;);</div><div class="line">ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);</div></pre></td></tr></table></figure><h4 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h4><p>当一个进程被调试的时候，该进程会有一个标记来标记自己正在被调试，所以可以通过<code>sysctl</code>去查看当前进程的信息，看有没有这个标记位即可检查当前调试状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">BOOL isDebuggerPresent()&#123;</div><div class="line">    int name[4];                //指定查询信息的数组</div><div class="line">    </div><div class="line">    struct kinfo_proc info;     //查询的返回结果</div><div class="line">    size_t info_size = sizeof(info);</div><div class="line">    </div><div class="line">    info.kp_proc.p_flag = 0;</div><div class="line">    </div><div class="line">    name[0] = CTL_KERN;</div><div class="line">    name[1] = KERN_PROC;</div><div class="line">    name[2] = KERN_PROC_PID;</div><div class="line">    name[3] = getpid();         </div><div class="line">    </div><div class="line">    if(sysctl(name, 4, &amp;info, &amp;info_size, NULL, 0) == -1)&#123;</div><div class="line">        NSLog(@&quot;sysctl error ...&quot;);</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>检测到调试器就退出，或者制造崩溃，或者隐藏工程啥的，当然也可以定时去查看有没有这个标记。</p><h4 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h4><p>为从实现从用户态切换到内核态，系统提供了一个系统调用函数<code>syscall</code>，上面讲到的<code>ptrace</code>也是通过系统调用去实现的。</p><p>在<a href="https://www.theiphonewiki.com/wiki/Kernel_Syscalls" target="_blank" rel="external">Kernel Syscalls</a>这里可以找到<code>ptrace</code>对应的编号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">26. ptrace               801e812c T</div></pre></td></tr></table></figure><p>所以如下的调用等同于调用<code>ptrace</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">syscall(26,31,0,0,0);</div></pre></td></tr></table></figure><h4 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h4><p><code>syscall</code>是通过软中断来实现从用户态到内核态，也可以通过汇编<code>svc</code>调用来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#ifdef __arm__</div><div class="line">        asm volatile(</div><div class="line">            &quot;mov r0,#31\n&quot;</div><div class="line">            &quot;mov r1,#0\n&quot;</div><div class="line">            &quot;mov r2,#0\n&quot;</div><div class="line">            &quot;mov r12,#26\n&quot;</div><div class="line">            &quot;svc #80\n&quot;</div><div class="line">        </div><div class="line">        );</div><div class="line">#endif</div><div class="line">#ifdef __arm64__</div><div class="line">        asm volatile(</div><div class="line">            &quot;mov x0,#26\n&quot;</div><div class="line">            &quot;mov x1,#31\n&quot;</div><div class="line">            &quot;mov x2,#0\n&quot;</div><div class="line">            &quot;mov x3,#0\n&quot;</div><div class="line">            &quot;mov x16,#0\n&quot;</div><div class="line">            &quot;svc #128\n&quot;</div><div class="line">        );</div><div class="line">#endif</div></pre></td></tr></table></figure><p>下面几种可能在实际中用到的比较少，不过也可以尝试一下。</p><h4 id="SIGSTOP"><a href="#SIGSTOP" class="headerlink" title="SIGSTOP"></a>SIGSTOP</h4><p>通过捕获系统<code>SIGSTOP</code>信号来判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, dispatch_get_main_queue());</div><div class="line">dispatch_source_set_event_handler(source, ^&#123;</div><div class="line">    NSLog(@&quot;SIGSTOP!!!&quot;);</div><div class="line">    exit(0);</div><div class="line">&#125;);</div><div class="line">dispatch_resume(source);</div></pre></td></tr></table></figure><h4 id="task-get-exception-ports"><a href="#task-get-exception-ports" class="headerlink" title="task_get_exception_ports"></a>task_get_exception_ports</h4><p>获取异常端口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct macosx_exception_info&#123;</div><div class="line">    exception_mask_t masks[EXC_TYPES_COUNT];</div><div class="line">    mach_port_t ports[EXC_TYPES_COUNT];</div><div class="line">    exception_behavior_t behaviors[EXC_TYPES_COUNT];</div><div class="line">    thread_state_flavor_t flavors[EXC_TYPES_COUNT];</div><div class="line">    mach_msg_type_number_t cout;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct macosx_exception_info *info = malloc(sizeof(struct macosx_exception_info));</div><div class="line">task_get_exception_ports(mach_task_self(),</div><div class="line">                                            EXC_MASK_ALL,</div><div class="line">                                            info-&gt;masks,</div><div class="line">                                            &amp;info-&gt;cout,</div><div class="line">                                            info-&gt;ports,</div><div class="line">                                            info-&gt;behaviors,</div><div class="line">                                            info-&gt;flavors);</div><div class="line"></div><div class="line">for(uint32_t i = 0; i &lt; info-&gt;cout; i ++)&#123;</div><div class="line">    if(info-&gt;ports[i] != 0 || info-&gt;flavors[i] == THREAD_STATE_NONE)&#123;</div><div class="line">        NSLog(@&quot;debugger detected via exception ports (null port)!\n&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="isatty"><a href="#isatty" class="headerlink" title="isatty"></a>isatty</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (isatty(1)) &#123;</div><div class="line">    NSLog(@&quot;Being Debugged isatty&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (!ioctl(1, TIOCGWINSZ)) &#123;</div><div class="line">    NSLog(@&quot;Being Debugged ioctl&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="反反调试-Tweak"><a href="#反反调试-Tweak" class="headerlink" title="反反调试(Tweak)"></a>反反调试(Tweak)</h3><p>了解了几种不同的反调试的方法，那么就可以根据几种常用的反调试方法来反反调试。</p><p>这里主要针对<code>ptrace</code>、<code>sysctl</code>、<code>syscall</code>来反反调试，做法就很简单了，hook函数，判断参数，返回结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">#import &lt;substrate.h&gt;</div><div class="line">#import &lt;sys/sysctl.h&gt;</div><div class="line"></div><div class="line">static int (*orig_ptrace) (int request, pid_t pid, caddr_t addr, int data);</div><div class="line">static int my_ptrace (int request, pid_t pid, caddr_t addr, int data)&#123;</div><div class="line">    if(request == 31)&#123;</div><div class="line">NSLog(@&quot;[AntiAntiDebug] - ptrace request is PT_DENY_ATTACH&quot;);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">return orig_ptrace(request,pid,addr,data);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void* (*orig_dlsym)(void* handle, const char* symbol);</div><div class="line">static void* my_dlsym(void* handle, const char* symbol)&#123;</div><div class="line">if(strcmp(symbol, &quot;ptrace&quot;) == 0)&#123;</div><div class="line">NSLog(@&quot;[AntiAntiDebug] - dlsym get ptrace symbol&quot;);</div><div class="line">return (void*)my_ptrace;</div><div class="line">    &#125;</div><div class="line">   return orig_dlsym(handle, symbol);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int (*orig_sysctl)(int * name, u_int namelen, void * info, size_t * infosize, void * newinfo, size_t newinfosize);</div><div class="line">static int my_sysctl(int * name, u_int namelen, void * info, size_t * infosize, void * newinfo, size_t newinfosize)&#123;</div><div class="line">int ret = orig_sysctl(name,namelen,info,infosize,newinfo,newinfosize);</div><div class="line">if(namelen == 4 &amp;&amp; name[0] == 1 &amp;&amp; name[1] == 14 &amp;&amp; name[2] == 1)&#123;</div><div class="line">struct kinfo_proc *info_ptr = (struct kinfo_proc *)info;</div><div class="line">        if(info_ptr &amp;&amp; (info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) != 0)&#123;</div><div class="line">            NSLog(@&quot;[AntiAntiDebug] - sysctl query trace status.&quot;);</div><div class="line">            info_ptr-&gt;kp_proc.p_flag ^= P_TRACED;</div><div class="line">            if((info_ptr-&gt;kp_proc.p_flag &amp; P_TRACED) == 0)&#123;</div><div class="line">                NSLog(@&quot;[AntiAntiDebug] trace status reomve success!&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">return ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void* (*orig_syscall)(int code, va_list args);</div><div class="line">static void* my_syscall(int code, va_list args)&#123;</div><div class="line">int request;</div><div class="line">    va_list newArgs;</div><div class="line">    va_copy(newArgs, args);</div><div class="line">    if(code == 26)&#123;</div><div class="line">        request = (long)args;</div><div class="line">        if(request == 31)&#123;</div><div class="line">            NSLog(@&quot;[AntiAntiDebug] - syscall call ptrace, and request is PT_DENY_ATTACH&quot;);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return (void*)orig_syscall(code, newArgs);</div><div class="line">&#125;</div><div class="line"></div><div class="line">%ctor&#123;</div><div class="line">MSHookFunction((void *)MSFindSymbol(NULL,&quot;_ptrace&quot;),(void*)my_ptrace,(void**)&amp;orig_ptrace);</div><div class="line">MSHookFunction((void *)dlsym,(void*)my_dlsym,(void**)&amp;orig_dlsym);</div><div class="line">MSHookFunction((void *)sysctl,(void*)my_sysctl,(void**)&amp;orig_sysctl);</div><div class="line">MSHookFunction((void *)syscall,(void*)my_syscall,(void**)&amp;orig_syscall);</div><div class="line"></div><div class="line">NSLog(@&quot;[AntiAntiDebug] Module loaded!!!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="反反调试-lldb"><a href="#反反调试-lldb" class="headerlink" title="反反调试(lldb)"></a>反反调试(lldb)</h3><p>通过<code>lldb</code>下断点，然后修改参数，或者直接返回也可以达到反反调试的效果。不过这里讲的是通过<code>python</code>脚本把过程自动化的一种方法。</p><p>为了方便直接使用<code>facebook</code>的<code>chisel</code>来增加脚本。</p><p>新建一个文件夹，然后使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">commandsDirectory = os.path.join(lldbHelperDir, &apos;文件名&apos;)</div><div class="line">loadCommandsInDirectory(commandsDirectory)</div></pre></td></tr></table></figure><p>加载即可。</p><p>下面是<code>python</code>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: utf-8 -*-</div><div class="line"></div><div class="line">&quot;&quot;&quot;</div><div class="line">反反调试脚本，过了反调试后记得:</div><div class="line">aadebug -d</div><div class="line">否则会很卡，如果有定时器定时检测，建议写tweak</div><div class="line">&quot;&quot;&quot;</div><div class="line"></div><div class="line">import lldb</div><div class="line">import fblldbbase as fb</div><div class="line">import fblldbobjcruntimehelpers as objc</div><div class="line"></div><div class="line">def lldbcommands():</div><div class="line">    return [</div><div class="line">        AMAntiAntiDebug()</div><div class="line">    ]</div><div class="line"></div><div class="line">class AMAntiAntiDebug(fb.FBCommand):</div><div class="line">    def name(self):</div><div class="line">        return &apos;aadebug&apos;</div><div class="line"></div><div class="line">    def description(self):</div><div class="line">        return &quot;anti anti debug ptrace syscall sysctl&quot;</div><div class="line"></div><div class="line">    def options(self):</div><div class="line">        return [</div><div class="line">            fb.FBCommandArgument(short=&apos;-d&apos;, long=&apos;--disable&apos;, arg=&apos;disable&apos;, boolean=True, default=False, help=&apos;disable anti anti debug.&apos;)</div><div class="line">        ]</div><div class="line"></div><div class="line">    def run(self, arguments, options):</div><div class="line">        if options.disable:</div><div class="line">            target = lldb.debugger.GetSelectedTarget()</div><div class="line">            target.BreakpointDelete(self.ptrace.id)</div><div class="line">            target.BreakpointDelete(self.syscall.id)</div><div class="line">            target.BreakpointDelete(self.sysctl.id)</div><div class="line">            print &quot;anti anti debug is disabled!!!&quot;</div><div class="line">        else:</div><div class="line">            self.antiPtrace()</div><div class="line">            self.antiSyscall()</div><div class="line">            self.antiSysctl()</div><div class="line">            print &quot;anti anti debug finished!!!&quot;</div><div class="line"></div><div class="line">    def antiPtrace(self):</div><div class="line">        ptrace = lldb.debugger.GetSelectedTarget().BreakpointCreateByName(&quot;ptrace&quot;)</div><div class="line">        if is64Bit():</div><div class="line">            ptrace.SetCondition(&apos;$x0==31&apos;)</div><div class="line">        else:</div><div class="line">            ptrace.SetCondition(&apos;$r0==31&apos;)</div><div class="line">        ptrace.SetScriptCallbackFunction(&apos;sys.modules[\&apos;&apos; + __name__ + &apos;\&apos;].ptrace_callback&apos;)</div><div class="line">        self.ptrace = ptrace</div><div class="line"></div><div class="line">    def antiSyscall(self):</div><div class="line">        syscall = lldb.debugger.GetSelectedTarget().BreakpointCreateByName(&quot;syscall&quot;)</div><div class="line">        if is64Bit():</div><div class="line">            syscall.SetCondition(&apos;$x0==26 &amp;&amp; *(int *)$sp==31&apos;)</div><div class="line">        else:</div><div class="line">            syscall.SetCondition(&apos;$r0==26 &amp;&amp; $r1==31&apos;)</div><div class="line">        syscall.SetScriptCallbackFunction(&apos;sys.modules[\&apos;&apos; + __name__ + &apos;\&apos;].syscall_callback&apos;)</div><div class="line">        self.syscall = syscall</div><div class="line"></div><div class="line">    def antiSysctl(self):</div><div class="line">        sysctl = lldb.debugger.GetSelectedTarget().BreakpointCreateByName(&quot;sysctl&quot;)</div><div class="line">        if is64Bit():</div><div class="line">            sysctl.SetCondition(&apos;$x1==4 &amp;&amp; *(int *)$x0==1 &amp;&amp; *(int *)($x0+4)==14 &amp;&amp; *(int *)($x0+8)==1&apos;)</div><div class="line">        else:</div><div class="line">            sysctl.SetCondition(&apos;$r1==4 &amp;&amp; *(int *)$r0==1 &amp;&amp; *(int *)($r0+4)==14 &amp;&amp; *(int *)($r0+8)==1&apos;)</div><div class="line">        sysctl.SetScriptCallbackFunction(&apos;sys.modules[\&apos;&apos; + __name__ + &apos;\&apos;].sysctl_callback&apos;)</div><div class="line">        self.sysctl = sysctl</div><div class="line"></div><div class="line">    def antiExit(self):</div><div class="line">        self.exit = lldb.debugger.GetSelectedTarget().BreakpointCreateByName(&quot;exit&quot;)</div><div class="line">        exit.SetScriptCallbackFunction(&apos;sys.modules[\&apos;&apos; + __name__ + &apos;\&apos;].exit_callback&apos;)</div><div class="line"></div><div class="line">#暂时只考虑armv7和arm64</div><div class="line">def is64Bit():</div><div class="line">    arch = objc.currentArch()</div><div class="line">    if arch == &quot;arm64&quot;:</div><div class="line">        return True</div><div class="line">    return False</div><div class="line"></div><div class="line">def ptrace_callback(frame, bp_loc, internal_dict):</div><div class="line">    print &quot;find ptrace&quot;</div><div class="line">    register = &quot;x0&quot;</div><div class="line">    if not is64Bit():</div><div class="line">        register = &quot;r0&quot;</div><div class="line">    frame.FindRegister(register).value = &quot;0&quot;</div><div class="line">    lldb.debugger.HandleCommand(&apos;continue&apos;)</div><div class="line"></div><div class="line">def syscall_callback(frame, bp_loc, internal_dict):</div><div class="line">    print &quot;find syscall&quot;</div><div class="line">    #不知道怎么用api修改sp指向的内容QAQ</div><div class="line">    lldb.debugger.GetSelectedTarget().GetProcess().SetSelectedThread(frame.GetThread())</div><div class="line">    if is64Bit():</div><div class="line">        lldb.debugger.HandleCommand(&apos;memory write &quot;$sp&quot; 0&apos;)</div><div class="line">    else:</div><div class="line">        lldb.debugger.HandleCommand(&apos;register write $r1 0&apos;)</div><div class="line">    lldb.debugger.HandleCommand(&apos;continue&apos;)</div><div class="line"></div><div class="line">def sysctl_callback(frame, bp_loc, internal_dict):</div><div class="line">    module = frame.GetThread().GetFrameAtIndex(1).GetModule()</div><div class="line">    currentModule = lldb.debugger.GetSelectedTarget().GetModuleAtIndex(0)</div><div class="line">    if module == currentModule:</div><div class="line">        print &quot;find sysctl&quot;</div><div class="line">        register = &quot;x2&quot;</div><div class="line">        if not is64Bit():</div><div class="line">            register = &quot;r2&quot;</div><div class="line">        frame.FindRegister(register).value = &quot;0&quot;</div><div class="line">    lldb.debugger.HandleCommand(&apos;continue&apos;)</div><div class="line"></div><div class="line">def exit_callback(frame, bp_loc, internal_dict):</div><div class="line">    print &quot;find exit&quot;</div><div class="line">    lldb.debugger.GetSelectedTarget().GetProcess().SetSelectedThread(frame.GetThread())</div><div class="line">    lldb.debugger.HandleCommand(&apos;thread return&apos;)</div><div class="line">    lldb.debugger.HandleCommand(&apos;continue&apos;)</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>反调试的方式有多种，可以通过:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ebugserver *:1234 -x auto /path/to/executable</div></pre></td></tr></table></figure><p>启动附加，然后断点测试。</p><p>本文代码地址:</p><p><a href="https://github.com/AloneMonkey/AntiAntiDebug" target="_blank" rel="external">AntiAntiDebug</a></p><p>有问题或者有更好的方法欢迎一起探讨。</p>]]></content>
    
    <summary type="html">
    
      最近发现好多人在弄反反调试的东西，顺便把以前的东西整理一下。
    
    </summary>
    
      <category term="逆向" scheme="http://www.alonemonkey.com/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://www.alonemonkey.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>在Centos部署nodejs</title>
    <link href="http://www.alonemonkey.com/2017/05/01/nodejs-on-centos/"/>
    <id>http://www.alonemonkey.com/2017/05/01/nodejs-on-centos/</id>
    <published>2017-04-30T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天突然发现自己买了一年快过期了的搬瓦工，除了少数时间拿来当梯子用用其它也没用上，所以流量还剩这么多。。。</p><p><img src="http://img.cdn.blogfshare.com/script_1493644280591.png" alt="image"></p><p>所以就想试试把本地写的nodejs的demo部署上去看看。</p><p>顺便把原来买的域名解析上去QAQ</p><h3 id="安装node和npm"><a href="#安装node和npm" class="headerlink" title="安装node和npm"></a>安装node和npm</h3><p>在官网下载编译好的node包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v6.10.2/node-v6.10.2-linux-x86.tar.xz</span><br><span class="line"></span><br><span class="line">xz -d node-v6.10.2-linux-x86.tar.xz</span><br><span class="line"></span><br><span class="line">tar -xf node-v6.10.2-linux-x86.tar</span><br></pre></td></tr></table></figure><p>解压后得到<code>node-v6.10.2-linux-x86</code>文件夹，里面有个<code>bin</code>目录，包含了我们需要的<code>node</code>和<code>npm</code>。</p><p>这里需要注意的是，<code>npm</code>是链接到<code>../lib/node_modules/npm/bin/npm-cli.js</code>的，不能直接拷贝到<code>/usr/bin/</code>,否则会出错，可以使用<code>ll</code>看到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rwxrwxr-x 1 500 500 28746408 Apr  4 05:04 node</span><br><span class="line">lrwxrwxrwx 1 500 500       38 May  1 08:03 npm -&gt; ../lib/node_modules/npm/bin/npm-cli.js</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>编辑<code>/etc/profile</code>文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>增加路径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH=$PATH:/home/node-v6.10.2-linux-x86/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="新建nodejs项目"><a href="#新建nodejs项目" class="headerlink" title="新建nodejs项目"></a>新建nodejs项目</h3><p>我自己的代码就不献丑了，这里就拿网上的一个demo来看看效果好了。<a href="https://my.oschina.net/u/1416844/blog/660951" target="_blank" rel="noopener">demo</a></p><p>安装git：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>ok, 在服务器拉下demo的代码，<code>npm install</code>，然后使用<code>pm2</code>来运行程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br><span class="line">pm2 start start.js -n demo</span><br></pre></td></tr></table></figure><p>输入<code>IP:8080</code>就能看到<code>Hello World!</code>了！</p><p>停止项目:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 stop demo -f</span><br></pre></td></tr></table></figure><h3 id="域名绑定到ip"><a href="#域名绑定到ip" class="headerlink" title="域名绑定到ip"></a>域名绑定到ip</h3><p>想起来原来有一个空闲的域名，正好试下域名绑定。</p><p>在域名的<code>A</code>记录填写服务器的ip地址，等其生效即可。</p><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>然后通过域名直接访问，发现并不能访问到我们的程序，因为默认访问的端口是<code>80</code>，而我们监听的端口是<code>8080</code>。这里可以通过：</p><ul><li>Nginx 反向代理</li><li>iptables 端口转发</li></ul><p>为了简单，直接用<code>iptables</code>端口转发了。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br><span class="line">service iptables save  //保存规则</span><br></pre></td></tr></table></figure><p>这下可以愉快的通过域名访问刚刚部署的nodejs服务了。。。</p>]]></content>
    
    <summary type="html">
    
      突然发现自己买了一年快到期的搬瓦工一直没用，就想试试部署一个简单的nodejs服务玩玩
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - RxGesture</title>
    <link href="http://www.alonemonkey.com/2017/04/10/rxswift-part-fifteen/"/>
    <id>http://www.alonemonkey.com/2017/04/10/rxswift-part-fifteen/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>RxGesture是RxSwift社区的产物，是对view手势的封装。</p><p>项目地址:<a href="https://github.com/RxSwiftCommunity/RxGesture" target="_blank" rel="noopener">RxGesture</a></p><p>话不多说，直接来看它的用法吧。</p><h3 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tapView.rx</span><br><span class="line">    .tapGesture()</span><br><span class="line">    .when(.recognized)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext:&#123;</span><br><span class="line">            _ in</span><br><span class="line">            print(&quot;tapped!!!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="双击"><a href="#双击" class="headerlink" title="双击"></a>双击</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tapView.rx</span><br><span class="line">    .tapGesture(numberOfTapsRequired: 2)</span><br><span class="line">    .when(.recognized)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext:&#123;</span><br><span class="line">            _ in</span><br><span class="line">            print(&quot;double tapped!!!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="下划"><a href="#下划" class="headerlink" title="下划"></a>下划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tapView.rx</span><br><span class="line">    .swipeGesture(.down)</span><br><span class="line">    .when(.recognized)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext:&#123;</span><br><span class="line">            _ in</span><br><span class="line">            print(&quot;swipe down!!!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="水平划动"><a href="#水平划动" class="headerlink" title="水平划动"></a>水平划动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tapView.rx</span><br><span class="line">    .swipeGesture([.left, .right])</span><br><span class="line">    .when(.recognized)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext:&#123;</span><br><span class="line">            _ in</span><br><span class="line">            print(&quot;swipe left or right!!!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="长按"><a href="#长按" class="headerlink" title="长按"></a>长按</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tapView.rx</span><br><span class="line">    .longPressGesture()</span><br><span class="line">    .when(.began)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext:&#123;</span><br><span class="line">            _ in</span><br><span class="line">            print(&quot;long press&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="拖动"><a href="#拖动" class="headerlink" title="拖动"></a>拖动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let panGesture = tapView.rx.panGesture().shareReplay(1)</span><br><span class="line">        </span><br><span class="line">panGesture</span><br><span class="line">    .when(.changed)</span><br><span class="line">    .asTranslation()</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123;</span><br><span class="line">            [unowned self] translation, _ in</span><br><span class="line">            self.label.text = String(format: &quot;(%.2f, %.2f)&quot;,translation.x, translation.y)</span><br><span class="line">            self.tapView.transform = CGAffineTransform(translationX: translation.x, y: translation.y)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">panGesture</span><br><span class="line">    .when(.ended)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123; _ in</span><br><span class="line">            print(&quot;panGesture end&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let rotationGesture = tapView.rx.rotationGesture().shareReplay(1)</span><br><span class="line">        </span><br><span class="line">rotationGesture</span><br><span class="line">    .when(.changed)</span><br><span class="line">    .asRotation()</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123;</span><br><span class="line">            [unowned self] rotation, _ in</span><br><span class="line">            self.label.text = String(format: &quot;%.2f rad&quot;, rotation)</span><br><span class="line">            self.tapView.transform = CGAffineTransform(rotationAngle: rotation)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">rotationGesture</span><br><span class="line">    .when(.ended)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123; _ in</span><br><span class="line">            print(&quot;rotationGesture end&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let pinchGesture = view.rx.pinchGesture().shareReplay(1)</span><br><span class="line">        </span><br><span class="line">pinchGesture</span><br><span class="line">    .when(.changed)</span><br><span class="line">    .asScale()</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123;</span><br><span class="line">            [unowned self] scale, _ in</span><br><span class="line">            self.label.text = String(format: &quot;x%.2f&quot;, scale)</span><br><span class="line">            self.tapView.transform = CGAffineTransform(scaleX: scale, y: scale)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">pinchGesture</span><br><span class="line">    .when(.ended)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123; _ in</span><br><span class="line">            print(&quot;pinchGesture end&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let transformGestures = view.rx.transformGestures().shareReplay(1)</span><br><span class="line">        </span><br><span class="line">transformGestures</span><br><span class="line">    .when(.changed)</span><br><span class="line">    .asTransform()</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123;</span><br><span class="line">            [unowned self] transform, _ in</span><br><span class="line">            self.label.numberOfLines = 3</span><br><span class="line">            self.label.text = String(format: &quot;[%.2f, %.2f,\n%.2f, %.2f,\n%.2f, %.2f]&quot;, transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty)</span><br><span class="line">            self.tapView.transform = transform</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">transformGestures</span><br><span class="line">    .when(.ended)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123;</span><br><span class="line">            [unowned self] _ in</span><br><span class="line">            self.label.numberOfLines = 1</span><br><span class="line">            print(&quot;transformGestures end&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="屏幕边缘"><a href="#屏幕边缘" class="headerlink" title="屏幕边缘"></a>屏幕边缘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">view.rx</span><br><span class="line">    .screenEdgePanGesture(edges: .right)</span><br><span class="line">    .when(.recognized)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123;</span><br><span class="line">            _ in</span><br><span class="line">            print(&quot;right edge&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tapView.rx</span><br><span class="line">    .anyGesture(.tap(), .swipe([.up, .down]))</span><br><span class="line">    .when(.recognized)</span><br><span class="line">    .subscribe(</span><br><span class="line">        onNext: &#123;</span><br><span class="line">            _ in</span><br><span class="line">            print(&quot;tap or up down&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    ).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>默认对手势是没有过滤的，所以你会收到初始化的第一个手势事件。</p><p>下面是几种手势对应的状态:</p><p><img src="http://img.cdn.blogfshare.com/script_1491817777814.png" alt="image"></p><p>还可以组合不同条件的手势:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tapView.rx</span><br><span class="line">    .anyGesture(</span><br><span class="line">        (.tap(), when: .recognized),</span><br><span class="line">        (.pan(), when: .ended)</span><br><span class="line">    )</span><br><span class="line">    .subscribe(onNext: &#123; gesture in</span><br><span class="line">        // Called whenever:</span><br><span class="line">        // - a tap is recognized (state == .recognized)</span><br><span class="line">        // - or a pan is ended (state == .ended)</span><br><span class="line">        print(&quot;tap is recognized or pan is ended&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码见github:</p><p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="noopener">RxSwiftRxGesture</a></p>]]></content>
    
    <summary type="html">
    
      RxGesture是RxSwift社区的产物，是对view手势的封装。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - Action</title>
    <link href="http://www.alonemonkey.com/2017/04/08/rxswift-part-fourteen/"/>
    <id>http://www.alonemonkey.com/2017/04/08/rxswift-part-fourteen/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2017-04-08T09:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Action是observable的一个抽象库，它定义了一个动作，传入输入的事件，然后对事件进行处理，返回处理结果。它有如下特点:</p><ul><li>只有<code>enabled</code>的时候才会执行，可以传入<code>enabledIf</code>参数</li><li>同时只能执行一个，下次<code>input</code>必须等上次的<code>action</code>执行完</li><li>可以分别处理错误和next</li></ul><h3 id="创建Action"><a href="#创建Action" class="headerlink" title="创建Action"></a>创建Action</h3><p><code>Action</code>被定义为一个类<code>Action&lt;Input, Element&gt;</code>,<code>Input</code>是输入的元素，<code>Element</code>是<code>Action</code>处理完之后返回的元素。</p><p>一个简单的例子，没有输入也没有输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let buttonAction: Action&lt;Void, Void&gt; = Action &#123;</div><div class="line">    print(&quot;Doing some work&quot;)</div><div class="line">    return Observable.empty()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或者传入用户名密码，返回登录结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let loginAction: Action&lt;(String,String), Bool&gt; = Action&#123;</div><div class="line">    (username, password) in</div><div class="line">    print(&quot;\(username) \(password)&quot;)</div><div class="line">    return Observable.just(true)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="连接Button"><a href="#连接Button" class="headerlink" title="连接Button"></a>连接Button</h3><p><code>buttonAction</code>怎么使用，你可以把它和<code>button</code>的点击绑定起来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.rx.action = buttonAction</div></pre></td></tr></table></figure><p>每次点击按钮<code>Action</code>都会执行，如果上一次的点击<code>Action</code>没有完成的话，这个的点击将会无效。</p><p>设置为<code>nil</code>去取消绑定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.rx.action = nil</div></pre></td></tr></table></figure><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>我们可以把输入的账号密码绑定到上面的<code>loginAction</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let usernameAndPassword = Observable.combineLatest(username.rx.text.orEmpty, password.rx.text.orEmpty)</div><div class="line">        </div><div class="line">login.rx.tap.asObservable()</div><div class="line">    .withLatestFrom(usernameAndPassword)</div><div class="line">    .bindTo(loginAction.inputs)</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">loginAction.elements</div><div class="line">    .filter&#123; $0 &#125;</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            _ in</div><div class="line">            print(&quot;login ok!&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div><div class="line"></div><div class="line">loginAction.errors</div><div class="line">    .subscribe(</div><div class="line">        onError:&#123;</div><div class="line">            error in</div><div class="line">            print(&quot;error&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure><p>输入的账号密码绑定到<code>loginAction.inputs</code>，然后订阅<code>loginAction</code>的结果。</p><h3 id="cell点击"><a href="#cell点击" class="headerlink" title="cell点击"></a>cell点击</h3><p>可以给每个<code>UITableViewCell</code>里面的button去绑定一个<code>Action</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let items = Observable.just(</div><div class="line">            (0...20).map&#123; &quot;\($0)&quot; &#125;</div><div class="line">        )</div><div class="line">        </div><div class="line">items.bindTo(tableview.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: UITableViewCell.self))&#123;</div><div class="line">    (row, elememt, cell) in</div><div class="line">    </div><div class="line">    let title = cell.viewWithTag(100) as! UILabel</div><div class="line">    </div><div class="line">    title.text = elememt</div><div class="line">    </div><div class="line">    var button = cell.viewWithTag(101) as! UIButton</div><div class="line">    </div><div class="line">    button.rx.action = CocoaAction &#123;</div><div class="line">        print(&quot;to do something \(elememt)&quot;)</div><div class="line">        return .empty()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;.disposed(by: disposeBag)</div></pre></td></tr></table></figure><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>除了绑定输入以外，还可以主动去执行<code>Action</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">loginAction.execute((&quot;admin&quot;,&quot;password&quot;))</div><div class="line">    .subscribe&#123;</div><div class="line">        print($0)</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure><p>通过<code>execute</code>传入账号密码，然后执行<code>Action</code>并订阅结果。</p><h3 id="enabledIf"><a href="#enabledIf" class="headerlink" title="enabledIf"></a>enabledIf</h3><p>只有当条件满足的时候<code>Action</code>才会执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let usernameCount = username.rx.text</div><div class="line">            .orEmpty</div><div class="line">            .asObservable()</div><div class="line">            .map&#123;</div><div class="line">                $0.characters.count &gt; 6</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">let validateUsername:Action&lt;String, Bool&gt; = Action(enabledIf: usernameCount, workFactory: &#123; input in</div><div class="line">    print(&quot;username validating.....&quot;)</div><div class="line">    return Observable.just(true)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">username.rx.controlEvent(.editingDidEnd)</div><div class="line">    .subscribe(</div><div class="line">        onNext:&#123;</div><div class="line">            [unowned self] _ in</div><div class="line">            validateUsername.execute(self.username.text ?? &quot;&quot;)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure><h3 id="UIAlertAction"><a href="#UIAlertAction" class="headerlink" title="UIAlertAction"></a>UIAlertAction</h3><p><code>UIAlert</code>的<code>Action</code>绑定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">validateUsername.elements</div><div class="line">    .observeOn(MainScheduler.instance)</div><div class="line">    .subscribe&#123;</div><div class="line">        [unowned self] _ in</div><div class="line">        print(&quot;username validate ok&quot;)</div><div class="line">        let alertController = UIAlertController(title: &quot;validate&quot;, message: &quot;username validate is ok!&quot;, preferredStyle: .alert)</div><div class="line">        var ok = UIAlertAction.Action(&quot;OK&quot;, style: .default)</div><div class="line">        ok.rx.action = CocoaAction &#123;</div><div class="line">            print(&quot;Alert&apos;s OK button was pressed&quot;)</div><div class="line">            return .empty()</div><div class="line">        &#125;</div><div class="line">        alertController.addAction(ok)</div><div class="line">        self.present(alertController, animated: true, completion: nil)</div><div class="line">    &#125;</div><div class="line">    .disposed(by: disposeBag)</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Action</code>可以用来定一个动作触发后的一个行为，也可以绑定多个动态到同一个<code>Action</code>，和<code>MVVM</code>结合的时候变得尤为合适。</p><p>代码见github:</p><p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="external">RxSwiftAction</a></p>]]></content>
    
    <summary type="html">
    
      Action是observable的一个抽象库，它定义了一个动作，传入输入的事件，然后对事件进行处理，返回处理结果。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 多线程调度</title>
    <link href="http://www.alonemonkey.com/2017/04/06/rxswift-part-thirteen/"/>
    <id>http://www.alonemonkey.com/2017/04/06/rxswift-part-thirteen/</id>
    <published>2017-04-05T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在前面我们基本都是在讲如何将事件转成序列，然后去驱动数据，很少考虑到当前在什么线程。</p><p>如果某些操作是耗时的、耗内存的是不应该在主线程进行，这样会阻塞主线程，导致界面卡顿等等。</p><p>所以我们要在不同的线程去执行不同的操作。</p><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>当<code>Rx</code>进行一些操作时，如果不去主动切换线程，那么它将一直在同一个线程进行。</p><p>但是调度器并不等同于线程，准确的说它是一个处理发生的上下文，这个上下文可以是一个线程也是是一个调度队列，甚至<code>OperationQueueScheduler</code>里面使用的<code>NSOperation</code>。<br>你可以在同一线程创建多个调度器，或者在不同线程使用同一个调度器，虽然有点奇怪，但是确定可以。</p><p><img src="http://img.cdn.blogfshare.com/script_1491484089713.png" alt="image"></p><p>有两种类型的调度器，串行调度器和并行调度器。</p><p>下面有几种不同的内建的调度器:</p><ul><li>当前线程调度器(CurrentThreadScheduler)(串行调度器)</li></ul><p>当前线程的调度，也是默认的调度器</p><ul><li>主调度器(MainScheduler)(串行调度器)</li></ul><p>主线程的调度</p><ul><li>串行调度队列调度器(SerialDispatchQueueScheduler)(串行调度)</li></ul><p>特殊队列调度<code>dispatch_queue_t</code></p><ul><li>并行调度队列调度器(ConcurrentDispatchQueueScheduler)(并发调度)</li></ul><p>特殊队列调度<code>dispatch_queue_t</code></p><ul><li>操作队列调度器(OperationQueueScheduler)(并发调度)</li></ul><p>特殊队列调度<code>NSOperationQueue</code>，适合在后台处理大块的工作。</p><p>传一个并行队列给串行调度器，会把它转化成串行队列。传一个串行队列给并行调度器，也不会引起任何问题，但是还是要避免这么做。</p><h3 id="subscribeOn-amp-observeOn"><a href="#subscribeOn-amp-observeOn" class="headerlink" title="subscribeOn() &amp; observeOn()"></a>subscribeOn() &amp; observeOn()</h3><h4 id="SubscribeOn"><a href="#SubscribeOn" class="headerlink" title="SubscribeOn"></a>SubscribeOn</h4><p>指定Observable自身在哪个调度器上执行</p><p><img src="http://img.cdn.blogfshare.com/script_1491488110688.png" alt="image"></p><h4 id="ObserveOn"><a href="#ObserveOn" class="headerlink" title="ObserveOn"></a>ObserveOn</h4><p>指定一个观察者在哪个调度器上观察这个Observable</p><p><img src="http://img.cdn.blogfshare.com/script_1491488168714.png" alt="image"></p><ul><li><code>SubscribeOn</code>的调用切换之前的线程。</li><li><code>ObserveOn</code>的调用切换之后的线程。</li><li><code>ObserveOn</code>之后，不可再调用<code>SubscribeOn</code>切换之后的线程。</li></ul><p>再来看下两者的组合使用:</p><p><img src="http://img.cdn.blogfshare.com/script_1491488363703.png" alt="image"></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>来看一个简单的例子，使用<code>RxAlamofire</code>从<code>github</code>搜索他人的项目，然后使用<code>ObjectMapper</code>解析json，最后展示到界面。由于涉及到网络以及解析，还有UI操作所以需求切换线程。</p><p>老套路，创建项目，导入<code>pod</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &apos;RxSwiftMultithreading&apos; do</span><br><span class="line"></span><br><span class="line">pod &apos;RxAlamofire/RxCocoa&apos;</span><br><span class="line">pod &apos;ObjectMapper&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p>界面还是一个<code>UITableView</code>和<code>UISearchBar</code>。</p><p>然后获取搜索的输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var rx_searchBarText: Observable&lt;String&gt; &#123;</span><br><span class="line">    return searchbar</span><br><span class="line">        .rx.text</span><br><span class="line">        .orEmpty</span><br><span class="line">        .filter &#123; $0.characters.count &gt; 0 &#125; // notice the filter new line</span><br><span class="line">        .throttle(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">        .distinctUntilChanged()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网络和解析"><a href="#网络和解析" class="headerlink" title="网络和解析"></a>网络和解析</h3><p>创建<code>Model</code>类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Repository: Mappable &#123;</span><br><span class="line">    var identifier: Int!</span><br><span class="line">    var language: String!</span><br><span class="line">    var url: String!</span><br><span class="line">    var name: String!</span><br><span class="line">    </span><br><span class="line">    required init?(map: Map) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    func mapping(map: Map) &#123;</span><br><span class="line">        identifier &lt;- map[&quot;id&quot;]</span><br><span class="line">        language &lt;- map[&quot;language&quot;]</span><br><span class="line">        url &lt;- map[&quot;url&quot;]</span><br><span class="line">        name &lt;- map[&quot;name&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发起网络请求，正常的写法那就是这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private func fetchRepositories() -&gt; Driver&lt;[Repository]&gt; &#123;</span><br><span class="line">    return repositoryName</span><br><span class="line">        .flatMapLatest &#123; text in</span><br><span class="line">            return RxAlamofire</span><br><span class="line">                .requestJSON(.GET, &quot;https://api.github.com/users/\(text)/repos&quot;)</span><br><span class="line">                .debug()</span><br><span class="line">                .catchError &#123; error in</span><br><span class="line">                    return Observable.never()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .map &#123; (response, json) -&gt; [Repository] in</span><br><span class="line">            if let repos = Mapper&lt;Repository&gt;().mapArray(json) &#123;</span><br><span class="line">                return repos</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .asDriver(onErrorJustReturn: [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把输入的文字转成网络请求序列，然后对请求的结果进行<code>map</code>转成<code>Repository</code>数组，最后返回。这里使用了<code>Driver</code>保证回到主线程，并不抛出错误。</p><p>然后在<code>ViewController</code>里面订阅结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">searchViewModel</span><br><span class="line">    .rx_repositories</span><br><span class="line">    .drive(tableview.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: UITableViewCell.self)) &#123; (row, repository, cell) in</span><br><span class="line">        cell.textLabel?.text = repository.name</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">searchViewModel</span><br><span class="line">    .rx_repositories</span><br><span class="line">    .drive(</span><br><span class="line">        onNext: &#123;</span><br><span class="line">            repositories in</span><br><span class="line">            if repositories.count == 0 &#123;</span><br><span class="line">                let alert = UIAlertController(title: &quot;sorry!&quot;, message: &quot;No repositories for this user.&quot;, preferredStyle: .alert)</span><br><span class="line">                alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil))</span><br><span class="line">                if self.navigationController?.visibleViewController?.isMember(of: UIAlertController.self) != true &#123;</span><br><span class="line">                    self.present(alert, animated: true, completion: nil)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h3><p>我们要确保网络请求和json解析在后台线程运行，所以使用<code>observeOn</code>主动切换线程，如果还要在之前或者之前才操作UI的话，也要切换线程如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func fetchRepositories() -&gt; Driver&lt;[Repository]&gt; &#123;</span><br><span class="line">    return repositoryName</span><br><span class="line">        .subscribeOn(MainScheduler.instance) // Make sure we are on MainScheduler</span><br><span class="line">        .do(onNext: &#123; response in</span><br><span class="line">            UIApplication.shared.isNetworkActivityIndicatorVisible = true</span><br><span class="line">        &#125;)</span><br><span class="line">        .observeOn(ConcurrentDispatchQueueScheduler(qos: .background))</span><br><span class="line">        .flatMapLatest &#123; text in // .background thread, network request</span><br><span class="line">            return RxAlamofire</span><br><span class="line">                .requestJSON(.get, &quot;https://api.github.com/users/\(text)/repos&quot;)</span><br><span class="line">                .debug()</span><br><span class="line">                .catchError &#123; error in</span><br><span class="line">                    return Observable.never()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .observeOn(ConcurrentDispatchQueueScheduler(qos: .background))</span><br><span class="line">        .map &#123; (response, json) -&gt; [Repository] in // again back to .background, map objects</span><br><span class="line">            if let repos = Mapper&lt;Repository&gt;().mapArray(JSONObject: json) &#123;</span><br><span class="line">                return repos</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .observeOn(MainScheduler.instance) // switch to MainScheduler, UI updates</span><br><span class="line">        .do(onNext: &#123; response in</span><br><span class="line">            UIApplication.shared.isNetworkActivityIndicatorVisible = false</span><br><span class="line">        &#125;)</span><br><span class="line">        .asDriver(onErrorJustReturn: []) // This also makes sure that we are on MainScheduler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在编写代码的时候要能意识到当前是在哪个线程进行的操作，并且把一些耗时操作放到后台，UI更新操作放到主线程。</p><p>代码见github:</p><p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="noopener">RxSwiftMultithreading</a></p>]]></content>
    
    <summary type="html">
    
      在进行某些耗时的操作时，常常需要切换到后台线程运行，更新UI的操作要确保在主线程进行，本文来看看Rx中的线程切换。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - 城市搜索</title>
    <link href="http://www.alonemonkey.com/2017/04/05/rxswift-part-twelve/"/>
    <id>http://www.alonemonkey.com/2017/04/05/rxswift-part-twelve/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Demo介绍"><a href="#Demo介绍" class="headerlink" title="Demo介绍"></a>Demo介绍</h3><p>这是一个通过<code>SearchBar</code>来搜索<code>tableview</code>内容的一个简单的例子，界面如下:</p><p><img src="http://img.cdn.blogfshare.com/script_1491380143544.png" alt="image"></p><h3 id="mock数据"><a href="#mock数据" class="headerlink" title="mock数据"></a>mock数据</h3><p>首先添加一个<code>mock</code>数据到<code>tableview</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//mock数据</span><br><span class="line">var shownCities = [String]() // Data source for UITableView</span><br><span class="line"></span><br><span class="line">let allCities = [&quot;ChangSha&quot;,</span><br><span class="line">                    &quot;HangZhou&quot;,</span><br><span class="line">                    &quot;ShangHai&quot;,</span><br><span class="line">                    &quot;BeiJing&quot;,</span><br><span class="line">                    &quot;ShenZhen&quot;,</span><br><span class="line">                    &quot;New York&quot;,</span><br><span class="line">                    &quot;London&quot;,</span><br><span class="line">                    &quot;Oslo&quot;,</span><br><span class="line">                    &quot;Warsaw&quot;,</span><br><span class="line">                    &quot;Berlin&quot;,</span><br><span class="line">                    &quot;Praga&quot;] // Our mocked API data source</span><br><span class="line"></span><br><span class="line">//数据源</span><br><span class="line">let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, String&gt;&gt;()</span><br><span class="line"></span><br><span class="line">dataSource.configureCell = &#123;</span><br><span class="line">    (_, tv, indexPath, element) in</span><br><span class="line">    let cell = tv.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)!</span><br><span class="line">    cell.textLabel?.text = &quot;\(element)&quot;</span><br><span class="line">    return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h3><p>获取用户的搜索输入，并简单判断前缀来返回结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//获取输入</span><br><span class="line">let searchResult = searchbar.rx</span><br><span class="line">                        .text</span><br><span class="line">                        .orEmpty</span><br><span class="line">                        .flatMapLatest&#123;</span><br><span class="line">                            [unowned self] query -&gt; Observable&lt;[String]&gt; in</span><br><span class="line">                            print(&quot;\(query)&quot;)</span><br><span class="line">                            if query.isEmpty&#123;</span><br><span class="line">                                return Observable.just([])</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                let results = self.allCities.filter&#123; $0.hasPrefix(query)&#125;</span><br><span class="line">                                return Observable.just(results)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        .shareReplay(1)</span><br></pre></td></tr></table></figure><h3 id="绑定结果"><a href="#绑定结果" class="headerlink" title="绑定结果"></a>绑定结果</h3><p>绑定结果到<code>dataSource</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">searchResult</span><br><span class="line">       .map&#123; [SectionModel(model:&quot;&quot;,items:$0)] &#125;</span><br><span class="line">       .bindTo(tableview.rx.items(dataSource: dataSource))</span><br><span class="line">       .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>现在已经能使用搜索了。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>运行后发现每次输入文字，都会发送请求，可以使用<code>debounce</code>指定一段时间后不再有输入再发送请求，同时使用<code>distinctUntilChanged</code>来过滤和上次一样的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let searchResult = searchbar.rx</span><br><span class="line">            .text</span><br><span class="line">            .orEmpty</span><br><span class="line">            .debounce(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">            .distinctUntilChanged()</span><br><span class="line">            .flatMapLatest&#123;</span><br><span class="line">                [unowned self] query -&gt; Observable&lt;[String]&gt; in</span><br><span class="line">                print(&quot;\(query)&quot;)</span><br><span class="line">                if query.isEmpty&#123;</span><br><span class="line">                    return Observable.just([])</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    let results = self.allCities.filter&#123; $0.hasPrefix(query)&#125;</span><br><span class="line">                    return Observable.just(results)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .shareReplay(1)</span><br></pre></td></tr></table></figure><p>还可以使用<code>filter</code>直接过滤空的搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let searchResult = searchbar.rx</span><br><span class="line">                        .text</span><br><span class="line">                        .orEmpty</span><br><span class="line">                        .debounce(0.5, scheduler: MainScheduler.instance)</span><br><span class="line">                        .distinctUntilChanged()</span><br><span class="line">                        .filter&#123; !$0.isEmpty &#125;</span><br><span class="line">                        .flatMapLatest&#123;</span><br><span class="line">                            [unowned self] query -&gt; Observable&lt;[String]&gt; in</span><br><span class="line">                            print(&quot;\(query)&quot;)</span><br><span class="line">                            return Observable.just(self.allCities.filter&#123; $0.hasPrefix(query)&#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                        .shareReplay(1)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里主要用到节流来处理用户输入，大家可以结合网络实时从接口获取数据，但是要主要线程切换。</p><p>代码见github:</p><p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="noopener">RxSwiftCitySearch</a></p>]]></content>
    
    <summary type="html">
    
      有tableview的地方大都会有搜索功能，如何使用RxSwift写一个简单的搜索功能，请看本文内容。
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift学习之旅 - share vs replay vs shareReplay</title>
    <link href="http://www.alonemonkey.com/2017/04/02/rxswift-part-eleven/"/>
    <id>http://www.alonemonkey.com/2017/04/02/rxswift-part-eleven/</id>
    <published>2017-04-01T16:00:00.000Z</published>
    <updated>2019-01-02T13:57:29.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><p>开发中最容易犯的错误是忘了每个订阅者都会导致<code>observable</code>重新执行链式调用。</p><p>like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func request() -&gt; Observable&lt;String&gt;&#123;</span><br><span class="line">        return Observable.create&#123;</span><br><span class="line">            observer in</span><br><span class="line">            print(&quot;发送网络请求&quot;)</span><br><span class="line">            observer.onNext(&quot;请求成功!&quot;)</span><br><span class="line">            return Disposables.create &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">let results = query.rx.text</span><br><span class="line">            .orEmpty</span><br><span class="line">            .asObservable()</span><br><span class="line">            .filter&#123;</span><br><span class="line">                $0.characters.count &gt; 0</span><br><span class="line">            &#125;</span><br><span class="line">            .flatMapLatest&#123;</span><br><span class="line">                query in</span><br><span class="line">                self.request()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        results.subscribe&#123;</span><br><span class="line">                print(&quot;订阅者 one: \($0)&quot;)</span><br><span class="line">            &#125;.disposed(by: disposeBag)</span><br><span class="line">        </span><br><span class="line">        results.subscribe&#123;</span><br><span class="line">                print(&quot;订阅者 two: \($0)&quot;)</span><br><span class="line">            &#125;.disposed(by: disposeBag)</span><br><span class="line">        </span><br><span class="line">        results.subscribe&#123;</span><br><span class="line">                print(&quot;订阅者 three: \($0)&quot;)</span><br><span class="line">            &#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>三个订阅者会发送三次请求。</p><h3 id="解决？"><a href="#解决？" class="headerlink" title="解决？"></a>解决？</h3><p>当有多个订阅者去订阅同一个<code>Observable</code>的时候，我们不希望<code>Observable</code>每次有新的订阅者都去执行。</p><p><code>RxSwift</code>提供了很多操作:</p><p><code>share()</code>、<code>replay()</code>、<code>replayAll()</code>、<code>shareReplay()</code>、<code>publish()</code>、<code>shareReplayLatesWhileConnected()</code>， 这么多个，应该选哪一个？</p><p>你现在能够说出他们之间的不同吗？</p><p>先看下总体的比较，有个大概的了解:</p><p><img src="http://img.cdn.blogfshare.com/script_1491368007455.png" alt="image"></p><p>1 表示重播最多<code>bufferSize</code>个事件<br>2 表示当订阅者的引用计数大于0时，重播一个事件</p><p><strong>共享订阅者</strong></p><p>多个订阅者订共享一个订阅者对象</p><p><strong>可连接</strong></p><p>可连接序列只有调用<code>connect</code>后才会开始发射值，可以等多个订阅者订阅后再连接。</p><p><strong>引用计数</strong></p><p>返回的<code>observable</code>记录了订阅者的数量，当订阅者数量从0变成1，订阅源序列，当订阅者数量从1变成0，取消订阅并重置源序列。</p><p>每次订阅者数量从0变成1源序列将会重新被订阅。</p><p><strong>重播事件</strong></p><p>重播已经发射的事件给订阅者。</p><p><code>replay(bufferSize)</code>和<code>shareReplay(bufferSize)</code>最多重播<code>bufferSize</code>个，而<code>shareReplayLatestWhileConnected</code>最多一个，当订阅者的引用计数变成0，<code>buffer</code>会被清空，所以引用计数从0变成1，订阅者不会受到重播事件。</p><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p>以下例子使用<code>interval</code>模拟用户输入文本，并进行搜索:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var results:Observable&lt;String&gt;!</span><br><span class="line">results = Observable&lt;Int&gt;</span><br><span class="line">            .interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">            .map&#123;</span><br><span class="line">                &quot;\($0)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            .flatMapLatest&#123;</span><br><span class="line">                query in</span><br><span class="line">                self.request(query)</span><br></pre></td></tr></table></figure><p>然后去订阅结果:</p><p><code>publish</code>原来讲到过，只有<code>connect</code>之后才会发射值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func publish()&#123;</span><br><span class="line">    let results = self.results.publish()</span><br><span class="line">    </span><br><span class="line">    results.subscribe&#123;</span><br><span class="line">            print(&quot;订阅者 one: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    results.subscribe&#123;</span><br><span class="line">            print(&quot;订阅者 two: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    _ = results.connect()</span><br><span class="line">    </span><br><span class="line">    delay(4)&#123;</span><br><span class="line">        print(&quot;three 订阅&quot;)</span><br><span class="line">        results.subscribe&#123;</span><br><span class="line">            print(&quot;订阅者 three: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: self.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">搜索 3  发送网络请求</span><br><span class="line">订阅者 one: next(3 请求成功!)</span><br><span class="line">订阅者 two: next(3 请求成功!)</span><br><span class="line">three 订阅                        //没有重播事件</span><br><span class="line">搜索 4  发送网络请求</span><br><span class="line">订阅者 one: next(4 请求成功!)</span><br><span class="line">订阅者 two: next(4 请求成功!)</span><br><span class="line">订阅者 three: next(4 请求成功!)</span><br></pre></td></tr></table></figure><h3 id="replayAll"><a href="#replayAll" class="headerlink" title="replayAll"></a>replayAll</h3><p>重播所有事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func replayAll()&#123;</span><br><span class="line">    </span><br><span class="line">    let results = self.results.replayAll()</span><br><span class="line">    </span><br><span class="line">    results.subscribe&#123;</span><br><span class="line">        print(&quot;订阅者 one: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    results.subscribe&#123;</span><br><span class="line">        print(&quot;订阅者 two: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    _ = results.connect()</span><br><span class="line">    </span><br><span class="line">    delay(4)&#123;</span><br><span class="line">        print(&quot;three 订阅&quot;)</span><br><span class="line">        results.subscribe&#123;</span><br><span class="line">            print(&quot;订阅者 three: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: self.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">搜索 3  发送网络请求</span><br><span class="line">订阅者 one: next(3 请求成功!)</span><br><span class="line">订阅者 two: next(3 请求成功!)</span><br><span class="line">three 订阅</span><br><span class="line">订阅者 three: next(0 请求成功!)     //订阅后，受到重播的所有事件</span><br><span class="line">订阅者 three: next(1 请求成功!)</span><br><span class="line">订阅者 three: next(2 请求成功!)</span><br><span class="line">订阅者 three: next(3 请求成功!)</span><br><span class="line">搜索 4  发送网络请求</span><br><span class="line">订阅者 one: next(4 请求成功!)</span><br><span class="line">订阅者 two: next(4 请求成功!)</span><br><span class="line">订阅者 three: next(4 请求成功!)</span><br></pre></td></tr></table></figure><h3 id="replay"><a href="#replay" class="headerlink" title="replay"></a>replay</h3><p><code>replay(bufferSize)</code>重播指定个数的事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func replay()&#123;</span><br><span class="line">    let results = self.results.replay(2)</span><br><span class="line">    </span><br><span class="line">    results.subscribe&#123;</span><br><span class="line">        print(&quot;订阅者 one: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    results.subscribe&#123;</span><br><span class="line">        print(&quot;订阅者 two: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    _ = results.connect()</span><br><span class="line">    </span><br><span class="line">    delay(4)&#123;</span><br><span class="line">        print(&quot;three 订阅&quot;)</span><br><span class="line">        results.subscribe&#123;</span><br><span class="line">            print(&quot;订阅者 three: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: self.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">搜索 3  发送网络请求</span><br><span class="line">订阅者 one: next(3 请求成功!)</span><br><span class="line">订阅者 two: next(3 请求成功!)</span><br><span class="line">three 订阅                        //重播最后2个事件</span><br><span class="line">订阅者 three: next(2 请求成功!)</span><br><span class="line">订阅者 three: next(3 请求成功!)</span><br><span class="line">搜索 4  发送网络请求</span><br><span class="line">订阅者 one: next(4 请求成功!)</span><br><span class="line">订阅者 two: next(4 请求成功!)</span><br><span class="line">订阅者 three: next(4 请求成功!)</span><br></pre></td></tr></table></figure><h3 id="share"><a href="#share" class="headerlink" title="share"></a>share</h3><p>订阅者从1变成0重置序列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func share()&#123;</span><br><span class="line">    let results = self.results.share()</span><br><span class="line">    </span><br><span class="line">    let sub = results.subscribe&#123;</span><br><span class="line">        </span><br><span class="line">            print(&quot;订阅者 one: \($0)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    delay(4)&#123;</span><br><span class="line">        //订阅者从1变成0</span><br><span class="line">        //可被观察序列重新发射</span><br><span class="line">        print(&quot;订阅者 one被销毁&quot;)</span><br><span class="line">        </span><br><span class="line">        sub.dispose()</span><br><span class="line">        </span><br><span class="line">        results.subscribe&#123;</span><br><span class="line">            print(&quot;订阅者 two: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: self.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">搜索 3  发送网络请求</span><br><span class="line">订阅者 one: next(3 请求成功!)</span><br><span class="line">订阅者 one被销毁</span><br><span class="line">搜索 0  发送网络请求                //从0开始重新发射</span><br><span class="line">订阅者 two: next(0 请求成功!)</span><br></pre></td></tr></table></figure><h3 id="shareReplay-bufferSize"><a href="#shareReplay-bufferSize" class="headerlink" title="shareReplay(bufferSize)"></a>shareReplay(bufferSize)</h3><p>在<code>share</code>的基础重播<code>bufferSize</code>个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func shareReplay()&#123;</span><br><span class="line">    let results = self.results.shareReplay(2)</span><br><span class="line">    </span><br><span class="line">    let sub1 = results.subscribe&#123;</span><br><span class="line">        print(&quot;订阅者 one: \($0)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    let sub2 = results.subscribe&#123;</span><br><span class="line">        print(&quot;订阅者 two: \($0)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    delay(4)&#123;</span><br><span class="line">        sub1.dispose()</span><br><span class="line">        sub2.dispose()</span><br><span class="line">        </span><br><span class="line">        print(&quot;three 订阅&quot;)</span><br><span class="line">        results.subscribe&#123;</span><br><span class="line">            print(&quot;订阅者 three: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: self.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">搜索 3  发送网络请求</span><br><span class="line">订阅者 one: next(3 请求成功!)</span><br><span class="line">订阅者 two: next(3 请求成功!)</span><br><span class="line">three 订阅</span><br><span class="line">订阅者 three: next(2 请求成功!)         //虽然订阅者都被销毁，但是仍收到最后两个值</span><br><span class="line">订阅者 three: next(3 请求成功!)</span><br><span class="line">搜索 0  发送网络请求</span><br><span class="line">订阅者 three: next(0 请求成功!)</span><br></pre></td></tr></table></figure><h3 id="shareReplayLatestWhileConnected"><a href="#shareReplayLatestWhileConnected" class="headerlink" title="shareReplayLatestWhileConnected"></a>shareReplayLatestWhileConnected</h3><p>订阅者从1变成0，缓存区被清空:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func shareReplayLatestWhileConnected()&#123;</span><br><span class="line">    let results = self.results.shareReplayLatestWhileConnected() // test  shareReplay(1)</span><br><span class="line">    </span><br><span class="line">    let sub = results.subscribe&#123;</span><br><span class="line">                print(&quot;订阅者 one: \($0)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    delay(4)&#123;</span><br><span class="line">        sub.dispose()</span><br><span class="line">        //订阅者从1变成0， 缓存的一个值被清掉了，所以不会收到最后一个值</span><br><span class="line">        print(&quot;two 订阅&quot;)</span><br><span class="line">        results.subscribe&#123;</span><br><span class="line">            print(&quot;订阅者 two: \($0)&quot;)</span><br><span class="line">        &#125;.disposed(by: self.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">搜索 3  发送网络请求</span><br><span class="line">订阅者 one: next(3 请求成功!)</span><br><span class="line">two 订阅</span><br><span class="line">搜索 0  发送网络请求</span><br><span class="line">订阅者 two: next(0 请求成功!)</span><br><span class="line">搜索 1  发送网络请求</span><br><span class="line">订阅者 two: next(1 请求成功!)</span><br></pre></td></tr></table></figure><p>试试改成<code>shareReplay(1)</code>，或者不销毁<code>sub</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以结合上面的例子，在实际运用中选择合适的接口。</p><p>代码见github:</p><p><a href="https://github.com/AloneMonkey/RxSwiftStudy" target="_blank" rel="noopener">RxSwiftShareOrReplay</a></p>]]></content>
    
    <summary type="html">
    
      share(), replay(), replayAll(), shareReplay(), publish(), and even shareReplayLatesWhileConnected()什么时候用哪个？？？
    
    </summary>
    
      <category term="rxswift" scheme="http://www.alonemonkey.com/categories/rxswift/"/>
    
    
      <category term="RxSwift" scheme="http://www.alonemonkey.com/tags/RxSwift/"/>
    
  </entry>
  
</feed>
